<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <meta property="og:site_name" content="爱折腾的工程师">
    <meta property="og:type" content="article">

    
    <meta property="og:image" content="https://www.iceyao.com.cn/img/home-bg.jpeg">
    <meta property="twitter:image" content="https://www.iceyao.com.cn/img/home-bg.jpeg" />
    

    
    <meta name="title" content="Golang知识点大杂烩" />
    <meta property="og:title" content="Golang知识点大杂烩" />
    <meta property="twitter:title" content="Golang知识点大杂烩" />
    

    
    <meta name="description" content="iceyao，程序员, 开源爱好者，生活探险家 | 这里是iceyao的博客，与你一起发现更大的世界。">
    <meta property="og:description" content="iceyao，程序员, 开源爱好者，生活探险家 | 这里是iceyao的博客，与你一起发现更大的世界。" />
    <meta property="twitter:description" content="iceyao，程序员, 开源爱好者，生活探险家 | 这里是iceyao的博客，与你一起发现更大的世界。" />
    

    
    <meta property="twitter:card" content="summary" />
    
    

    <meta name="keyword"  content="iceyao, IceYao&#39;s Blog, 博客, 个人网站, 互联网, Web, 云原生, PaaS, Istio, Kubernetes, 微服务, Microservice">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>Golang知识点大杂烩 | 爱折腾的工程师 | IceYao&#39;s Blog</title>

    <link rel="canonical" href="/post/2020-08-09-golang_knowledge/">

    
    
    
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    
    <link rel="stylesheet" href="/css/hugo-theme-cleanwhite.min.css">

    
    <link rel="stylesheet" href="/css/zanshang.css">

    
    <link rel="stylesheet" href="/css/font-awesome.all.min.css">

    
    

    
    <script src="/js/jquery.min.js"></script>

    
    <script src="/js/bootstrap.min.js"></script>

    
    <script src="/js/hux-blog.min.js"></script>

    
    <script src="/js/lazysizes.min.js"></script>

    
    

</head>



<script async src="https://www.googletagmanager.com/gtag/js?id=G-9J7CKFVPPM"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-9J7CKFVPPM', { 'anonymize_ip': false });
}
</script>






<nav class="navbar navbar-default navbar-custom navbar-fixed-top">

    <div class="container-fluid">
        
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">爱折腾的工程师</a>
        </div>

        
        
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">All Posts</a>
                    </li>
                    
                        
                    
                    
		    
                        <li><a href="/archive//">ARCHIVE</a></li>
                    
                        <li><a href="/notes//">NOTES</a></li>
                    
                        <li><a href="/about//">ABOUT</a></li>
                    
		            <li>
                        <a href="/search"><i class="fa fa-search"></i></a>
		           </li>
                </ul>
            </div>
        </div>
        
    </div>
    
</nav>
<script>
    
    
    
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        
            $navbar.className = " ";
            
            setTimeout(function(){
                
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>




<style type="text/css">
    header.intro-header {
        background-image: url('/img/home-bg.jpeg')
    }
</style>

<header class="intro-header" >

    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/go" title="Go">
                            Go
                        </a>
                        
                    </div>
                    <h1>Golang知识点大杂烩</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        
                            Posted by 
                            
                                    爱折腾的工程师
                             
                            on 
                            Sunday, August 9, 2020
                            
                            
                            
                            
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>




<article>
    <div class="container">
        <div class="row">

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                
                <h2 id="golang知识点">Golang知识点</h2>
<h3 id="defer-7个知识点">defer 7个知识点</h3>
<h4 id="defer的执行顺序">defer的执行顺序</h4>
<p>有多个defer的时候，是按照栈的关系来执行</p>
<h4 id="defer与return谁先谁后">defer与return谁先谁后</h4>
<p>return之后的语句先执行，defer后的语句后执行</p>
<h4 id="函数的返回值初始化与defer间接影响">函数的返回值初始化与defer间接影响</h4>
<p>只要声明函数的返回值变量名称，就会在函数初始化时候为之赋值为0，而且在函数体作用域可见</p>
<h4 id="有名函数返回值遇见defer情况">有名函数返回值遇见defer情况</h4>
<p>通过知识点2得知，先return，再defer，所以在执行完return之后，还要再执行defer里的语句，依然可以修改本应该返回的结果</p>
<h4 id="defer遇见panic">defer遇见panic</h4>
<p>遇到panic时，遍历本协程的defer链表，并执行defer。在执行defer过程中:遇到recover则停止panic，返回recover处继续往下执行。
如果没有遇到recover，遍历完本协程的defer链表后，向stderr抛出panic信息</p>
<h4 id="defer中包含panic">defer中包含panic</h4>
<p>panic仅有最后一个可以被revover捕获</p>
<h4 id="defer下的函数参数包含子函数">defer下的函数参数包含子函数</h4>
<pre tabindex="0"><code>func function(index int, value int) int {

    fmt.Println(index)

    return index
}

func main() {
    defer function(1, function(3, 0))
    defer function(2, function(4, 0))
}
</code></pre><p>执行顺序：function(3) -&gt; function(4) -&gt; function(2) -&gt; function(1)</p>
<h3 id="atomicvalue-vs-syncmutex">atomic.Value vs sync.Mutex</h3>
<p>原子操作由底层硬件支持，而锁则由操作系统的调度器实现。锁应当用来保护一段逻辑，对于一个变量更新的保护，原子操作通常会更有效率，并且更能利用计算机多核的优势，
如果要更新的是一个复合对象，则应当使用atomic.Value封装好的实现。</p>
<h3 id="进程-vs-线程-vs-协程">进程 vs 线程 vs 协程</h3>
<h4 id="进程">进程</h4>
<blockquote>
<p>进程是系统资源分配的最小单位, 进程包括文本段text region、数据段data region和堆栈段stack region等。
进程的创建和销毁都是系统资源级别的，因此是一种比较昂贵的操作，
进程是抢占式调度其有三个状态:等待态、就绪态、运行态。进程之间是相互隔离的，
它们各自拥有自己的系统资源, 更加安全但是也存在进程间通信不便的问题。</p>
</blockquote>
<h4 id="线程">线程</h4>
<blockquote>
<p>进程是线程的载体容器，多个线程除了共享进程的资源还拥有自己的一少部分独立的资源，
因此相比进程而言更加轻量，进程内的多个线程间的通信比进程容易，但是也同样带来了同步和互斥的问题和线程安全问题，
尽管如此多线程编程仍然是当前服务端编程的主流，线程也是CPU调度的最小单位，多线程运行时就存在线程切换问题</p>
</blockquote>
<h4 id="协程">协程</h4>
<blockquote>
<p>协程在有的资料中称为微线程或者用户态轻量级线程，协程调度不需要内核参与而是完全由用户态程序来决定，
因此协程对于系统而言是无感知的。协程由用户态控制就不存在抢占式调度那样强制的CPU控制权切换到其他进线程，
多个协程进行协作式调度，协程自己主动把控制权转让出去之后，其他协程才能被执行到，
这样就避免了系统切换开销提高了CPU的使用效率。</p>
</blockquote>
<h4 id="小结">小结</h4>
<ul>
<li>进程/线程抢占式调度由系统内核调度，成本大效率低</li>
<li>协程协作式调度由用户态调度，成本低效率高</li>
</ul>
<h4 id="gpm调度">GPM调度</h4>
<p>如果有大量的协程，何时让出控制权，何时恢复执行？忽然明白了抢占式调度的优势了，在抢占式调度中都是由系统内核来完成的。
我们需要一个&quot;用户态协程调度器&quot;. Golang Goroutine是如何解决的呢？</p>
<p>Golang GPM模型使用一种M:N的调度器来调度任意数量的协程运行于任意数量的系统线程中，
从而保证了上下文切换的速度并且利用多核，但是增加了调度器的复杂度。</p>
<p>引用网络上的一张图

  <img src="/img/posts/2020-08-09/golang_gpm.png" alt="">

</p>
<p>GPM调度过程简述：</p>
<blockquote>
<p>新创建的Goroutine会先存放在Global全局队列中，等待Go调度器进行调度，
随后Goroutine被分配给其中的一个逻辑处理器P，并放到这个逻辑处理器对应的Local本地运行队列中，
最终等待被逻辑处理器P执行即可。
在M与P绑定后，M会不断从P的Local队列中无锁地取出G，并切换到G的堆栈执行，
当P的Local队列中没有G时，再从Global队列中获取一个G，当Global队列中也没有待运行的G时，
则尝试从其它的P窃取部分G来执行相当于P之间的负载均衡。</p>
</blockquote>
<h3 id="读写锁-vs-互斥锁-vs-死锁">读写锁 vs 互斥锁 vs 死锁</h3>
<h4 id="死锁">死锁</h4>
<blockquote>
<p>两个或两个以上进程竞争资源造成的一种阻塞现象</p>
</blockquote>
<p>golang 中的 sync 包实现了两种锁：</p>
<ul>
<li>Mutex：互斥锁</li>
<li>RWMutex：读写锁，RWMutex 基于 Mutex 实现</li>
</ul>
<h4 id="mutex互斥锁">Mutex(互斥锁)</h4>
<blockquote>
</blockquote>
<ul>
<li>Mutex 为互斥锁，Lock() 加锁，Unlock() 解锁</li>
<li>在一个 goroutine 获得 Mutex 后，其他 goroutine 只能等到这个 goroutine 释放该 Mutex</li>
<li>使用 Lock() 加锁后，不能再继续对其加锁，直到利用 Unlock() 解锁后才能再加锁</li>
<li>在 Lock() 之前使用 Unlock() 会导致 panic 异常</li>
<li>已经锁定的 Mutex 并不与特定的 goroutine 相关联，这样可以利用一个 goroutine 对其加锁，再利用其他 goroutine 对其解锁</li>
<li>在同一个 goroutine 中的 Mutex 解锁之前再次进行加锁，会导致死锁</li>
<li>适用于读写不确定，并且只有一个读或者写的场景</li>
</ul>
<h4 id="rwmutex读写锁">RWMutex(读写锁)</h4>
<blockquote>
</blockquote>
<ul>
<li>RWMutex 是单写多读锁，该锁可以加多个读锁或者一个写锁</li>
<li>读锁占用的情况下会阻止写，不会阻止读，多个 goroutine 可以同时获取读锁</li>
<li>写锁会阻止其他 goroutine（无论读和写）进来，整个锁由该 goroutine 独占</li>
<li>适用于读多写少的场景</li>
<li>Lock() 加写锁，Unlock() 解写锁</li>
<li>如果在加写锁之前已经有其他的读锁和写锁，则 Lock() 会阻塞直到该锁可用，为确保该锁可用，已经阻塞的 Lock() 调用会从获得的锁中排除新的读取器，即写锁权限高于读锁，有写锁时优先进行写锁定</li>
<li>在 Lock() 之前使用 Unlock() 会导致 panic 异常</li>
<li>RLock() 加读锁，RUnlock() 解读锁</li>
<li>RLock() 加读锁时，如果存在写锁，则无法加读锁；当只有读锁或者没有锁时，可以加读锁，读锁可以加载多个</li>
<li>RUnlock() 解读锁，RUnlock() 撤销单词 RLock() 调用，对于其他同时存在的读锁则没有效果</li>
<li>在没有读锁的情况下调用 RUnlock() 会导致 panic 错误</li>
<li>RUnlock() 的个数不得多余 RLock()，否则会导致 panic 错误</li>
</ul>
<h3 id="slice扩容机制">slice扩容机制</h3>
<h4 id="slice扩容范例">slice扩容范例</h4>
<p>例子1</p>
<pre tabindex="0"><code>func main() {
    a := make([]int, 2, 2)
    fmt.Printf(&quot;原始容量：%d\n&quot;, cap(a))

    a = append(a, 1,2,3)
    fmt.Printf(&quot;扩容后的容量：%d\n&quot;, cap(a))
}
</code></pre><p>例子2</p>
<pre tabindex="0"><code>func main() {
    a := make([]int, 4, 4)
    fmt.Printf(&quot;原始容量：%d\n&quot;, cap(a))

    a = append(a, 1,2,3)
    fmt.Printf(&quot;扩容后的容量：%d\n&quot;, cap(a))
}
</code></pre><h4 id="预估扩容容量">预估扩容容量</h4>
<p>slice预估扩容容量的源码实现<code>go1.16.5/src/runtime/slice.go</code></p>
<pre tabindex="0"><code>// growslice handles slice growth during append.
// It is passed the slice element type, the old slice, and the desired new minimum capacity,
// and it returns a new slice with at least that capacity, with the old data
// copied into it.
// The new slice's length is set to the old slice's length,
// NOT to the new requested capacity.
// This is for codegen convenience. The old slice's length is used immediately
// to calculate where to write new values during an append.
// TODO: When the old backend is gone, reconsider this decision.
// The SSA backend might prefer the new length or to return only ptr/cap and save stack space.
func growslice(et *_type, old slice, cap int) slice {
    ......

    newcap := old.cap
    doublecap := newcap + newcap
    if cap &gt; doublecap {
        newcap = cap
    } else {
        if old.cap &lt; 1024 {
            newcap = doublecap
        } else {
            // Check 0 &lt; newcap to detect overflow
            // and prevent an infinite loop.
            for 0 &lt; newcap &amp;&amp; newcap &lt; cap {
                newcap += newcap / 4
            }
            // Set newcap to the requested cap when
            // the newcap calculation overflowed.
            if newcap &lt;= 0 {
                newcap = cap
            }
        }
    }
    ......
</code></pre><p>根据源码总结出来的预估扩容容量的原理是：</p>
<ol>
<li>如果需要的总容量 &gt; 原始容量 * 2，新扩容后的容量 = 需要的总容量</li>
<li>需要的总容量 &lt;= 原始容量 * 2，且原始容量小于1024，新扩容后的容量 = 原始容量 * 2</li>
<li>需要的总容量 &lt;= 原始容量 * 2，且原始容量大于等于1024，新扩容后的容量 = 原始容量 * 1.25^n，直到新扩容后的容量&gt;=需要的总容量</li>
</ol>
<p>例子1实际运行结果：</p>
<pre tabindex="0"><code>原始容量：2
扩容后的容量：6
</code></pre><p>为什么扩容后的容量不是5，而是6？</p>
<p>例子2实际运行结果：</p>
<pre tabindex="0"><code>原始容量：4
扩容后的容量：8
</code></pre><p>预估扩容容量的原理跟实际运行结果不相匹配，问题出在哪里？最终是分配一段内存大小空间出来，这个内存空间不是随意分配的，而是由golang内存管理模块决定的，
内存块大小都是固定的。</p>
<h4 id="所需内存大小">所需内存大小</h4>
<p>golang内存管理模块，划分的内存块大小：<code>go1.16.5/src/runtime/sizeclasses.go</code></p>
<pre tabindex="0"><code>// class  bytes/obj  bytes/span  objects  tail waste  max waste
//     1          8        8192     1024           0     87.50%
//     2         16        8192      512           0     43.75%
//     3         24        8192      341           8     29.24%
//     4         32        8192      256           0     21.88%
//     5         48        8192      170          32     31.52%
//     6         64        8192      128           0     23.44%
//     7         80        8192      102          32     19.07%
//     8         96        8192       85          32     15.95%
//     9        112        8192       73          16     13.56%
//    10        128        8192       64           0     11.72%
//    11        144        8192       56         128     11.82%
//    12        160        8192       51          32      9.73%
//    13        176        8192       46          96      9.59%
//    14        192        8192       42         128      9.25%
//    15        208        8192       39          80      8.12%
//    16        224        8192       36         128      8.15%
//    17        240        8192       34          32      6.62%
//    18        256        8192       32           0      5.86%
//    19        288        8192       28         128     12.16%
//    20        320        8192       25         192     11.80%
//    21        352        8192       23          96      9.88%
//    22        384        8192       21         128      9.51%
//    23        416        8192       19         288     10.71%
//    24        448        8192       18         128      8.37%
//    25        480        8192       17          32      6.82%
//    26        512        8192       16           0      6.05%
//    27        576        8192       14         128     12.33%
//    28        640        8192       12         512     15.48%
//    29        704        8192       11         448     13.93%
//    30        768        8192       10         512     13.94%
//    31        896        8192        9         128     15.52%
//    32       1024        8192        8           0     12.40%
//    33       1152        8192        7         128     12.41%
//    34       1280        8192        6         512     15.55%
//    35       1408       16384       11         896     14.00%
//    36       1536        8192        5         512     14.00%
//    37       1792       16384        9         256     15.57%
//    38       2048        8192        4           0     12.45%
//    39       2304       16384        7         256     12.46%
//    40       2688        8192        3         128     15.59%
//    41       3072       24576        8           0     12.47%
//    42       3200       16384        5         384      6.22%
//    43       3456       24576        7         384      8.83%
//    44       4096        8192        2           0     15.60%
//    45       4864       24576        5         256     16.65%
//    46       5376       16384        3         256     10.92%
//    47       6144       24576        4           0     12.48%
//    48       6528       32768        5         128      6.23%
//    49       6784       40960        6         256      4.36%
//    50       6912       49152        7         768      3.37%
//    51       8192        8192        1           0     15.61%
//    52       9472       57344        6         512     14.28%
//    53       9728       49152        5         512      3.64%
//    54      10240       40960        4           0      4.99%
//    55      10880       32768        3         128      6.24%
//    56      12288       24576        2           0     11.45%
//    57      13568       40960        3         256      9.99%
//    58      14336       57344        4           0      5.35%
//    59      16384       16384        1           0     12.49%
//    60      18432       73728        4           0     11.11%
//    61      19072       57344        3         128      3.57%
//    62      20480       40960        2           0      6.87%
//    63      21760       65536        3         256      6.25%
//    64      24576       24576        1           0     11.45%
//    65      27264       81920        3         128     10.00%
//    66      28672       57344        2           0      4.91%
//    67      32768       32768        1           0     12.50%
</code></pre><p>从上图看出，内存块增长并不是规律的</p>
<h4 id="匹配最合适的内存大小">匹配最合适的内存大小</h4>
<p><code>所需内存大小 = 预估容量 * 元素类型大小</code>，套用上述例子1，所需内存大小 = 5 * 8字节(一个int在64位操作系统里是64位，也就是8字节) = 40字节，
查看上图最匹配的内存空间大小是48字节，48/8=6个int的容量</p>
<h3 id="goroutine-id">Goroutine id</h3>
<p>利用runtime.Stack可以获取全部Goroutine的栈信息，官方net/http2库中curGoroutineID函数也采用这种方式获取Goroutine id，
<a href="https://github.com/golang/net/blob/master/http2/gotrack.go#L51">net/http2获取Goroutine id</a></p>
<p>获取到Goroutine id，可以方便debug，这个id可以作为唯一标识，将Goroutine中调用的函数层级串联起来；
比较典型的例子：在web框架中，在日志中打印这个id，可以很方便对整个请求过程进行跟踪和分析。</p>
<pre tabindex="0"><code>package main

import (
    &quot;bytes&quot;
    &quot;fmt&quot;
    &quot;runtime&quot;
    &quot;strconv&quot;
    &quot;sync&quot;
)

func GetGoid() uint64 {
    b := make([]byte, 64)
    b = b[:runtime.Stack(b, false)]
    b = bytes.TrimPrefix(b, []byte(&quot;goroutine &quot;))
    b = b[:bytes.IndexByte(b, ' ')]
    n, _ := strconv.ParseUint(string(b), 10, 64)
    return n
}

func main() {
    fmt.Println(&quot;main&quot;, GetGoid())
    var wg sync.WaitGroup
    for i := 0; i &lt; 20; i++ {
        i := i
        wg.Add(1)
        go func() {
            defer wg.Done()
            fmt.Println(i, GetGoid())
        }()
    }
    wg.Wait()
}
</code></pre><h3 id="rpc">RPC</h3>
<h4 id="grpc">grpc</h4>
<h4 id="grpc入门">grpc入门</h4>
<pre tabindex="0"><code>入门/
├── main.go
├── protobuf
│├── hello.pb.go
│└── hello.proto
└── server
    └── server.go
2 directories, 4 files
</code></pre><p><code>protobuf/hello.proto</code></p>
<pre tabindex="0"><code>syntax = &quot;proto3&quot;;

package protobuf;

// message关键字定义一个叫String的类型
message String {
    string value = 1;
}

// 定义rpc方法
service HelloService {
    rpc Hello (String) returns (String);
</code></pre><p>通过<code>protoc -I protobuf protobuf/*.proto --go_out=plugins=grpc:protobuf</code>生成hello.pb.go</p>
<p><code>main.go</code></p>
<pre tabindex="0"><code>package main

import (
    &quot;context&quot;
    &quot;fmt&quot;
    &quot;google.golang.org/grpc&quot;
    &quot;log&quot;
    . &quot;test/protobuf&quot;
)

func main() {
    conn, err := grpc.Dial(&quot;localhost:1234&quot;, grpc.WithInsecure())
    if err != nil {
        log.Fatal(err)
    }
    defer conn.Close()

    // protobuf生成Client
    client := NewHelloServiceClient(conn)
    reply, err := client.Hello(context.Background(), &amp;String{Value: &quot;hello&quot;})
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(reply.GetValue())
</code></pre><p><code>server/server.go</code></p>
<pre tabindex="0"><code>package main

import (
    &quot;context&quot;
    &quot;google.golang.org/grpc&quot;
    &quot;log&quot;
    &quot;net&quot;
    . &quot;test/protobuf&quot;
)

type HelloServiceImpl struct{}

func (p *HelloServiceImpl) Hello(ctx context.Context, args *String) (*String, error) {
    reply := &amp;String{Value: &quot;hello:&quot; + args.GetValue()}
    return reply, nil
}

func main() {
    grpcServer := grpc.NewServer()
    // protobuf生成注册函数
    RegisterHelloServiceServer(grpcServer, new(HelloServiceImpl))

    lis, err := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if err != nil {
        log.Fatal(err)
    }
    grpcServer.Serve(lis)
</code></pre><h4 id="grpc-stream">grpc stream</h4>
<p>传统rpc不适合上传/下载数据量大的场景，grpc提供了stream特性</p>
<pre tabindex="0"><code>stream/
├── main.go
├── protobuf
│ ├── hello.pb.go
│ └── hello.proto
└── server
    └── server.go

2 directories, 4 files
</code></pre><p><code>protobuf/hello.proto</code></p>
<pre tabindex="0"><code>syntax = &quot;proto3&quot;;

package protobuf;

message String {
    string value = 1;
}

service HelloService {
    rpc Hello (String) returns (String);
    // 关键字stream启用流特性, 添加一个双向流的方法
    rpc Channel (stream String) returns (stream String);
</code></pre><p><code>main.go</code></p>
<pre tabindex="0"><code>package main

import (
    &quot;context&quot;
    &quot;fmt&quot;
    &quot;google.golang.org/grpc&quot;
    &quot;io&quot;
    &quot;log&quot;
    . &quot;test/protobuf&quot;
    &quot;time&quot;
)

func main() {
    conn, err := grpc.Dial(&quot;localhost:1234&quot;, grpc.WithInsecure())
    if err != nil {
        log.Fatal(err)
    }
    defer conn.Close()

    client := NewHelloServiceClient(conn)

    // 先获取stream对象
    stream, err := client.Channel(context.Background())
    if err != nil {
        log.Fatal(err)
    }

    // 模拟客户端发送数据
    go func() {
        for {
            if err := stream.Send(&amp;String{Value: &quot;hi&quot;}); err != nil {
                log.Fatal(err)
            }
            time.Sleep(time.Second)
        }
    }()

    // 循环接收数据
    for {
        reply, err := stream.Recv()
        if err != nil {
            if err == io.EOF {
                break
            }
            log.Fatal(err)
        }
        fmt.Println(reply.GetValue())
    }
}
</code></pre><p><code>server/server.go</code></p>
<pre tabindex="0"><code>package main

import (
    &quot;context&quot;
    &quot;google.golang.org/grpc&quot;
    &quot;io&quot;
    &quot;log&quot;
    &quot;net&quot;
    . &quot;test/protobuf&quot;
)

type HelloServiceImpl struct{}

func (p *HelloServiceImpl) Hello(ctx context.Context, args *String) (*String, error) {
    reply := &amp;String{Value: &quot;hello:&quot; + args.GetValue()}
    return reply, nil
}

// 循环接收客户端的数据，数据重新组装后，通过stream又发给客户端；双向流数据的发送和接收是独立的
func (p *HelloServiceImpl) Channel(stream HelloService_ChannelServer) error {
    for {
        args, err := stream.Recv()
        if err != nil {
            if err == io.EOF {
                return nil
            }
            return err
        }

        reply := &amp;String{Value: &quot;hello:&quot; + args.GetValue()}

        err = stream.Send(reply)
        if err != nil {
            return err
        }
    }
}

func main() {
    grpcServer := grpc.NewServer()
    RegisterHelloServiceServer(grpcServer, new(HelloServiceImpl))

    lis, err := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if err != nil {
        log.Fatal(err)
    }
    grpcServer.Serve(lis)
}
</code></pre><h4 id="http-rpc">http-rpc</h4>
<p>在http协议上提供jsonrpc服务</p>
<p><code>http-rpc/server.go</code></p>
<pre tabindex="0"><code>package main

import (
    &quot;io&quot;
    &quot;net/http&quot;
    &quot;net/rpc&quot;
    &quot;net/rpc/jsonrpc&quot;
)

type HelloService struct {}

func (p *HelloService) Hello(request string, reply *string) error {
    *reply = &quot;hello:&quot; + request
    return nil
}

func main() {
    rpc.RegisterName(&quot;HelloService&quot;, new(HelloService))

    // 在处理函数中基于http.ResponseWriter和http.Request类型的参数
    // 构造一个io.ReadWriteCloser类型的conn通道
    http.HandleFunc(&quot;/hello&quot;, func(w http.ResponseWriter, r *http.Request) {
        var conn io.ReadWriteCloser = struct {
            io.Writer
            io.ReadCloser
        }{
            ReadCloser: r.Body,
            Writer:     w,
        }

        rpc.ServeRequest(jsonrpc.NewServerCodec(conn))
    })

    http.ListenAndServe(&quot;:1234&quot;, nil)
}
</code></pre><p>使用curl调用</p>
<pre tabindex="0"><code>curl localhost:1234/hello -X POST \
    --data '{&quot;method&quot;:&quot;HelloService.Hello&quot;,&quot;params&quot;:[&quot;hello&quot;],&quot;id&quot;:0}'
</code></pre><h4 id="json-rpc">json-rpc</h4>
<p>采用官方net/rpc/jsonrpc扩展，只要是同样的json结构，就可以进行跨语言rpc</p>
<pre tabindex="0"><code>json-rpc/
├── client
│ └── test.go
├── main.go
└── server
    └── server.go

2 directories, 3 files
</code></pre><p><code>main.go</code></p>
<pre tabindex="0"><code>package main

import (
    . &quot;./server&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;net/rpc/jsonrpc&quot;
)

func main() {
    RegisterHelloService(new(HelloService))

    listener, err := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if err != nil {
        log.Fatal(&quot;ListenTCP error:&quot;, err)
    }

    for {
        conn, err := listener.Accept()
        if err != nil {
            log.Fatal(&quot;Accept error:&quot;, err)
        }

        // json编解码器包装
        go rpc.ServeCodec(jsonrpc.NewServerCodec(conn))
    }
}
</code></pre><p><code>server/server.go</code></p>
<pre tabindex="0"><code>package server

import (
    &quot;net/rpc&quot;
)

const HelloServiceName = &quot;path/to/pkg.HelloService&quot;

type HelloServiceInterface interface {
    Hello(request string, reply *string) error
}

func RegisterHelloService(svc HelloServiceInterface) error {
    return rpc.RegisterName(HelloServiceName, svc)
}

type HelloService struct {}

func (p *HelloService) Hello(request string, reply *string) error {
    *reply = &quot;hello:&quot; + request
    return nil
}
</code></pre><p><code>client/test.go</code></p>
<pre tabindex="0"><code>package main

import (
    . &quot;../server&quot;
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
    &quot;net/rpc/jsonrpc&quot;
)

type HelloServiceClient struct {
    *rpc.Client
}

//var _ HelloServiceInterface = (*HelloServiceClient)(nil)

func DialHelloService(network, address string) (*HelloServiceClient, error) {
    // rpc连接建立在io.ReadWriteCloser接口之上
    conn, err := net.Dial(network, address)
    if err != nil {
        return nil, err
    }
    // json编解码器包装
    client := rpc.NewClientWithCodec(jsonrpc.NewClientCodec(conn))

    return &amp;HelloServiceClient{Client: client}, nil
}

func (p *HelloServiceClient) Hello(request string, reply *string) error {
    return p.Client.Call(HelloServiceName+&quot;.Hello&quot;, request, reply)
}

func main() {
    client, err := DialHelloService(&quot;tcp&quot;, &quot;localhost:1234&quot;)
    if err != nil {
        log.Fatal(&quot;dialing:&quot;, err)
    }

    var reply string
    err = client.Hello(&quot;world&quot;, &amp;reply)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(reply)
}
</code></pre><h4 id="golang官方rpc">Golang官方rpc</h4>
<p>Go官方rpc包是net/rpc, rpc方法必须满足Go rpc规则:
1.公开方法
2.只有两个序列化参数，第二个参数是指针类型
3.返回值是error类型</p>
<pre tabindex="0"><code>Golang官方rpc/
├── client
│└── test.go
├── main.go
└── server
    └── server.go

2 directories, 3 files
</code></pre><p><code>main.go</code></p>
<pre tabindex="0"><code>package main

import (
    . &quot;./server&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/rpc&quot;
)

func main() {
    RegisterHelloService(new(HelloService))

    listener, err := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if err != nil {
        log.Fatal(&quot;ListenTCP error:&quot;, err)
    }

    for {
        conn, err := listener.Accept()
        if err != nil {
            log.Fatal(&quot;Accept error:&quot;, err)
        }

        go rpc.ServeConn(conn)
    }
}
</code></pre><p><code>client/test.go</code></p>
<pre tabindex="0"><code>package main

import (
    . &quot;../server&quot;
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net/rpc&quot;
)

type HelloServiceClient struct {
    *rpc.Client
}

var _ HelloServiceInterface = (*HelloServiceClient)(nil)

func DialHelloService(network, address string) (*HelloServiceClient, error) {
    // 与rpc server建立rpc连接
    c, err := rpc.Dial(network, address)
    if err != nil {
        return nil, err
    }
    return &amp;HelloServiceClient{Client: c}, nil
}

func (p *HelloServiceClient) Hello(request string, reply *string) error {
    // 调用rpc方法
    return p.Client.Call(HelloServiceName+&quot;.Hello&quot;, request, reply)
}

func main() {
    client, err := DialHelloService(&quot;tcp&quot;, &quot;localhost:1234&quot;)
    if err != nil {
        log.Fatal(&quot;dialing:&quot;, err)
    }

    var reply string
    err = client.Hello(&quot;world&quot;, &amp;reply)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(reply)
}
</code></pre><p><code>server/server.go</code></p>
<pre tabindex="0"><code>package server

import (
    &quot;net/rpc&quot;
)

const HelloServiceName = &quot;path/to/pkg.HelloService&quot;

type HelloServiceInterface interface {
    Hello(request string, reply *string) error
}

// rpc.Register将对象类型下所有符合Go rpc规则的方法都注册为rpc方法，
// rpc方法托管在HelloServiceName命名空间下
func RegisterHelloService(svc HelloServiceInterface) error {
    return rpc.RegisterName(HelloServiceName, svc)
}

type HelloService struct {}

func (p *HelloService) Hello(request string, reply *string) error {
    *reply = &quot;hello:&quot; + request
    return nil
}
</code></pre><h3 id="set集合">Set集合</h3>
<p>引用来自：k8s.io/apimachinery/pkg/util/sets</p>
<pre tabindex="0"><code>package sets

import (
    &quot;reflect&quot;
    &quot;sort&quot;
)

// Empty is public since it is used by some pkg API objects for conversions between external
// string arrays and pkg sets, and conversion logic requires public types today.
type Empty struct{}

// sets.String is a set of strings, implemented via map[string]struct{} for minimal memory consumption.
type String map[string]Empty

// NewString creates a String from a list of values.
func NewString(items ...string) String {
    ss := String{}
    ss.Insert(items...)
    return ss
}

// StringKeySet creates a String from a keys of a map[string](? extends interface{}).
// If the value passed in is not actually a map, this will panic.
func StringKeySet(theMap interface{}) String {
    v := reflect.ValueOf(theMap)
    ret := String{}

    for _, keyValue := range v.MapKeys() {
        ret.Insert(keyValue.Interface().(string))
    }
    return ret
}

// Insert adds items to the set.
func (s String) Insert(items ...string) {
    for _, item := range items {
        s[item] = Empty{}
    }
}

// Delete removes all items from the set.
func (s String) Delete(items ...string) {
    for _, item := range items {
        delete(s, item)
    }
}

// Has returns true if and only if item is contained in the set.
func (s String) Has(item string) bool {
    _, contained := s[item]
    return contained
}

// HasAll returns true if and only if all items are contained in the set.
func (s String) HasAll(items ...string) bool {
    for _, item := range items {
        if !s.Has(item) {
            return false
        }
    }
    return true
}

// HasAny returns true if any items are contained in the set.
func (s String) HasAny(items ...string) bool {
    for _, item := range items {
        if s.Has(item) {
            return true
        }
    }
    return false
}

// Difference returns a set of objects that are not in s2
// For example:
// s1 = {a1, a2, a3}
// s2 = {a1, a2, a4, a5}
// s1.Difference(s2) = {a3}
// s2.Difference(s1) = {a4, a5}
func (s String) Difference(s2 String) String {
    result := NewString()
    for key := range s {
        if !s2.Has(key) {
            result.Insert(key)
        }
    }
    return result
}

// Union returns a new set which includes items in either s1 or s2.
// For example:
// s1 = {a1, a2}
// s2 = {a3, a4}
// s1.Union(s2) = {a1, a2, a3, a4}
// s2.Union(s1) = {a1, a2, a3, a4}
func (s1 String) Union(s2 String) String {
    result := NewString()
    for key := range s1 {
        result.Insert(key)
    }
    for key := range s2 {
        result.Insert(key)
    }
    return result
}

// Intersection returns a new set which includes the item in BOTH s1 and s2
// For example:
// s1 = {a1, a2}
// s2 = {a2, a3}
// s1.Intersection(s2) = {a2}
func (s1 String) Intersection(s2 String) String {
    var walk, other String
    result := NewString()
    if s1.Len() &lt; s2.Len() {
        walk = s1
        other = s2
    } else {
        walk = s2
        other = s1
    }
    for key := range walk {
        if other.Has(key) {
            result.Insert(key)
        }
    }
    return result
}

// IsSuperset returns true if and only if s1 is a superset of s2.
func (s1 String) IsSuperset(s2 String) bool {
    for item := range s2 {
        if !s1.Has(item) {
            return false
        }
    }
    return true
}

// Equal returns true if and only if s1 is equal (as a set) to s2.
// Two sets are equal if their membership is identical.
// (In practice, this means same elements, order doesn't matter)
func (s1 String) Equal(s2 String) bool {
    return len(s1) == len(s2) &amp;&amp; s1.IsSuperset(s2)
}

type sortableSliceOfString []string

func (s sortableSliceOfString) Len() int           { return len(s) }
func (s sortableSliceOfString) Less(i, j int) bool { return lessString(s[i], s[j]) }
func (s sortableSliceOfString) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }

// List returns the contents as a sorted string slice.
func (s String) List() []string {
    res := make(sortableSliceOfString, 0, len(s))
    for key := range s {
        res = append(res, key)
    }
    sort.Sort(res)
    return []string(res)
}

// UnsortedList returns the slice with contents in random order.
func (s String) UnsortedList() []string {
    res := make([]string, 0, len(s))
    for key := range s {
        res = append(res, key)
    }
    return res
}

// Returns a single element from the set.
func (s String) PopAny() (string, bool) {
    for key := range s {
        s.Delete(key)
        return key, true
    }
    var zeroValue string
    return zeroValue, false
}

// Len returns the size of the set.
func (s String) Len() int {
    return len(s)
}

func lessString(lhs, rhs string) bool {
    return lhs &lt; rhs
}
</code></pre><h3 id="网络开发">网络开发</h3>
<h4 id="netlink库操作">netlink库操作</h4>
<p>引用来自：github.com/coreos/flannel/pkg/ip/iface.go</p>
<pre tabindex="0"><code>package ip

import (
    &quot;errors&quot;
    &quot;fmt&quot;
    &quot;net&quot;
    &quot;syscall&quot;

    &quot;github.com/vishvananda/netlink&quot;
)

func getIfaceAddrs(iface *net.Interface) ([]netlink.Addr, error) {
    link := &amp;netlink.Device{
        netlink.LinkAttrs{
            Index: iface.Index,
        },
    }

    return netlink.AddrList(link, syscall.AF_INET)
}

func GetIfaceIP4Addr(iface *net.Interface) (net.IP, error) {
    addrs, err := getIfaceAddrs(iface)
    if err != nil {
        return nil, err
    }

    // prefer non link-local addr
    var ll net.IP

    for _, addr := range addrs {
        if addr.IP.To4() == nil {
            continue
        }

        if addr.IP.IsGlobalUnicast() {
            return addr.IP, nil
        }

        if addr.IP.IsLinkLocalUnicast() {
            ll = addr.IP
        }
    }

    if ll != nil {
        // didn't find global but found link-local. it'll do.
        return ll, nil
    }

    return nil, errors.New(&quot;No IPv4 address found for given interface&quot;)
}

func GetIfaceIP4AddrMatch(iface *net.Interface, matchAddr net.IP) error {
    addrs, err := getIfaceAddrs(iface)
    if err != nil {
        return err
    }

    for _, addr := range addrs {
        // Attempt to parse the address in CIDR notation
        // and assert it is IPv4
        if addr.IP.To4() != nil {
            if addr.IP.To4().Equal(matchAddr) {
                return nil
            }
        }
    }

    return errors.New(&quot;No IPv4 address found for given interface&quot;)
}

func GetDefaultGatewayIface() (*net.Interface, error) {
    routes, err := netlink.RouteList(nil, syscall.AF_INET)
    if err != nil {
        return nil, err
    }

    for _, route := range routes {
        if route.Dst == nil || route.Dst.String() == &quot;0.0.0.0/0&quot; {
            if route.LinkIndex &lt;= 0 {
                return nil, errors.New(&quot;Found default route but could not determine interface&quot;)
            }
            return net.InterfaceByIndex(route.LinkIndex)
        }
    }

    return nil, errors.New(&quot;Unable to find default route&quot;)
}

func GetInterfaceByIP(ip net.IP) (*net.Interface, error) {
    ifaces, err := net.Interfaces()
    if err != nil {
        return nil, err
    }

    for _, iface := range ifaces {
        err := GetIfaceIP4AddrMatch(&amp;iface, ip)
        if err == nil {
            return &amp;iface, nil
        }
    }

    return nil, errors.New(&quot;No interface with given IP found&quot;)
}

func DirectRouting(ip net.IP) (bool, error) {
    routes, err := netlink.RouteGet(ip)
    if err != nil {
        return false, fmt.Errorf(&quot;couldn't lookup route to %v: %v&quot;, ip, err)
    }
    if len(routes) == 1 &amp;&amp; routes[0].Gw == nil {
        // There is only a single route and there's no gateway (i.e. it's directly connected)
        return true, nil
    }
    return false, nil
}

// EnsureV4AddressOnLink ensures that there is only one v4 Addr on `link` and it equals `ipn`.
// If there exist multiple addresses on link, it returns an error message to tell callers to remove additional address.
func EnsureV4AddressOnLink(ipn IP4Net, link netlink.Link) error {
    addr := netlink.Addr{IPNet: ipn.ToIPNet()}
    existingAddrs, err := netlink.AddrList(link, netlink.FAMILY_V4)
    if err != nil {
        return err
    }

    // flannel will never make this happen. This situation can only be caused by a user, so get them to sort it out.
    if len(existingAddrs) &gt; 1 {
        return fmt.Errorf(&quot;link has incompatible addresses. Remove additional addresses and try again. %#v&quot;, link)
    }

    // If the device has an incompatible address then delete it. This can happen if the lease changes for example.
    if len(existingAddrs) == 1 &amp;&amp; !existingAddrs[0].Equal(addr) {
        if err := netlink.AddrDel(link, &amp;existingAddrs[0]); err != nil {
            return fmt.Errorf(&quot;failed to remove IP address %s from %s: %s&quot;, ipn.String(), link.Attrs().Name, err)
        }
        existingAddrs = []netlink.Addr{}
    }

    // Actually add the desired address to the interface if needed.
    if len(existingAddrs) == 0 {
        if err := netlink.AddrAdd(link, &amp;addr); err != nil {
            return fmt.Errorf(&quot;failed to add IP address %s to %s: %s&quot;, ipn.String(), link.Attrs().Name, err)
        }
    }

    return nil
}
</code></pre><h3 id="三元表达式">三元表达式</h3>
<pre tabindex="0"><code>package main

func If(condition bool, trueVal, falseVal interface{}) interface{} {
    if condition {
        return trueVal
    }
    return falseVal
}

func main() {
    a, b := 2, 3
    max := If(a &gt; b, a, b).(int)
    println(max)
}
</code></pre><h3 id="结构体优雅赋值">结构体优雅赋值</h3>
<pre tabindex="0"><code>package main

//参数定义在结构体内部
type Op struct {
    userInfo *models.UserInfo
    pagination *models.Pagination
    state string
}

type OpOption func(*Op)

//变量赋值給实例
func (op *Op) applyOpts(opts []OpOption) {
    for _, opt := range opts {
        opt(op)
    }
}

func WithUserInfo(userInfo *models.UserInfo) OpOption {
    return func(op *Op) { op.userInfo = userInfo }
}

func WithPagination(pagination *models.Pagination) OpOption {
    return func(op *Op) { op.pagination = pagination }
}

func WithState(state string) OpOption {
    return func(op *Op) { op.state = state }
}

func OpGet(opts ...OpOption) Op {
    ret := Op{}
    ret.applyOpts(opts)
    return ret
}
</code></pre><h3 id="函数">函数</h3>
<h4 id="回调函数">回调函数</h4>
<p>回调函数：本质是通过函数指针调用的函数，如函数1作为参数传递给函数2，函数1叫做回调函数，函数2叫做中间函数，调用2的函数叫做起始函数.</p>
<p>回调示例（来自知乎）：</p>
<blockquote>
<p>有一家旅馆提供叫醒服务，但是要求旅客自己决定叫醒的方法。可以是打客房电话，也可以是派服务员去敲门，睡得死怕耽误事的，还可以要求往自己头上浇盆水。
这里，“叫醒”这个行为是旅馆提供的，相当于中间函数，但是叫醒的方式是由旅客决定并告诉旅馆的，也就是回调函数。而旅客告诉旅馆怎么叫醒自己的动作，
也就是把回调函数传入中间函数的动作，称为登记回调函数（to register a callback function）</p>
</blockquote>
<blockquote>
<p>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。
在这个例子里， 你的电话号码就叫回调函数 ，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件 ，店员给你打电话叫做调用回调函数 ，
你到店里去取货叫做响应回调事件 。</p>
</blockquote>
<p>回调函数类型：</p>
<ol>
<li>阻塞式回调（同步回调）(下面这个例子就是阻塞式回调)</li>
<li>延迟式回调（异步回调）</li>
</ol>
<p>知乎上关于回调的理解不错的帖子: <a href="https://www.zhihu.com/question/19801131">https://www.zhihu.com/question/19801131</a></p>
<pre tabindex="0"><code>package main

import &quot;fmt&quot;

//回调函数
func XX(x int) int {
    return x * x
}

//中间函数
//接受一个生成平方数的函数作为参数
func returnXXNumber(x int, getXXNumber func(int) int) int {
    return getXXNumber(x)
}

//起始函数
func main() {
    x := 2
    fmt.Println(returnXXNumber(x, XX))
}
</code></pre><h4 id="闭包函数">闭包函数</h4>
<p>闭包：官方解释（译文）Go函数可以是一个闭包。闭包是一个函数值，它引用了函数体之外的变量。
这个函数可以对这个引用的变量进行访问和赋值；换句话说这个函数被&quot;绑定&quot;在这个变量上。</p>
<p>作用：是缩小变量作用域，降低对全局变量污染的概率</p>
<pre tabindex="0"><code>package main

import &quot;fmt&quot;

func add() func(int) int {
    sum := 0
    return func(x int) int {
        sum += x
        return sum
    }
}

func main() {
    //add()就是一个闭包，并赋值给pos和neg，pos的闭包函数和neg的闭包函数被绑定在各自的sum变量上；
    //两个闭包函数的sum变量之间没有任何关系
    pos, neg := add(), add()
    for i := 0; i &lt; 5; i++ {
        fmt.Println(
            pos(i),
            neg(-i),
        )
    }
}
</code></pre><p>闭包实现的斐波那契数列</p>
<pre tabindex="0"><code>package main

//fibonacci函数完成核心算法、核心数据存储, 不负责for循环
func fibonacci() func() int {
    b1 := 1
    b2 := 0
    bc := 0
    return func() int {
        bc = b1 + b2
        b1 = b2
        b2 = bc
        return bc
    }
}

func main() {
    f := fibonacci()
    for i := 0; i &lt; 10; i++ {
        fmt.Println(f())
    }
}
</code></pre><h3 id="分布式锁">分布式锁</h3>
<h4 id="etcd分布式锁">etcd分布式锁</h4>
<p>etcd client v3版本中的concurrency包实现了分布式锁，
大致思路是：</p>
<ol>
<li>createReVision最小的客户端获得锁</li>
<li>createReVision越小越早获得锁，部分关键代码如下</li>
</ol>
<p>等待比当前客户端创建的key的revision小的key的客户端释放锁
// wait for deletion revisions prior to myKey
hdr, werr := waitDeletes(ctx, client, m.pfx, m.myRev-1)</p>
<p>引用来自: <a href="https://github.com/etcd-io/etcd/blob/master/clientv3/example_kv_test.go">https://github.com/etcd-io/etcd/blob/master/clientv3/example_kv_test.go</a></p>
<pre tabindex="0"><code>package main

import (
    &quot;context&quot;
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;strings&quot;
    &quot;time&quot;

    &quot;github.com/coreos/etcd/clientv3&quot;
    &quot;github.com/coreos/etcd/clientv3/concurrency&quot;
)

var (
    endpoints = &quot;http://10.10.10.10:52379&quot;
)

func main() {
    cli, err := clientv3.New(clientv3.Config{
        Endpoints:   strings.Split(endpoints, &quot;,&quot;),
        DialTimeout: 3 * time.Second,
    })
    if err != nil {
        panic(err)
    }
    defer cli.Close()

    // create two separate sessions for lock competition
    s1, err := concurrency.NewSession(cli)
    if err != nil {
        log.Fatal(err)
    }
    defer s1.Close()
    m1 := concurrency.NewMutex(s1, &quot;/my-lock/&quot;)

    s2, err := concurrency.NewSession(cli)
    if err != nil {
        log.Fatal(err)
    }
    defer s2.Close()
    m2 := concurrency.NewMutex(s2, &quot;/my-lock/&quot;)

    // acquire lock for s1
    if err := m1.Lock(context.TODO()); err != nil {
        log.Fatal(err)
    }
    fmt.Println(&quot;acquired lock for s1&quot;)

    m2Locked := make(chan struct{})
    go func() {
        defer close(m2Locked)
        // wait until s1 is locks /my-lock/
        if err := m2.Lock(context.TODO()); err != nil {
            log.Fatal(err)
        }
    }()

    if err := m1.Unlock(context.TODO()); err != nil {
        log.Fatal(err)
    }
    fmt.Println(&quot;released lock for s1&quot;)

    &lt;-m2Locked
    fmt.Println(&quot;acquired lock for s2&quot;)

    // Output:
    // acquired lock for s1
    // released lock for s1
    // acquired lock for s2
}
</code></pre><h3 id="分页">分页</h3>
<p>分页逻辑：</p>
<pre tabindex="0"><code>if page &gt; 0 &amp;&amp; pageSize &gt; 0 {
    Db = Db.Limit(pageSize).Offset((page - 1) * pageSize)
}
</code></pre><h4 id="接口层分页">接口层分页</h4>
<pre tabindex="0"><code>func CommonPaginate(x interface{}, offset int, limit int) (int, int) {
    xLen := reflect.ValueOf(x).Len()
    if offset+1 &gt; xLen {
        offset = xLen - 1
        if offset &lt; 0 {
            offset = 0
        }
    }
    end := offset + limit
    if end &gt; xLen {
        end = xLen
    }
    return offset, end
}
</code></pre><h3 id="发布-订阅模式">发布-订阅模式</h3>
<p>引用来自：moby项目提供pubsub简单实现</p>
<pre tabindex="0"><code>package main

import (
    &quot;fmt&quot;
    &quot;github.com/moby/moby/pkg/pubsub&quot;
    &quot;strings&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

func main() {
    p := pubsub.NewPublisher(100*time.Millisecond, 10)

    golang := p.SubscribeTopic(func(v interface{}) bool {
        if key, ok := v.(string); ok {
            if strings.HasPrefix(key, &quot;golang:&quot;) {
                return true
            }
        }
        return false
    })
    docker := p.SubscribeTopic(func(v interface{}) bool {
        if key, ok := v.(string); ok {
            if strings.HasPrefix(key, &quot;docker:&quot;) {
                return true
            }
        }
        return false
    })

    go p.Publish(&quot;hi&quot;)
    go p.Publish(&quot;golang: https://golang.org&quot;)
    go p.Publish(&quot;docker: https://www.docker.com/&quot;)
    time.Sleep(1)

    wg := &amp;sync.WaitGroup{}
    wg.Add(2)

    go func() {
        defer func() {
            wg.Done()
        }()
        fmt.Println(&quot;golang topic:&quot;, &lt;-golang)
    }()
    go func() {
        defer func() {
            wg.Done()
        }()
        fmt.Println(&quot;docker topic:&quot;, &lt;-docker)
    }()
    wg.Wait()
}
</code></pre><h3 id="定时器">定时器</h3>
<h4 id="自定义定时器">自定义定时器</h4>
<p>自定义一种定时器执行任务的job机制，在time Ticker基础上的升级版，大体思路是：</p>
<ol>
<li>定义一个Periodic接口类型</li>
<li>定义一个refreshData结构体，实现Periodic接口</li>
<li>定义一个DoPeriodic函数，遍历Periodic类型列表</li>
</ol>
<p>引用来自：https://github.com/helm/monocular</p>
<pre tabindex="0"><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

type Periodic interface {
    Do() error
    Frequency() time.Duration
    Name() string
    FirstRun() bool
}

type PeriodicCanceller func()

func DoPeriodic(pSlice []Periodic) PeriodicCanceller {
    doneCh := make(chan struct{})
    for _, p := range pSlice {
        go func(p Periodic) {
            if p.FirstRun() {
                err := p.Do()
                if err != nil {
                    fmt.Printf(&quot;periodic job ran and returned error (%s)\n&quot;, err)
                } else {
                    fmt.Printf(&quot;periodic job %s ran\n&quot;, p.Name())
                }
            }
            ticker := time.NewTicker(p.Frequency())
            for {
                select {
                case &lt;-ticker.C:
                    err := p.Do()
                    if err != nil {
                        fmt.Printf(&quot;periodic job ran and returned error (%s)\n&quot;, err)
                    }
                case &lt;-doneCh:
                    ticker.Stop()
                    return
                }
            }
        }(p)
    }
    return func() {
        close(doneCh)
    }
}

func NewRefreshData(frequency time.Duration, name string, firstRun bool) Periodic {
    return &amp;refreshData{
        frequency: frequency,
        name:      name,
        firstRun:  firstRun,
    }
}

type refreshData struct {
    frequency time.Duration
    name      string
    firstRun  bool
}

func (r *refreshData) Do() error {
    fmt.Printf(&quot;time: %s, %s Do xxx\n&quot;, time.Now(), r.name)
    return nil
}

func (r *refreshData) Frequency() time.Duration {
    return r.frequency
}

func (r *refreshData) FirstRun() bool {
    return r.firstRun
}

func (r *refreshData) Name() string {
    return r.name
}

func main() {
    var refreshInterval = 3
    freshness := time.Duration(refreshInterval) * time.Second
    periodicRefresh :=  NewRefreshData(freshness, &quot;refresh&quot;, false)
    newPeriodicRefresh :=  NewRefreshData(5*time.Second, &quot;test&quot;, true)
    toDo := []Periodic{periodicRefresh, newPeriodicRefresh}
    DoPeriodic(toDo)

    select {
    }
}
</code></pre><h4 id="time-ticker实现">time Ticker实现</h4>
<p>比较通用的做法：通过time Ticker获取一个time的channel</p>
<pre tabindex="0"><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    var (
        DefaultInterval = 1
    )

    done := make(chan bool)
    ticker := time.NewTicker(time.Duration(DefaultInterval) * time.Second)

    fmt.Println(&quot;begin!&quot;)
    go func() {
        for {
            select {
            case &lt;- done:
                fmt.Println(&quot;stop!&quot;)
                ticker.Stop()
                return
            case &lt;- ticker.C:
                fmt.Printf(&quot;time: %s, msg: trigger the periodic timer.\n&quot;, time.Now())
            }
        }
    }()
    time.Sleep(5*time.Second)
    done &lt;- true
    fmt.Println(&quot;end!&quot;)
}
</code></pre><h4 id="k8s定时器实现">k8s定时器实现</h4>
<p>引用来自: k8s.io/apimachinery/pkg/util/wait/wait.go</p>
<pre tabindex="0"><code>/*
Copyright 2014 The Kubernetes Authors.
Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package wait

import (
    &quot;context&quot;
    &quot;errors&quot;
    &quot;math&quot;
    &quot;math/rand&quot;
    &quot;sync&quot;
    &quot;time&quot;

    &quot;k8s.io/apimachinery/pkg/util/runtime&quot;
    &quot;k8s.io/utils/clock&quot;
)

// For any test of the style:
//   ...
//   &lt;- time.After(timeout):
//      t.Errorf(&quot;Timed out&quot;)
// The value for timeout should effectively be &quot;forever.&quot; Obviously we don't want our tests to truly lock up forever, but 30s
// is long enough that it is effectively forever for the things that can slow down a run on a heavily contended machine
// (GC, seeks, etc), but not so long as to make a developer ctrl-c a test run if they do happen to break that test.
var ForeverTestTimeout = time.Second * 30

// NeverStop may be passed to Until to make it never stop.
var NeverStop &lt;-chan struct{} = make(chan struct{})

// Group allows to start a group of goroutines and wait for their completion.
type Group struct {
    wg sync.WaitGroup
}

func (g *Group) Wait() {
    g.wg.Wait()
}

// StartWithChannel starts f in a new goroutine in the group.
// stopCh is passed to f as an argument. f should stop when stopCh is available.
func (g *Group) StartWithChannel(stopCh &lt;-chan struct{}, f func(stopCh &lt;-chan struct{})) {
    g.Start(func() {
        f(stopCh)
    })
}

// StartWithContext starts f in a new goroutine in the group.
// ctx is passed to f as an argument. f should stop when ctx.Done() is available.
func (g *Group) StartWithContext(ctx context.Context, f func(context.Context)) {
    g.Start(func() {
        f(ctx)
    })
}

// Start starts f in a new goroutine in the group.
func (g *Group) Start(f func()) {
    g.wg.Add(1)
    go func() {
        defer g.wg.Done()
        f()
    }()
}

// Forever calls f every period for ever.
//
// Forever is syntactic sugar on top of Until.
func Forever(f func(), period time.Duration) {
    Until(f, period, NeverStop)
}

// Until loops until stop channel is closed, running f every period.
//
// Until is syntactic sugar on top of JitterUntil with zero jitter factor and
// with sliding = true (which means the timer for period starts after the f
// completes).
func Until(f func(), period time.Duration, stopCh &lt;-chan struct{}) {
    JitterUntil(f, period, 0.0, true, stopCh)
}

// UntilWithContext loops until context is done, running f every period.
//
// UntilWithContext is syntactic sugar on top of JitterUntilWithContext
// with zero jitter factor and with sliding = true (which means the timer
// for period starts after the f completes).
func UntilWithContext(ctx context.Context, f func(context.Context), period time.Duration) {
    JitterUntilWithContext(ctx, f, period, 0.0, true)
}

// NonSlidingUntil loops until stop channel is closed, running f every
// period.
//
// NonSlidingUntil is syntactic sugar on top of JitterUntil with zero jitter
// factor, with sliding = false (meaning the timer for period starts at the same
// time as the function starts).
func NonSlidingUntil(f func(), period time.Duration, stopCh &lt;-chan struct{}) {
    JitterUntil(f, period, 0.0, false, stopCh)
}

// NonSlidingUntilWithContext loops until context is done, running f every
// period.
//
// NonSlidingUntilWithContext is syntactic sugar on top of JitterUntilWithContext
// with zero jitter factor, with sliding = false (meaning the timer for period
// starts at the same time as the function starts).
func NonSlidingUntilWithContext(ctx context.Context, f func(context.Context), period time.Duration) {
    JitterUntilWithContext(ctx, f, period, 0.0, false)
}

// JitterUntil loops until stop channel is closed, running f every period.
//
// If jitterFactor is positive, the period is jittered before every run of f.
// If jitterFactor is not positive, the period is unchanged and not jittered.
//
// If sliding is true, the period is computed after f runs. If it is false then
// period includes the runtime for f.
//
// Close stopCh to stop. f may not be invoked if stop channel is already
// closed. Pass NeverStop to if you don't want it stop.
func JitterUntil(f func(), period time.Duration, jitterFactor float64, sliding bool, stopCh &lt;-chan struct{}) {
    BackoffUntil(f, NewJitteredBackoffManager(period, jitterFactor, &amp;clock.RealClock{}), sliding, stopCh)
}

// BackoffUntil loops until stop channel is closed, run f every duration given by BackoffManager.
//
// If sliding is true, the period is computed after f runs. If it is false then
// period includes the runtime for f.
func BackoffUntil(f func(), backoff BackoffManager, sliding bool, stopCh &lt;-chan struct{}) {
    var t clock.Timer
    for {
        select {
        case &lt;-stopCh:
            return
        default:
        }

        if !sliding {
            t = backoff.Backoff()
        }

        func() {
            defer runtime.HandleCrash()
            f()
        }()

        if sliding {
            t = backoff.Backoff()
        }

        // NOTE: b/c there is no priority selection in golang
        // it is possible for this to race, meaning we could
        // trigger t.C and stopCh, and t.C select falls through.
        // In order to mitigate we re-check stopCh at the beginning
        // of every loop to prevent extra executions of f().
        select {
        case &lt;-stopCh:
            if !t.Stop() {
                &lt;-t.C()
            }
            return
        case &lt;-t.C():
        }
    }
}

// JitterUntilWithContext loops until context is done, running f every period.
//
// If jitterFactor is positive, the period is jittered before every run of f.
// If jitterFactor is not positive, the period is unchanged and not jittered.
//
// If sliding is true, the period is computed after f runs. If it is false then
// period includes the runtime for f.
//
// Cancel context to stop. f may not be invoked if context is already expired.
func JitterUntilWithContext(ctx context.Context, f func(context.Context), period time.Duration, jitterFactor float64, sliding bool) {
    JitterUntil(func() { f(ctx) }, period, jitterFactor, sliding, ctx.Done())
}

// Jitter returns a time.Duration between duration and duration + maxFactor *
// duration.
//
// This allows clients to avoid converging on periodic behavior. If maxFactor
// is 0.0, a suggested default value will be chosen.
func Jitter(duration time.Duration, maxFactor float64) time.Duration {
    if maxFactor &lt;= 0.0 {
        maxFactor = 1.0
    }
    wait := duration + time.Duration(rand.Float64()*maxFactor*float64(duration))
    return wait
}

// ErrWaitTimeout is returned when the condition exited without success.
var ErrWaitTimeout = errors.New(&quot;timed out waiting for the condition&quot;)

// ConditionFunc returns true if the condition is satisfied, or an error
// if the loop should be aborted.
type ConditionFunc func() (done bool, err error)

// ConditionWithContextFunc returns true if the condition is satisfied, or an error
// if the loop should be aborted.
//
// The caller passes along a context that can be used by the condition function.
type ConditionWithContextFunc func(context.Context) (done bool, err error)

// WithContext converts a ConditionFunc into a ConditionWithContextFunc
func (cf ConditionFunc) WithContext() ConditionWithContextFunc {
    return func(context.Context) (done bool, err error) {
        return cf()
    }
}

// runConditionWithCrashProtection runs a ConditionFunc with crash protection
func runConditionWithCrashProtection(condition ConditionFunc) (bool, error) {
    return runConditionWithCrashProtectionWithContext(context.TODO(), condition.WithContext())
}

// runConditionWithCrashProtectionWithContext runs a
// ConditionWithContextFunc with crash protection.
func runConditionWithCrashProtectionWithContext(ctx context.Context, condition ConditionWithContextFunc) (bool, error) {
    defer runtime.HandleCrash()
    return condition(ctx)
}

// Backoff holds parameters applied to a Backoff function.
type Backoff struct {
    // The initial duration.
    Duration time.Duration
    // Duration is multiplied by factor each iteration, if factor is not zero
    // and the limits imposed by Steps and Cap have not been reached.
    // Should not be negative.
    // The jitter does not contribute to the updates to the duration parameter.
    Factor float64
    // The sleep at each iteration is the duration plus an additional
    // amount chosen uniformly at random from the interval between
    // zero and `jitter*duration`.
    Jitter float64
    // The remaining number of iterations in which the duration
    // parameter may change (but progress can be stopped earlier by
    // hitting the cap). If not positive, the duration is not
    // changed. Used for exponential backoff in combination with
    // Factor and Cap.
    Steps int
    // A limit on revised values of the duration parameter. If a
    // multiplication by the factor parameter would make the duration
    // exceed the cap then the duration is set to the cap and the
    // steps parameter is set to zero.
    Cap time.Duration
}

// Step (1) returns an amount of time to sleep determined by the
// original Duration and Jitter and (2) mutates the provided Backoff
// to update its Steps and Duration.
func (b *Backoff) Step() time.Duration {
    if b.Steps &lt; 1 {
        if b.Jitter &gt; 0 {
            return Jitter(b.Duration, b.Jitter)
        }
        return b.Duration
    }
    b.Steps--

    duration := b.Duration

    // calculate the next step
    if b.Factor != 0 {
        b.Duration = time.Duration(float64(b.Duration) * b.Factor)
        if b.Cap &gt; 0 &amp;&amp; b.Duration &gt; b.Cap {
            b.Duration = b.Cap
            b.Steps = 0
        }
    }

    if b.Jitter &gt; 0 {
        duration = Jitter(duration, b.Jitter)
    }
    return duration
}

// contextForChannel derives a child context from a parent channel.
//
// The derived context's Done channel is closed when the returned cancel function
// is called or when the parent channel is closed, whichever happens first.
//
// Note the caller must *always* call the CancelFunc, otherwise resources may be leaked.
func contextForChannel(parentCh &lt;-chan struct{}) (context.Context, context.CancelFunc) {
    ctx, cancel := context.WithCancel(context.Background())

    go func() {
        select {
        case &lt;-parentCh:
            cancel()
        case &lt;-ctx.Done():
        }
    }()
    return ctx, cancel
}

// BackoffManager manages backoff with a particular scheme based on its underlying implementation. It provides
// an interface to return a timer for backoff, and caller shall backoff until Timer.C() drains. If the second Backoff()
// is called before the timer from the first Backoff() call finishes, the first timer will NOT be drained and result in
// undetermined behavior.
// The BackoffManager is supposed to be called in a single-threaded environment.
type BackoffManager interface {
    Backoff() clock.Timer
}

type exponentialBackoffManagerImpl struct {
    backoff              *Backoff
    backoffTimer         clock.Timer
    lastBackoffStart     time.Time
    initialBackoff       time.Duration
    backoffResetDuration time.Duration
    clock                clock.Clock
}

// NewExponentialBackoffManager returns a manager for managing exponential backoff. Each backoff is jittered and
// backoff will not exceed the given max. If the backoff is not called within resetDuration, the backoff is reset.
// This backoff manager is used to reduce load during upstream unhealthiness.
func NewExponentialBackoffManager(initBackoff, maxBackoff, resetDuration time.Duration, backoffFactor, jitter float64, c clock.Clock) BackoffManager {
    return &amp;exponentialBackoffManagerImpl{
        backoff: &amp;Backoff{
            Duration: initBackoff,
            Factor:   backoffFactor,
            Jitter:   jitter,

            // the current impl of wait.Backoff returns Backoff.Duration once steps are used up, which is not
            // what we ideally need here, we set it to max int and assume we will never use up the steps
            Steps: math.MaxInt32,
            Cap:   maxBackoff,
        },
        backoffTimer:         nil,
        initialBackoff:       initBackoff,
        lastBackoffStart:     c.Now(),
        backoffResetDuration: resetDuration,
        clock:                c,
    }
}

func (b *exponentialBackoffManagerImpl) getNextBackoff() time.Duration {
    if b.clock.Now().Sub(b.lastBackoffStart) &gt; b.backoffResetDuration {
        b.backoff.Steps = math.MaxInt32
        b.backoff.Duration = b.initialBackoff
    }
    b.lastBackoffStart = b.clock.Now()
    return b.backoff.Step()
}

// Backoff implements BackoffManager.Backoff, it returns a timer so caller can block on the timer for exponential backoff.
// The returned timer must be drained before calling Backoff() the second time
func (b *exponentialBackoffManagerImpl) Backoff() clock.Timer {
    if b.backoffTimer == nil {
        b.backoffTimer = b.clock.NewTimer(b.getNextBackoff())
    } else {
        b.backoffTimer.Reset(b.getNextBackoff())
    }
    return b.backoffTimer
}

type jitteredBackoffManagerImpl struct {
    clock        clock.Clock
    duration     time.Duration
    jitter       float64
    backoffTimer clock.Timer
}

// NewJitteredBackoffManager returns a BackoffManager that backoffs with given duration plus given jitter. If the jitter
// is negative, backoff will not be jittered.
func NewJitteredBackoffManager(duration time.Duration, jitter float64, c clock.Clock) BackoffManager {
    return &amp;jitteredBackoffManagerImpl{
        clock:        c,
        duration:     duration,
        jitter:       jitter,
        backoffTimer: nil,
    }
}

func (j *jitteredBackoffManagerImpl) getNextBackoff() time.Duration {
    jitteredPeriod := j.duration
    if j.jitter &gt; 0.0 {
        jitteredPeriod = Jitter(j.duration, j.jitter)
    }
    return jitteredPeriod
}

// Backoff implements BackoffManager.Backoff, it returns a timer so caller can block on the timer for jittered backoff.
// The returned timer must be drained before calling Backoff() the second time
func (j *jitteredBackoffManagerImpl) Backoff() clock.Timer {
    backoff := j.getNextBackoff()
    if j.backoffTimer == nil {
        j.backoffTimer = j.clock.NewTimer(backoff)
    } else {
        j.backoffTimer.Reset(backoff)
    }
    return j.backoffTimer
}

// ExponentialBackoff repeats a condition check with exponential backoff.
//
// It repeatedly checks the condition and then sleeps, using `backoff.Step()`
// to determine the length of the sleep and adjust Duration and Steps.
// Stops and returns as soon as:
// 1. the condition check returns true or an error,
// 2. `backoff.Steps` checks of the condition have been done, or
// 3. a sleep truncated by the cap on duration has been completed.
// In case (1) the returned error is what the condition function returned.
// In all other cases, ErrWaitTimeout is returned.
func ExponentialBackoff(backoff Backoff, condition ConditionFunc) error {
    for backoff.Steps &gt; 0 {
        if ok, err := runConditionWithCrashProtection(condition); err != nil || ok {
            return err
        }
        if backoff.Steps == 1 {
            break
        }
        time.Sleep(backoff.Step())
    }
    return ErrWaitTimeout
}

// Poll tries a condition func until it returns true, an error, or the timeout
// is reached.
//
// Poll always waits the interval before the run of 'condition'.
// 'condition' will always be invoked at least once.
//
// Some intervals may be missed if the condition takes too long or the time
// window is too short.
//
// If you want to Poll something forever, see PollInfinite.
func Poll(interval, timeout time.Duration, condition ConditionFunc) error {
    return PollWithContext(context.Background(), interval, timeout, condition.WithContext())
}

// PollWithContext tries a condition func until it returns true, an error,
// or when the context expires or the timeout is reached, whichever
// happens first.
//
// PollWithContext always waits the interval before the run of 'condition'.
// 'condition' will always be invoked at least once.
//
// Some intervals may be missed if the condition takes too long or the time
// window is too short.
//
// If you want to Poll something forever, see PollInfinite.
func PollWithContext(ctx context.Context, interval, timeout time.Duration, condition ConditionWithContextFunc) error {
    return poll(ctx, false, poller(interval, timeout), condition)
}

// PollUntil tries a condition func until it returns true, an error or stopCh is
// closed.
//
// PollUntil always waits interval before the first run of 'condition'.
// 'condition' will always be invoked at least once.
func PollUntil(interval time.Duration, condition ConditionFunc, stopCh &lt;-chan struct{}) error {
    ctx, cancel := contextForChannel(stopCh)
    defer cancel()
    return PollUntilWithContext(ctx, interval, condition.WithContext())
}

// PollUntilWithContext tries a condition func until it returns true,
// an error or the specified context is cancelled or expired.
//
// PollUntilWithContext always waits interval before the first run of 'condition'.
// 'condition' will always be invoked at least once.
func PollUntilWithContext(ctx context.Context, interval time.Duration, condition ConditionWithContextFunc) error {
    return poll(ctx, false, poller(interval, 0), condition)
}

// PollInfinite tries a condition func until it returns true or an error
//
// PollInfinite always waits the interval before the run of 'condition'.
//
// Some intervals may be missed if the condition takes too long or the time
// window is too short.
func PollInfinite(interval time.Duration, condition ConditionFunc) error {
    return PollInfiniteWithContext(context.Background(), interval, condition.WithContext())
}

// PollInfiniteWithContext tries a condition func until it returns true or an error
//
// PollInfiniteWithContext always waits the interval before the run of 'condition'.
//
// Some intervals may be missed if the condition takes too long or the time
// window is too short.
func PollInfiniteWithContext(ctx context.Context, interval time.Duration, condition ConditionWithContextFunc) error {
    return poll(ctx, false, poller(interval, 0), condition)
}

// PollImmediate tries a condition func until it returns true, an error, or the timeout
// is reached.
//
// PollImmediate always checks 'condition' before waiting for the interval. 'condition'
// will always be invoked at least once.
//
// Some intervals may be missed if the condition takes too long or the time
// window is too short.
//
// If you want to immediately Poll something forever, see PollImmediateInfinite.
func PollImmediate(interval, timeout time.Duration, condition ConditionFunc) error {
    return PollImmediateWithContext(context.Background(), interval, timeout, condition.WithContext())
}

// PollImmediateWithContext tries a condition func until it returns true, an error,
// or the timeout is reached or the specified context expires, whichever happens first.
//
// PollImmediateWithContext always checks 'condition' before waiting for the interval.
// 'condition' will always be invoked at least once.
//
// Some intervals may be missed if the condition takes too long or the time
// window is too short.
//
// If you want to immediately Poll something forever, see PollImmediateInfinite.
func PollImmediateWithContext(ctx context.Context, interval, timeout time.Duration, condition ConditionWithContextFunc) error {
    return poll(ctx, true, poller(interval, timeout), condition)
}

// PollImmediateUntil tries a condition func until it returns true, an error or stopCh is closed.
//
// PollImmediateUntil runs the 'condition' before waiting for the interval.
// 'condition' will always be invoked at least once.
func PollImmediateUntil(interval time.Duration, condition ConditionFunc, stopCh &lt;-chan struct{}) error {
    ctx, cancel := contextForChannel(stopCh)
    defer cancel()
    return PollImmediateUntilWithContext(ctx, interval, condition.WithContext())
}

// PollImmediateUntilWithContext tries a condition func until it returns true,
// an error or the specified context is cancelled or expired.
//
// PollImmediateUntilWithContext runs the 'condition' before waiting for the interval.
// 'condition' will always be invoked at least once.
func PollImmediateUntilWithContext(ctx context.Context, interval time.Duration, condition ConditionWithContextFunc) error {
    return poll(ctx, true, poller(interval, 0), condition)
}

// PollImmediateInfinite tries a condition func until it returns true or an error
//
// PollImmediateInfinite runs the 'condition' before waiting for the interval.
//
// Some intervals may be missed if the condition takes too long or the time
// window is too short.
func PollImmediateInfinite(interval time.Duration, condition ConditionFunc) error {
    return PollImmediateInfiniteWithContext(context.Background(), interval, condition.WithContext())
}

// PollImmediateInfiniteWithContext tries a condition func until it returns true
// or an error or the specified context gets cancelled or expired.
//
// PollImmediateInfiniteWithContext runs the 'condition' before waiting for the interval.
//
// Some intervals may be missed if the condition takes too long or the time
// window is too short.
func PollImmediateInfiniteWithContext(ctx context.Context, interval time.Duration, condition ConditionWithContextFunc) error {
    return poll(ctx, true, poller(interval, 0), condition)
}

// Internally used, each of the the public 'Poll*' function defined in this
// package should invoke this internal function with appropriate parameters.
// ctx: the context specified by the caller, for infinite polling pass
// a context that never gets cancelled or expired.
// immediate: if true, the 'condition' will be invoked before waiting for the interval,
// in this case 'condition' will always be invoked at least once.
// wait: user specified WaitFunc function that controls at what interval the condition
// function should be invoked periodically and whether it is bound by a timeout.
// condition: user specified ConditionWithContextFunc function.
func poll(ctx context.Context, immediate bool, wait WaitWithContextFunc, condition ConditionWithContextFunc) error {
    if immediate {
        done, err := runConditionWithCrashProtectionWithContext(ctx, condition)
        if err != nil {
            return err
        }
        if done {
            return nil
        }
    }

    select {
    case &lt;-ctx.Done():
        // returning ctx.Err() will break backward compatibility
        return ErrWaitTimeout
    default:
        return WaitForWithContext(ctx, wait, condition)
    }
}

// WaitFunc creates a channel that receives an item every time a test
// should be executed and is closed when the last test should be invoked.
type WaitFunc func(done &lt;-chan struct{}) &lt;-chan struct{}

// WithContext converts the WaitFunc to an equivalent WaitWithContextFunc
func (w WaitFunc) WithContext() WaitWithContextFunc {
    return func(ctx context.Context) &lt;-chan struct{} {
        return w(ctx.Done())
    }
}

// WaitWithContextFunc creates a channel that receives an item every time a test
// should be executed and is closed when the last test should be invoked.
//
// When the specified context gets cancelled or expires the function
// stops sending item and returns immediately.
type WaitWithContextFunc func(ctx context.Context) &lt;-chan struct{}

// WaitFor continually checks 'fn' as driven by 'wait'.
//
// WaitFor gets a channel from 'wait()'', and then invokes 'fn' once for every value
// placed on the channel and once more when the channel is closed. If the channel is closed
// and 'fn' returns false without error, WaitFor returns ErrWaitTimeout.
//
// If 'fn' returns an error the loop ends and that error is returned. If
// 'fn' returns true the loop ends and nil is returned.
//
// ErrWaitTimeout will be returned if the 'done' channel is closed without fn ever
// returning true.
//
// When the done channel is closed, because the golang `select` statement is
// &quot;uniform pseudo-random&quot;, the `fn` might still run one or multiple time,
// though eventually `WaitFor` will return.
func WaitFor(wait WaitFunc, fn ConditionFunc, done &lt;-chan struct{}) error {
    ctx, cancel := contextForChannel(done)
    defer cancel()
    return WaitForWithContext(ctx, wait.WithContext(), fn.WithContext())
}

// WaitForWithContext continually checks 'fn' as driven by 'wait'.
//
// WaitForWithContext gets a channel from 'wait()'', and then invokes 'fn'
// once for every value placed on the channel and once more when the
// channel is closed. If the channel is closed and 'fn'
// returns false without error, WaitForWithContext returns ErrWaitTimeout.
//
// If 'fn' returns an error the loop ends and that error is returned. If
// 'fn' returns true the loop ends and nil is returned.
//
// context.Canceled will be returned if the ctx.Done() channel is closed
// without fn ever returning true.
//
// When the ctx.Done() channel is closed, because the golang `select` statement is
// &quot;uniform pseudo-random&quot;, the `fn` might still run one or multiple times,
// though eventually `WaitForWithContext` will return.
func WaitForWithContext(ctx context.Context, wait WaitWithContextFunc, fn ConditionWithContextFunc) error {
    waitCtx, cancel := context.WithCancel(context.Background())
    defer cancel()
    c := wait(waitCtx)
    for {
        select {
        case _, open := &lt;-c:
            ok, err := runConditionWithCrashProtectionWithContext(ctx, fn)
            if err != nil {
                return err
            }
            if ok {
                return nil
            }
            if !open {
                return ErrWaitTimeout
            }
        case &lt;-ctx.Done():
            // returning ctx.Err() will break backward compatibility
            return ErrWaitTimeout
        }
    }
}

// poller returns a WaitFunc that will send to the channel every interval until
// timeout has elapsed and then closes the channel.
//
// Over very short intervals you may receive no ticks before the channel is
// closed. A timeout of 0 is interpreted as an infinity, and in such a case
// it would be the caller's responsibility to close the done channel.
// Failure to do so would result in a leaked goroutine.
//
// Output ticks are not buffered. If the channel is not ready to receive an
// item, the tick is skipped.
func poller(interval, timeout time.Duration) WaitWithContextFunc {
    return WaitWithContextFunc(func(ctx context.Context) &lt;-chan struct{} {
        ch := make(chan struct{})

        go func() {
            defer close(ch)

            tick := time.NewTicker(interval)
            defer tick.Stop()

            var after &lt;-chan time.Time
            if timeout != 0 {
                // time.After is more convenient, but it
                // potentially leaves timers around much longer
                // than necessary if we exit early.
                timer := time.NewTimer(timeout)
                after = timer.C
                defer timer.Stop()
            }

            for {
                select {
                case &lt;-tick.C:
                    // If the consumer isn't ready for this signal drop it and
                    // check the other channels.
                    select {
                    case ch &lt;- struct{}{}:
                    default:
                    }
                case &lt;-after:
                    return
                case &lt;-ctx.Done():
                    return
                }
            }
        }()

        return ch
    })
}

// ExponentialBackoffWithContext works with a request context and a Backoff. It ensures that the retry wait never
// exceeds the deadline specified by the request context.
func ExponentialBackoffWithContext(ctx context.Context, backoff Backoff, condition ConditionFunc) error {
    for backoff.Steps &gt; 0 {
        select {
        case &lt;-ctx.Done():
            return ctx.Err()
        default:
        }

        if ok, err := runConditionWithCrashProtection(condition); err != nil || ok {
            return err
        }

        if backoff.Steps == 1 {
            break
        }

        waitBeforeRetry := backoff.Step()
        select {
        case &lt;-ctx.Done():
            return ctx.Err()
        case &lt;-time.After(waitBeforeRetry):
        }
    }

    return ErrWaitTimeout
}
</code></pre><h3 id="捕获goroutine异常">捕获Goroutine异常</h3>
<h4 id="无缓冲channel实现">无缓冲channel实现</h4>
<p>定义一个包含Error的struct，再定义一个无缓冲的channel实现同步传递</p>
<pre tabindex="0"><code>package main

type Result struct {
    Error error
}

func updateNode(node string) error {
    return nil
}

func main() {
    nodeList := make([]string, 10)
    checkStatus := func(done &lt;-chan interface{}, nodeList ...string) &lt;-chan Result {
        results := make(chan Result)
        go func() {
            defer close(results)
            for _, node := range nodeList {
                var result Result
                // update node
                err := updateNode(node)
                result = Result{Error: err}
                select {
                case &lt;- done:
                    return
                case results &lt;- result:
                }
            }
        }()
        return results
    }

    done := make(chan interface{})
    defer close(done)

    for result := range checkStatus(done, nodeList...) {
        if result.Error != nil {
            panic(result.Error)
        }
    }
}
</code></pre><h4 id="sync-errgroup实现">sync errgroup实现</h4>
<p>使用sync包提供的errgroup, errgroup提供同步，error收集，可使用context取消正处于任务中运行的goroutines.
errgroup可直接看源码，源码比较简短</p>
<pre tabindex="0"><code>package main

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), thresholdTime)
    defer cancel()
    g, ctx := errgroup.WithContext(ctx)

    if felixLive {
        g.Go(func() error {
            if err := checkFelixHealth(ctx, felixLivenessEp, &quot;liveness&quot;); err != nil {
                return fmt.Errorf(&quot;calico/node is not ready: Felix is not live: %+v&quot;, err)
            }
            return nil
        })
    }

    if birdLive {
        g.Go(func() error {
            if err := checkServiceIsLive([]string{&quot;confd&quot;, &quot;bird&quot;}); err != nil {
                return fmt.Errorf(&quot;calico/node is not ready: bird/confd is not live: %+v&quot;, err)
            }
            return nil
        })
    }

    if bird6Live {
        g.Go(func() error {
            if err := checkServiceIsLive([]string{&quot;confd&quot;, &quot;bird6&quot;}); err != nil {
                return fmt.Errorf(&quot;calico/node is not ready: bird6/confd is not live: %+v&quot;, err)
            }
            return nil
        })
    }

    if felixReady {
        g.Go(func() error {
            if err := checkFelixHealth(ctx, felixReadinessEp, &quot;readiness&quot;); err != nil {
                return fmt.Errorf(&quot;calico/node is not ready: felix is not ready: %+v&quot;, err)
            }
            return nil
        })
    }

    if bird {
        g.Go(func() error {
            if err := checkBIRDReady(&quot;4&quot;, thresholdTime); err != nil {
                return fmt.Errorf(&quot;calico/node is not ready: BIRD is not ready: %+v&quot;, err)
            }
            return nil
        })
    }

    if bird6 {
        g.Go(func() error {
            if err := checkBIRDReady(&quot;6&quot;, thresholdTime); err != nil {
                return fmt.Errorf(&quot;calico/node is not ready: BIRD6 is not ready: %+v&quot;, err)
            }
            return nil
        })
    }
    if err := g.Wait(); err != nil {
        fmt.Printf(&quot;%s&quot;, err)
        os.Exit(1)
    }
}
</code></pre><h4 id="加锁slice实现">加锁Slice实现</h4>
<p>定义一个error类型的Slice, 通过加读写锁对它进行操作</p>
<p>引用来自：kubernetes/pkg/scheduler/core/generic_scheduler.go的代码片段</p>
<pre tabindex="0"><code>package main

func main() {
    /*
    var (
        mu   = sync.Mutex{}
        wg   = sync.WaitGroup{}
        errs []error
    )
    appendError := func(err error) {
        mu.Lock()
        defer mu.Unlock()
        errs = append(errs, err)
    }

    results := make([]schedulerapi.HostPriorityList, len(priorityConfigs), len(priorityConfigs))

    // DEPRECATED: we can remove this when all priorityConfigs implement the
    // Map-Reduce pattern.
    for i := range priorityConfigs {
        if priorityConfigs[i].Function != nil {
            wg.Add(1)
            go func(index int) {
                defer wg.Done()
                var err error
                results[index], err = priorityConfigs[index].Function(pod, nodeNameToInfo, nodes)
                if err != nil {
                    appendError(err)
                }
            }(i)
        } else {
            results[i] = make(schedulerapi.HostPriorityList, len(nodes))
        }
    }

    // Wait for all computations to be finished.
    wg.Wait()
    if len(errs) != 0 {
        return schedulerapi.HostPriorityList{}, errors.NewAggregate(errs)
    }
    */
}
</code></pre><h3 id="goroutine池">goroutine池</h3>
<p>通过sync.WaitGroup + channel控制数量</p>
<p>引用来自：k8s.io/client-go/util/workqueue/parallelizer.go</p>
<pre tabindex="0"><code>package workqueue

import (
    &quot;context&quot;
    &quot;sync&quot;

    utilruntime &quot;k8s.io/apimachinery/pkg/util/runtime&quot;
)

type DoWorkPieceFunc func(piece int)

type options struct {
    chunkSize int
}

type Options func(*options)

// WithChunkSize allows to set chunks of work items to the workers, rather than
// processing one by one.
// It is recommended to use this option if the number of pieces significantly
// higher than the number of workers and the work done for each item is small.
func WithChunkSize(c int) func(*options) {
    return func(o *options) {
        o.chunkSize = c
    }
}

// ParallelizeUntil is a framework that allows for parallelizing N
// independent pieces of work until done or the context is canceled.
func ParallelizeUntil(ctx context.Context, workers, pieces int, doWorkPiece DoWorkPieceFunc, opts ...Options) {
    if pieces == 0 {
        return
    }
    o := options{}
    for _, opt := range opts {
        opt(&amp;o)
    }
    chunkSize := o.chunkSize
    if chunkSize &lt; 1 {
        chunkSize = 1
    }

    chunks := ceilDiv(pieces, chunkSize)
    toProcess := make(chan int, chunks)
    for i := 0; i &lt; chunks; i++ {
        toProcess &lt;- i
    }
    //不影响读
    close(toProcess)

    var stop &lt;-chan struct{}
    if ctx != nil {
        stop = ctx.Done()
    }
    if chunks &lt; workers {
        workers = chunks
    }
    wg := sync.WaitGroup{}
    wg.Add(workers)
    for i := 0; i &lt; workers; i++ {
        go func() {
            defer utilruntime.HandleCrash()
            defer wg.Done()
            //并发从channel中读取
            for chunk := range toProcess {
                start := chunk * chunkSize
                end := start + chunkSize
                if end &gt; pieces {
                    end = pieces
                }
                for p := start; p &lt; end; p++ {
                    select {
                    case &lt;-stop:
                        return
                    default:
                        doWorkPiece(p)
                    }
                }
            }
        }()
    }
    wg.Wait()
}

func ceilDiv(a, b int) int {
    return (a + b - 1) / b
}
</code></pre><h3 id="无锁栈">无锁栈</h3>
<h4 id="atomic实现">atomic实现</h4>
<pre tabindex="0"><code>package main

import (
    &quot;sync/atomic&quot;
    &quot;unsafe&quot;
)

// LFStack 无锁栈
// 使用链表实现
type LFStack struct {
    head unsafe.Pointer // 栈顶
}

// Node 节点
type Node struct {
    val  int32
    next unsafe.Pointer
}

// NewLFStack NewLFStack
func NewLFStack() *LFStack {
    n := unsafe.Pointer(&amp;Node{})
    return &amp;LFStack{head: n}
}

// Push 入栈
func (s *LFStack) Push(v int32) {
    n := &amp;Node{val: v}

    for {
        // 先取出栈顶
        old := atomic.LoadPointer(&amp;s.head)
        n.next = old
        if atomic.CompareAndSwapPointer(&amp;s.head, old, unsafe.Pointer(n)) {
            return
        }
    }
}

// Pop 出栈，没有数据时返回 nil
func (s *LFStack) Pop() int32 {
    for {
        // 先取出栈顶
        old := atomic.LoadPointer(&amp;s.head)
        if old == nil {
            return 0
        }

        oldNode := (*Node)(old)
        // 取出下一个节点
        next := atomic.LoadPointer(&amp;oldNode.next)
        // 重置栈顶
        if atomic.CompareAndSwapPointer(&amp;s.head, old, next) {
            return oldNode.val
        }
    }
}
</code></pre><h3 id="消费者-生产者-工作队列模式">消费者-生产者-工作队列模式</h3>
<h4 id="channel实现">channel实现</h4>
<p>一个任务的执行过程如下：</p>
<ul>
<li>JobQueue &lt;- work  新任务入队</li>
<li>job := &lt;-JobQueue: 调度中心收到任务</li>
<li>jobChannel := &lt;-d.WorkerPool 从工作者池取到一个工作者</li>
<li>jobChannel &lt;- job 任务给到工作者</li>
<li>job := &lt;-w.JobChannel 工作者取出任务</li>
<li>{{1}} 执行任务</li>
<li>w.WorkerPool &lt;- w.JobChannel 工作者在放回工作者池</li>
</ul>
<pre tabindex="0"><code>package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
    &quot;runtime&quot;
    &quot;time&quot;
)

var (
    MaxWorker = 10
)

type Payload struct {
    Num int
}

//待执行的工作
type Job struct {
    Payload Payload
}

//任务channal
var JobQueue chan Job

//执行任务的工作者单元
type Worker struct {
    WorkerPool chan chan Job //工作者池--每个元素是一个工作者的私有任务channal
    JobChannel chan Job      //每个工作者单元包含一个任务管道 用于获取任务
    quit       chan bool     //退出信号
    no         int           //编号
}

//创建一个新工作者单元
func NewWorker(workerPool chan chan Job, no int) Worker {
    fmt.Println(&quot;创建了工作者&quot;, no)
    return Worker{
        WorkerPool: workerPool,
        JobChannel: make(chan Job),
        quit:       make(chan bool),
        no:         no,
    }
}

//循环监听任务和结束信号
func (w Worker) Start() {
    go func() {
        for {
            // register the current worker into the worker queue.
            w.WorkerPool &lt;- w.JobChannel
            fmt.Println(&quot;w.WorkerPool &lt;- w.JobChannel&quot;, w)
            select {
            case job := &lt;-w.JobChannel:
                fmt.Println(&quot;job := &lt;-w.JobChannel&quot;)
                // 收到任务
                fmt.Println(job)
                time.Sleep(100 * time.Second)
            case &lt;-w.quit:
                // 收到退出信号
                return
            }
        }
    }()
}

// 停止信号
func (w Worker) Stop() {
    go func() {
        w.quit &lt;- true
    }()
}

//调度中心
type Dispatcher struct {
    //工作者池
    WorkerPool chan chan Job
    //工作者数量
    MaxWorkers int
}

//创建调度中心
func NewDispatcher(maxWorkers int) *Dispatcher {
    pool := make(chan chan Job, maxWorkers)
    return &amp;Dispatcher{WorkerPool: pool, MaxWorkers: maxWorkers}
}

//工作者池的初始化
func (d *Dispatcher) Run() {
    // starting n number of workers
    for i := 1; i &lt; d.MaxWorkers+1; i++ {
        worker := NewWorker(d.WorkerPool, i)
        worker.Start()
    }
    go d.dispatch()
}

//调度
func (d *Dispatcher) dispatch() {
    for {
        select {
        case job := &lt;-JobQueue:
            fmt.Println(&quot;job := &lt;-JobQueue:&quot;)
            go func(job Job) {
                //等待空闲worker (任务多的时候会阻塞这里)
                jobChannel := &lt;-d.WorkerPool
                fmt.Println(&quot;jobChannel := &lt;-d.WorkerPool&quot;, reflect.TypeOf(jobChannel))
                // 将任务放到上述woker的私有任务channal中
                jobChannel &lt;- job
                fmt.Println(&quot;jobChannel &lt;- job&quot;)
            }(job)
        }
    }
}

func main() {
    JobQueue = make(chan Job, 10)
    dispatcher := NewDispatcher(MaxWorker)
    dispatcher.Run()
    time.Sleep(1 * time.Second)
    go addQueue()
    time.Sleep(1000 * time.Second)
}

func addQueue() {
    for i := 0; i &lt; 20; i++ {
        // 新建一个任务
        payLoad := Payload{Num: i}
        work := Job{Payload: payLoad}
        // 任务放入任务队列channal
        JobQueue &lt;- work
        fmt.Println(&quot;JobQueue &lt;- work&quot;, i)
        fmt.Println(&quot;当前协程数:&quot;, runtime.NumGoroutine())
        time.Sleep(100 * time.Millisecond)
    }
}
</code></pre><h4 id="控制并发数的channel实现">控制并发数的channel实现</h4>
<p>在job_worker基础上扩展，增加DispatchNumControl分发控制数，activeAccount worker活跃数控制，
不过会丢部分job</p>
<p>引用来自：http://blog.cocosdever.com/2018/08/22/goroutine-channel-Job-Worker-mode</p>
<pre tabindex="0"><code>package main
import (
    &quot;fmt&quot;
    &quot;runtime&quot;
    &quot;time&quot;
)
// 定义一些全局常量
var (
    MaxWorker             = 10
    MaxDispatchNumControl = 20
)
// Payload 任务里面的负载
type Payload struct {
    Num int
}
// Job 任务结构体
type Job struct {
    Payload Payload
}
// JobQueue 定义全局Job队列, 新增加的任务就丢进该任务队列即可
var JobQueue chan Job
// WorkerList 工作单元切片
var WorkerList []*Worker
//用于控制并发处理的协程数
var DispatchNumControl chan bool
func Limit(job Job) bool {
    select {
    case &lt;-time.After(time.Millisecond * 100):
        fmt.Println(&quot;我很忙&quot;)
        return false
    case DispatchNumControl &lt;- true:
        // 任务放入全局任务队列channal
        JobQueue &lt;- job
        return true
    }
}
// Worker 工作者单元, 用于执行Job的单元, 数量有限, 由调度中心分配
type Worker struct {
    WorkerPool chan chan Job //存放JobChan的池子
    JobChan    chan Job
    quit       chan bool
    No         int
}
// NewWorker 创建工作单元
func NewWorker(workerPool chan chan Job, no int) *Worker {
    fmt.Println(&quot;创建了工作者&quot;, no)
    return &amp;Worker{
        WorkerPool: workerPool,
        JobChan:    make(chan Job),
        quit:       make(chan bool),
        No:         no,
    }
}
// Start 开始工作
func (w *Worker) Start() {
    go func() {
        for {
            // 注册JobChan到工作池中,  然后开始工作循环
            w.WorkerPool &lt;- w.JobChan
            fmt.Println(&quot;w.WorkerPool &lt;- w.JobChan | w:&quot;, w)
            //如果有工作进来就执行工作, 收到退出信号就退出
            select {
            case job := &lt;-w.JobChan:
                //收到job, 开始工作
                fmt.Println(&quot;job := &lt;-w.JobChan&quot;)
                fmt.Println(job)
                //完成之后释放控制中心额度
                &lt;-DispatchNumControl
                time.Sleep(5 * time.Second)
            case &lt;-w.quit:
                fmt.Println(&quot;&lt;-w.Quit | w:&quot;, w)
                return
            }
        }
    }()
}
// Stop 暂停工作
func (w *Worker) Stop() {
    go func() {
        w.quit &lt;- true
    }()
}
// Dispatcher 调度中心, 用于创建工作单元Worker, 安排Worker执行Job
type Dispatcher struct {
    WorkerPool  chan chan Job
    MaxWorkers  int
    ActiveCount int
}
// NewDispatcher 创建调度中心
func NewDispatcher(max int) *Dispatcher {
    return &amp;Dispatcher{
        WorkerPool: make(chan chan Job, max),
        MaxWorkers: max,
    }
}
// Run 根据MaxWorkers, 创建工作者, 同时让工作者运行起来
func (d *Dispatcher) Run() {
    for i := 0; i &lt; d.MaxWorkers; i++ {
        worker := NewWorker(d.WorkerPool, i)
        worker.Start()
        // 将工作单元存进切片中
        WorkerList[i] = worker
        d.ActiveCount++
    }
    go d.dispatcher()
}
// dispatcher 读取全局job队列, 开始分配任务
func (d *Dispatcher) dispatcher() {
    for {
        select {
        case job := &lt;-JobQueue:
            go func(job Job) {
                // 从池中找到一个空闲的JobChan, 如果没有空闲的就会堵塞
                jobChan := &lt;-d.WorkerPool
                fmt.Println(&quot;jobChan := &lt;-d.WorkerPool&quot;)
                //把job丢给工作者
                jobChan &lt;- job
                //每次丢进一个job给工作者之后, 就删除一个工作者, 直到工作者数量维持在5个
                fmt.Println(&quot;d.ActiveCount: &quot;, d.ActiveCount)
                if d.ActiveCount &gt; 5 {
                    worker := WorkerList[d.ActiveCount-1]
                    fmt.Println(&quot;worker := WorkerList[d.ActiveCount-1] | worker: &quot;, worker)
                    worker.Stop()
                    d.ActiveCount--
                }
            }(job)
        }
    }
}
// AddQueue 往全局队列中添加job
func AddQueue(n int) {
    for i := 0; i &lt; n; i++ {
        job := Job{Payload{i}}
        fmt.Println(&quot;JobQueue &lt;- job&quot;, job)
        // 只有在DispatchNumControl缓冲还未满的时候, 才能将job加入到JobQueue中
        // 因为一旦加入到JobQueue之后, 系统立马会将job从队头取出, 分配一个协程去单独处理后续的工作
        // 为了避免协程数量过多, 所以使用Lmit函数做总体控制
        if Limit(job) {
            fmt.Println(&quot;任务成功加入全局队列&quot;)
        } else {
            fmt.Println(&quot;全局队列已满, 暂不处理任务&quot;)
            i--
        }
        fmt.Println(&quot;当前协程数:&quot;, runtime.NumGoroutine())
        time.Sleep(200 * time.Millisecond)
    }
}
func main() {
    DispatchNumControl = make(chan bool, MaxDispatchNumControl)
    JobQueue = make(chan Job)
    WorkerList = make([]*Worker, 10)
    disp := NewDispatcher(MaxWorker)
    disp.Run()
    time.Sleep(1 * time.Second)
    AddQueue(100)
    fmt.Println()
    time.Sleep(1000 * time.Second)
}
</code></pre><h3 id="gin教程">gin教程</h3>
<p>引用来自：<a href="https://github.com/gin-gonic/gin/blob/master/README.md">https://github.com/gin-gonic/gin/blob/master/README.md</a></p>
<h3 id="泛型编程">泛型编程</h3>
<p>Go 1.17版本开始支持泛型，再也不需要使用反射来实现了</p>
<h4 id="初体验">初体验</h4>
<p>使用[T any]来声明一个泛型，一个通用函数可实现打印不同类型的变量</p>
<pre tabindex="0"><code>package main

import &quot;fmt&quot;

func print[T any](arr []T) {
    for _, v := range arr {
        fmt.Println(v)
    }
}

func main() {
    str := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}
    flat := []float64{1.1, 1.2, 1.3}
    nums := []int{1, 2, 3}
    print(str)
    print(flat)
    print(nums)
}
</code></pre><p>运行需要加上<code>-gcflags=-G=3</code>编译参数(golang 1.18版本会成为默认)</p>
<pre tabindex="0"><code>go run -gcflags=-G=3 ./main.go
</code></pre><p>一个泛型实现的通用查询函数，使用[T comparable]的格式，comparable是一个接口类型，要求我们的类型需要支持<code>==</code>的操作</p>
<pre tabindex="0"><code>package main

import &quot;fmt&quot;

func find[T comparable](arr []T, target T) {
    for k, v := range arr {
        if v == target {
            fmt.Printf(&quot;found %v at %d\n&quot;, target, k)
        }
    }
}

func main() {
    find([]int{1,2,3}, 2)
    find([]string{&quot;a&quot;,&quot;bcd&quot;,&quot;efg&quot;}, &quot;a&quot;)
}
</code></pre><p>这个find函数依赖于数组，对于其它数据结构，比如链表、栈等需要重写</p>
<h4 id="泛型栈">泛型栈</h4>
<pre tabindex="0"><code>package main

import &quot;fmt&quot;

type stack [T any] []T

func(s *stack[T]) push(elem T) {
    *s = append(*s, elem)
}

func(s *stack[T]) pop() {
    if len(*s) &gt; 0 {
        *s = (*s)[:len(*s)-1]
    }
}

//判断栈是否为空
func(s *stack[T]) top() *T{
    if len(*s) &gt; 0 {
        return &amp;(*s)[len(*s)-1]
    }
    return nil
}

func(s *stack[T]) len() int{
    return len(*s)
}

func(s *stack[T]) print() {
    for _, elem := range *s {
        fmt.Println(elem)
    }
}

func main() {
    ss := stack[string]{}
    ss.push(&quot;a&quot;)
    ss.push(&quot;b&quot;)
    ss.push(&quot;c&quot;)
    ss.print()
    fmt.Printf(&quot;stack top is - %v\n&quot;, *ss.top())
    ss.pop()
    ss.pop()
    ss.print()
}
</code></pre><p>为什么函数名都是小写？当前Go泛型函数不支持被其它包引用</p>
<h4 id="泛型双向链表">泛型双向链表</h4>
<pre tabindex="0"><code>package main

import (
    &quot;fmt&quot;
)

type node[T comparable] struct {
    data T
    prev *node[T]
    next *node[T]
}

type list[T comparable] struct {
    head, tail *node[T]
    len int
}

func(l *list[T]) isEmpty() bool {
    return l.head == nil &amp;&amp; l.tail == nil
}

//从头插入
func(l *list[T]) add(data T) {
    n := &amp;node[T]{
        data: data,
        prev: nil,
        next: l.head,
    }

    if l.isEmpty() {
        l.head = n
        l.tail = n
    }
    l.head.prev = n
    l.head = n
}

//从尾插入
func (l *list[T]) push(data T) {
    n := &amp;node[T] {
        data : data,
        prev : l.tail,
        next : nil,
    }
    if l.isEmpty() {
        l.head = n
        l.tail = n
    }
    l.tail.next = n
    l.tail = n
}

//删除一个节点，注意边界处理
func (l *list[T]) del(data T) {
    for p := l.head; p != nil; p = p.next {
        if data == p.data {
            if p == l.head {
                l.head = p.next
            }
            if p == l.tail {
                l.tail = p.prev
            }
            if p.prev != nil {
                p.prev.next = p.next
            }
            if p.next != nil {
                p.next.prev = p.prev
            }
            return
        }
    }
}

func (l *list[T]) print() {
    if l.isEmpty() {
        fmt.Println(&quot;linklist is empty.&quot;)
        return
    }
    for p := l.head; p != nil; p = p.next {
        fmt.Printf(&quot;[%v]--&gt;&quot;, p.data)
    }
    fmt.Println(&quot;end&quot;)
}

func main() {
    l := list[int]{}
    l.add(1)
    l.add(2)
    l.push(3)
    l.push(4)
    l.add(5)
    l.print()
    l.del(1)
    l.del(3)
    l.print()
}
</code></pre><h4 id="泛型map">泛型Map</h4>
<pre tabindex="0"><code>package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
)

func fMap[T1 any, T2 any](arr []T1, f func(T1) T2) []T2 {
    s := make([]T2, len(arr))
    for k,v := range arr {
        s[k] = f(v)
    }
    return s
}

func main() {

    strs := []string{&quot;I&quot;, &quot;am&quot;, &quot;yao&quot;}
    upstrs := fMap(strs, func(s string) string  {
        return strings.ToUpper(s)
    })
    fmt.Println(upstrs)
}
</code></pre><ul>
<li>T1: 需要处理的数据类型</li>
<li>T2: 处理后的数据类型</li>
<li>f func(T1) T2)：T1经过的函数然后转变为T2</li>
</ul>
<h4 id="泛型reduce">泛型Reduce</h4>
<p>数组求和</p>
<pre tabindex="0"><code>package main

import (
    &quot;fmt&quot;
)

func fReduce[T1 any, T2 any](arr []T1, init T2, f func(T1, T2) T2) T2 {
    s := init
    for _, v := range arr {
        s = f(v, s)
    }
    return s
}

func main() {
    nums := []int{0,1,2,3,4}
    sum := fReduce(nums, 0, func(result, elem int) int  {
        return result + elem
    })
    fmt.Printf(&quot;Sum = %d \n&quot;, sum)
}
</code></pre><h4 id="泛型filter">泛型Filter</h4>
<pre tabindex="0"><code>package main

import (
    &quot;fmt&quot;
)

func fFilter[T any](arr []T, in bool, f func(T) bool) []T {
    s := []T{}
    for _, v := range arr {
        target := f(v)
        if (in &amp;&amp; target) || (!in &amp;&amp; !target) {
            s = append(s, v)
        }
    }
    return s
}

func fFilterTrue[T any](arr []T, f func(T) bool) []T {
    return fFilter(arr, true, f)
}

func fFilterFalse[T any](arr []T, f func(T) bool) []T {
    return fFilter(arr, false, f)
}

func main() {
    nums := []int{0,1,2,3,4,5}
    result := fFilterTrue(nums, func (elem int) bool {
        return elem % 2 == 1
    })
    fmt.Println(result)

    result = fFilterFalse(nums, func (elem int) bool {
        return elem % 2 == 1
    })
    fmt.Println(result)
}
</code></pre><h3 id="优雅关闭goroutine">优雅关闭Goroutine</h3>
<h4 id="返回ctx的signalhandler">返回ctx的SignalHandler</h4>
<pre tabindex="0"><code>var onlyOneSignalHandler = make(chan struct{})

// SetupSignalHandler registers for SIGTERM and SIGINT. A stop channel is returned
// which is closed on one of these signals. If a second signal is caught, the program
// is terminated with exit code 1.
func SetupSignalHandler() context.Context {
    close(onlyOneSignalHandler) // panics when called twice

    ctx, cancel := context.WithCancel(context.Background())

    c := make(chan os.Signal, 2)
    signal.Notify(c, shutdownSignals...)
    go func() {
        &lt;-c
        cancel()
        &lt;-c
        os.Exit(1) // second signal. Exit directly.
    }()

    return ctx
}
</code></pre><h3 id="检测结构体是否有这个方法">检测结构体是否有这个方法</h3>
<p>不使用reflect检测结构体是否有这个方法</p>
<pre tabindex="0"><code>package main

import &quot;fmt&quot;

type A int
type B int
func (b B) M(x int) string {
    return fmt.Sprint(b, &quot;: &quot;, x)
}

func check(v interface{}) bool {
    _, has := v.(interface{M(int) string})
    return has
}

func main() {
    var a A = 123
    var b B = 789
    fmt.Println(check(a)) // false
    fmt.Println(check(b)) // true
}
</code></pre><h3 id="jsondecoder-vs-jsonunmarshal">json.Decoder vs json.Unmarshal</h3>
<ul>
<li>Use json.Decoder if your data is coming from an io.Reader stream, or you need to decode multiple values from a stream of data.</li>
<li>Use json.Unmarshal if you already have the JSON data in memory.</li>
</ul>
<p>如果是从http请求的流中读取，使用<code>json.Decoder</code>; 如果json数据已在内存中，使用<code>json.Unmarshal</code></p>
<h3 id="interface判断为nil">interface判断为nil</h3>
<pre tabindex="0"><code>package main

import &quot;fmt&quot;

func main(){
    var a interface{} = nil
    var b interface{} = (*string)(nil)
    fmt.Println(a==nil)
    fmt.Println(b==nil)
}
</code></pre><p>输出为</p>
<pre tabindex="0"><code>true
false
</code></pre><p>为什么会出现这样的结果呢？跟interface的底层结构有关，一个接口包括动态类型和动态值。通过<code>x!=nil</code>只是判断了动态类型，并没有判断动态值；
显式指明nil，动态类型和动态值都为nil，所以输出true；使用强制类型指明(*string)nil，动态类型不为nil，动态值为nil，所以输出为false.</p>
<p>interface底层实现：分为两种struct来表示，<code>iface</code>和<code>eface</code></p>
<p>eface表示不含method的interface结构(empty interface)</p>
<pre tabindex="0"><code>type eface struct {
    _type *_type
    data  unsafe.Pointer
}

type _type struct {
    size       uintptr // type size
    ptrdata    uintptr // size of memory prefix holding all pointers
    hash       uint32  // hash of type; avoids computation in hash tables
    tflag      tflag   // extra type information flags
    align      uint8   // alignment of variable with this type
    fieldalign uint8   // alignment of struct field with this type
    kind       uint8   // enumeration for C
    alg        *typeAlg  // algorithm table
    gcdata    *byte    // garbage collection data
    str       nameOff  // string form
    ptrToThis typeOff  // type for pointer to this type, may be zero
}
</code></pre><p>iface表示non-empty interface的底层实现, non-empty要包含method</p>
<pre tabindex="0"><code>type iface struct {
    tab  *itab
    data unsafe.Pointer
}

// layout of Itab known to compilers
// allocated in non-garbage-collected memory
// Needs to be in sync with
// ../cmd/compile/internal/gc/reflect.go:/^func.dumptypestructs.
type itab struct {
    inter  *interfacetype
    _type  *_type
    link   *itab
    bad    int32
    inhash int32      // has this itab been added to hash?
    fun    [1]uintptr // variable sized
}
</code></pre><p>可以借助反射来判断</p>
<pre tabindex="0"><code>func IsNil(i interface{}) bool {
    vi := reflect.ValueOf(i)
    if vi.Kind() == reflect.Ptr {
        return vi.IsNil()
    }
    return false
}
</code></pre><h3 id="自动转化时间格式">自动转化时间格式</h3>
<pre tabindex="0"><code>func (b *T) MarshalJSON() ([]byte, error) {
    type tmp T
    return json.Marshal(&amp;struct {
        *tmp
        CreatedAt  string `json:&quot;created_at&quot;`
        UpdatedAt  string `json:&quot;updated_at&quot;`
        ExpireTime string `json:&quot;expire_time&quot;`
    }{
        tmp:        (*tmp)(b),
        CreatedAt:  b.CreatedAt.Local().Format(DefaultTimeFormat),
        UpdatedAt:  b.UpdatedAt.Local().Format(DefaultTimeFormat),
        ExpireTime: b.ExpireTime.Local().Format(DefaultTimeFormat),
    })
}

func (b *T) UnmarshalJSON(data []byte) error {
    type tmp T
    origin := &amp;struct {
        *tmp
        CreatedAt  string `json:&quot;created_at&quot;`
        UpdatedAt  string `json:&quot;updated_at&quot;`
        ExpireTime string `json:&quot;expire_time&quot;`
    }{
        tmp: (*tmp)(b),
    }
    if err := json.Unmarshal(data, origin); err != nil {
        return err
    }
    createdAt, err := time.Parse(DefaultTimeFormat, origin.CreatedAt)
    if err != nil {
        return err
    }
    b.CreatedAt = createdAt

    updatedAt, err := time.Parse(DefaultTimeFormat, origin.UpdatedAt)
    if err != nil {
        return err
    }
    b.UpdatedAt = updatedAt
    expireTime, err := time.Parse(DefaultTimeFormat, origin.ExpireTime)
    if err != nil {
        return err
    }
    b.ExpireTime = expireTime
    return nil
}
</code></pre><h3 id="如何计算结构体占用的空间">如何计算结构体占用的空间</h3>
<pre tabindex="0"><code>package main

import (
    &quot;fmt&quot;
    &quot;unsafe&quot;
)

type test1 struct {
    num1 int
    num2 int
}

type test2 struct {
    num1 int16
    num2 int32
}

func main() {
    fmt.Println(unsafe.Sizeof(test1{}))
    fmt.Println(unsafe.Sizeof(test2{}))
}
</code></pre><p>运行结果:</p>
<pre tabindex="0"><code>16
8
</code></pre><p>test1结构体int类型在64位机器上占8字节，test1结构占16字节；test2结构体int16占2字节，int32占4字节，总共6字节。为什么不是8字节？
这是因为内存对齐的缘故，CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问。比如32位的CPU ，字长为4字节。
这么设计的目的，是减少 CPU 访问内存的次数，加大CPU访问内存的吞吐量。合理的内存对齐可以提高内存读写的性能，并且便于实现变量操作的原子性。</p>
<p>unsafe库提供<code>Alignof</code>方法查看一个类型的对齐值(对齐系数、对齐倍数)，golang官方文档有针对这个的说明，总结：</p>
<ul>
<li>对于任意类型的变量 x ，unsafe.Alignof(x) 至少为 1。</li>
<li>对于 struct 结构体类型的变量 x，计算x每一个字段f的unsafe.Alignof(x.f)，unsafe.Alignof(x)等于其中的最大值。但至少为1</li>
<li>对于 array 数组类型的变量 x，unsafe.Alignof(x) 等于构成数组的元素类型的对齐倍数。
没有任何字段的空 struct{} 和没有任何元素的 array 占据的内存空间大小为 0，不同的大小为 0 的变量可能指向同一块地址。</li>
</ul>
<h4 id="struct内存对齐技巧">struct内存对齐技巧</h4>
<p>合理放置变量位置减少内存占用</p>
<pre tabindex="0"><code>package main

import (
    &quot;fmt&quot;
    &quot;unsafe&quot;
)

//假设字长为4字节
type test1 struct {
    a int8  //a和下面的b加起来为3字节，补齐1个字节凑齐一个字长
    b int16
    c int32 //c刚好一个字长
}

type test2 struct {
    a int8  //a和下面的b加起来超过一个字长的字节，所以a单独补齐3个字节
    c int32 //c刚好一个字长
    b int16 //b补齐2个字节，凑齐一个字长
}

func main() {
    fmt.Println(unsafe.Sizeof(test1{})) // 8
    fmt.Println(unsafe.Sizeof(test2{})) // 12
}
</code></pre><p>运行结果为8和12</p>
<h4 id="空struct的对齐">空struct{}的对齐</h4>
<p>struct{}作为其它struct最后一个字段时，需要填充额外的内存保证安全</p>
<pre tabindex="0"><code>package main

import (
    &quot;fmt&quot;
    &quot;unsafe&quot;
)

type test1 struct {
    c int32
    a struct{}
}

type test2 struct {
    a struct{}
    c int32
}

func main() {
    fmt.Println(unsafe.Sizeof(test1{})) // 8
    fmt.Println(unsafe.Sizeof(test2{})) // 4
}
</code></pre><p>运行结果为8和4，test1的struct{}额外占用一个字长</p>
<h3 id="syncpool临时对象池">sync.Pool临时对象池</h3>
<p>为什么需要sync.Pool？保存和复用临时对象，减少内存分配，降低GC压力。</p>
<pre tabindex="0"><code>import (
    &quot;sync&quot;
    &quot;testing&quot;
)

type A struct {
    Name string
}

func (a *A) Reset() {
    a.Name = &quot;&quot;
}

var pool = sync.Pool{
    New: func() interface{} {
        return new(A)
    },
}

func BenchmarkWithoutPool(b *testing.B) {
    var a *A
    b.ReportAllocs()
    b.ResetTimer()
    for i := 0; i &lt; b.N; i++ {
        for j := 0; j &lt; 10000; j++ {
            a = new(A)
            a.Name = &quot;tink&quot;
        }
    }
}

func BenchmarkWithPool(b *testing.B) {
    var a *A
    b.ReportAllocs()
    b.ResetTimer()
    for i := 0; i &lt; b.N; i++ {
        for j := 0; j &lt; 10000; j++ {
            a = pool.Get().(*A)
            a.Reset()
            a.Name = &quot;tink&quot;
            pool.Put(a)
        }
    }
}
</code></pre><pre tabindex="0"><code># go test -benchmem -run=^$ -bench .
goos: darwin
goarch: amd64
pkg: test/syncpool
cpu: Intel(R) Core(TM) i7-4770HQ CPU @ 2.20GHz
BenchmarkWithoutPool-8              3955            307508 ns/op          160000 B/op      10000 allocs/op
BenchmarkWithPool-8                 7032            148487 ns/op               0 B/op          0 allocs/op
PASS 
ok      test/syncpool   3.491s
</code></pre><p>运行耗时节省了一半以上，内存分配为0，内存分配次数也为0</p>
<h3 id="注册模式">注册模式</h3>
<p>slice方式注册，来自<code>github.com/bitpoke/mysql-operator</code>代码片段</p>
<p>多controller运行例子：</p>
<pre tabindex="0"><code>    // Setup all Controllers
    if err := controller.AddToManager(mgr); err != nil {
        log.Error(err, &quot;unable to setup controllers&quot;)
        os.Exit(1)
    }
</code></pre><p>定义一个AddToManagerFuncs变量存放函数组，AddToManager遍历AddToManagerFuncs，并执行其函数</p>
<pre tabindex="0"><code>// AddToManagerFuncs is a list of functions to add all Controllers to the Manager
var AddToManagerFuncs []func(manager.Manager) error

// AddToManager adds all Controllers to the Manager
func AddToManager(m manager.Manager) error {
    for _, f := range AddToManagerFuncs {
        if err := f(m); err != nil {
            return err
        }
    }
    return nil
}
</code></pre><p>同级目录下不同的controller的init函数有注册AddToManagerFuncs的实现</p>
<pre tabindex="0"><code>//add_mysqlcontroller.go
func init() {
    // AddToManagerFuncs is a list of functions to create controllers and add them to a manager.
    AddToManagerFuncs = append(AddToManagerFuncs, mysqlcluster.Add)
}

//add_nodecontroller.go
func init() {
    // AddToManagerFuncs is a list of functions to create controllers and add them to a manager.
    AddToManagerFuncs = append(AddToManagerFuncs, node.Add)
}
</code></pre><p>Note: 看到有大量项目使用下划线声明变量，mysql-operator项目中也存在
<code>var _ reconcile.Reconciler = &amp;ReconcileMysqlCluster{}</code>，这是一种接口断言，否则编译报错</p>
<h3 id="二级缓存常见实现">二级缓存常见实现</h3>
<p>引用左耳朵耗子的：<a href="https://coolshell.cn/articles/17416.html">缓存更新的套路</a></p>
<h4 id="cache-aside模式">Cache Aside模式</h4>
<ul>
<li>失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li>
<li>命中：应用程序从cache中取数据，取到后返回。</li>
<li>更新：先把数据存到数据库中，成功后，再让缓存失效。</li>
</ul>
<h4 id="read-through模式">Read Through模式</h4>
<p>查询操作中更新缓存</p>
<h4 id="write-through模式">Write Through模式</h4>
<p>更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。
如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库</p>
<h4 id="write-back模式">Write Back模式</h4>
<p>在更新数据的时候，只更新缓存，不更新数据库，缓存会异步地批量更新数据库</p>
<h3 id="for-range的坑">for range的坑</h3>
<pre tabindex="0"><code>func main() {
    arr1 := []int{1, 2, 3}
	arr2 := make([]*int, len(arr1))

	for i, v := range arr1 {
		arr2[i] = &amp;v
	}

	for _, v := range arr2 {
		fmt.Println(*v)
	}
}
</code></pre><p>输出结果</p>
<pre tabindex="0"><code>3
3
3
</code></pre><p>原因是v变量在for range中只会被初始化一次，后面都是复用这个临时变量，v的指针地址始终是同一个地址；建议可以用slice下标避免这个问题</p>
<h3 id="参考链接">参考链接</h3>
<ul>
<li><a href="https://www.dailybtc.cn/golang%e4%b8%ad%e7%9a%84defer%e5%bf%85%e6%8e%8c%e6%8f%a1%e7%9a%847%e7%9f%a5%e8%af%86%e7%82%b9golang%e4%b8%ad%e7%9a%84defer%e5%bf%85%e6%8e%8c%e6%8f%a1%e7%9a%847%e7%9f%a5%e8%af%86%e7%82%b9/">golang中的defer必掌握的7知识点golang中的defer必掌握的7知识点</a></li>
<li><a href="https://blog.betacat.io/post/golang-atomic-value-exploration/">Go 语言标准库中 atomic.Value 的前世今生</a></li>
<li><a href="https://juejin.im/post/6844904056918376456">浅谈协程和Go语言的Goroutine</a></li>
<li><a href="https://liudanking.com/performance/golang-%E8%8E%B7%E5%8F%96-goroutine-id-%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/">https://liudanking.com/performance/golang-%E8%8E%B7%E5%8F%96-goroutine-id-%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/</a></li>
<li><a href="https://chai2010.cn/advanced-go-programming-book/ch3-asm/ch3-08-goroutine-id.html">https://chai2010.cn/advanced-go-programming-book/ch3-asm/ch3-08-goroutine-id.html</a></li>
<li><a href="https://coolshell.cn/articles/21615.html">GO编程模式: 泛型编程</a></li>
<li><a href="https://go101.org/article/tips.html">Go Tips 101</a></li>
<li><a href="https://golang.org/ref/spec#Size_and_alignment_guarantees"> Size and alignment guarantees - golang spec 的unsafe.Alignof</a></li>
<li><a href="https://geektutu.com/post/hpg-struct-alignment.html">Go 语言高性能编程</a></li>
</ul>


                
                
<div class="entry-shang text-center">
    
	    <p>「真诚赞赏，手留余香」</p>
	
	<button class="zs show-zs btn btn-bred">赞赏支持</button>
</div>
<div class="zs-modal-bg"></div>
<div class="zs-modal-box">
	<div class="zs-modal-head">
		<button type="button" class="close">×</button>
		<span class="author"><a href="https://www.iceyao.com.cn"><img src="/img/favicon.png" />爱折腾的工程师</a></span>
        
	        <p class="tip"><i></i><span>真诚赞赏，手留余香</span></p>
		
 
	</div>
	<div class="zs-modal-body">
		<div class="zs-modal-btns">
			<button class="btn btn-blink" data-num="2">2元</button>
			<button class="btn btn-blink" data-num="5">5元</button>
			<button class="btn btn-blink" data-num="10">10元</button>
			<button class="btn btn-blink" data-num="50">50元</button>
			<button class="btn btn-blink" data-num="100">100元</button>
			<button class="btn btn-blink" data-num="1">任意金额</button>
		</div>
		<div class="zs-modal-pay">
			<button class="btn btn-bred" id="pay-text">2元</button>
			<p>使用<span id="pay-type">微信</span>扫描二维码完成支付</p>
			<img src="/img/reward/wechat-2.png"  id="pay-image"/>
		</div>
	</div>
	<div class="zs-modal-footer">
		<label><input type="radio" name="zs-type" value="wechat" class="zs-type" checked="checked"><span ><span class="zs-wechat"><img src="/img/reward/wechat-btn.png"/></span></label>
		<label><input type="radio" name="zs-type" value="alipay" class="zs-type" class="zs-alipay"><img src="/img/reward/alipay-btn.png"/></span></label>
	</div>
</div>
<script type="text/javascript" src="/js/reward.js"></script>

                

                
                <hr>
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/post/2020-08-06-ebpf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-toggle="tooltip" data-placement="top" title="eBPF学习笔记">&larr;
                            Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/post/2020-08-12-k8s-network-develop-flannel_readnote/" data-toggle="tooltip" data-placement="top" title="flannel源码阅读笔记">Next
                            Post &rarr;</a>
                    </li>
                    
                </ul>
                

                


<script src="https://giscus.app/client.js"
        data-repo="yaoice/yaoice.github.io"
        data-repo-id="R_kgDOJnxqVg"
        data-category="General"
        data-category-id="DIC_kwDOJnxqVs4CWwUs"
        data-mapping="pathname"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-theme="light"
        data-lang="en"
        crossorigin="anonymous"
        async>
</script>


            </div>

            
            
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
            

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                        
                        
                        
                        
                        
                        <a href="/tags/devops" title="devops">
                            devops
                        </a>
                        
                        
                        
                        <a href="/tags/go" title="go">
                            go
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/k8s" title="k8s">
                            k8s
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/openstack" title="openstack">
                            openstack
                        </a>
                        
                        
                        
                        <a href="/tags/tkestack" title="tkestack">
                            tkestack
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/%E7%BB%83%E8%BD%A6" title="练车">
                            练车
                        </a>
                        
                        
                    </div>
                </section>
                

                
                
            </div>
        </div>
    </div>
</article>




<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">                  
                    
                    <li>
                        <a href="mailto:yao3690093@gmail.com">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		           
                    
                    
                    
                    

		            
                    
                    <li>
                        <a target="_blank" href="/img/wechat.jpeg">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-weixin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		            
                    
                    <li>
                        <a target="_blank" href="https://github.com/yaoice">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		            
                    
                    
                    
                    
                    
                    
                    
                    
                    
            
            
            
           
                   <li>
                       <a href='' rel="alternate" type="application/rss+xml" title="爱折腾的工程师" >
                           <span class="fa-stack fa-lg">
                               <i class="fas fa-circle fa-stack-2x"></i>
                               <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                           </span>
                       </a>
                   </li>
            
             </ul>
		<p class="copyright text-muted">
                    Copyright &copy; 爱折腾的工程师 2023
                </p>
            </div>
        </div>
    </div>
</footer>




<script>
    function loadAsync(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>






<script>
    
    if($('#tag_cloud').length !== 0){
        loadAsync("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>


<script>
    loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>



<script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https'){
       bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else{
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>


<script>
    
    var _baId = '92c175994ded75a3cd2074bc1123e2be';

    
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>




<script type="text/javascript">
    function generateCatalog(selector) {

        
        
        
        
            _containerSelector = 'div.post-container'
        

        
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        
        $(selector).html('')

        
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    
    $(".catalog-toggle").click((function (e) {
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    


    loadAsync("\/js\/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>






</body>
</html>
