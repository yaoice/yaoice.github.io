<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <meta property="og:site_name" content="爱折腾的工程师">
    <meta property="og:type" content="article">

    
    <meta property="og:image" content="https://www.iceyao.com.cn//img/post-bg-unix-linux.jpg">
    <meta property="twitter:image" content="https://www.iceyao.com.cn//img/post-bg-unix-linux.jpg" />
    

    
    <meta name="title" content="TKEStack galaxy源码阅读笔记" />
    <meta property="og:title" content="TKEStack galaxy源码阅读笔记" />
    <meta property="twitter:title" content="TKEStack galaxy源码阅读笔记" />
    

    
    <meta name="description" content="iceyao，程序员, 开源爱好者，生活探险家 | 这里是iceyao的博客，与你一起发现更大的世界。">
    <meta property="og:description" content="iceyao，程序员, 开源爱好者，生活探险家 | 这里是iceyao的博客，与你一起发现更大的世界。" />
    <meta property="twitter:description" content="iceyao，程序员, 开源爱好者，生活探险家 | 这里是iceyao的博客，与你一起发现更大的世界。" />
    

    
    <meta property="twitter:card" content="summary" />
    
    

    <meta name="keyword"  content="iceyao, IceYao&#39;s Blog, 博客, 个人网站, 互联网, Web, 云原生, PaaS, Istio, Kubernetes, 微服务, Microservice">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>TKEStack galaxy源码阅读笔记 | 爱折腾的工程师 | IceYao&#39;s Blog</title>

    <link rel="canonical" href="/post/2020-07-03-galaxy_source_code_readnote/">

    
    
    
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    
    <link rel="stylesheet" href="/css/hugo-theme-cleanwhite.min.css">

    
    <link rel="stylesheet" href="/css/zanshang.css">

    
    <link rel="stylesheet" href="/css/font-awesome.all.min.css">

    
    

    
    <script src="/js/jquery.min.js"></script>

    
    <script src="/js/bootstrap.min.js"></script>

    
    <script src="/js/hux-blog.min.js"></script>

    
    <script src="/js/lazysizes.min.js"></script>

    
    

</head>



  
    
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-9J7CKFVPPM"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-9J7CKFVPPM');
        }
      </script>
    
  







<nav class="navbar navbar-default navbar-custom navbar-fixed-top">

    <div class="container-fluid">
        
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">爱折腾的工程师</a>
        </div>

        
        
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">All Posts</a>
                    </li>
                    
                        
                    
                    
		    
                        <li><a href="/archive//">ARCHIVE</a></li>
                    
                        <li><a href="/notes//">NOTES</a></li>
                    
                        <li><a href="/about//">ABOUT</a></li>
                    
		            <li>
                        <a href="/search"><i class="fa fa-search"></i></a>
		           </li>
                </ul>
            </div>
        </div>
        
    </div>
    
</nav>
<script>
    
    
    
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        
            $navbar.className = " ";
            
            setTimeout(function(){
                
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>




<style type="text/css">
    header.intro-header {
        background-image: url('/img/post-bg-unix-linux.jpg')
    }
</style>

<header class="intro-header" >

    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/tkestack" title="tkestack">
                            tkestack
                        </a>
                        
                    </div>
                    <h1>TKEStack galaxy源码阅读笔记</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        
                            Posted by 
                            
                                    爱折腾的工程师
                             
                            on 
                            Friday, July 3, 2020
                            
                            
                            
                            
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>




<article>
    <div class="container">
        <div class="row">

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                
                <h3 id="简介">简介</h3>
<p>Galaxy是一个Kubernetes网络项目，旨在为Pod提供overlay和高性能底层网络。并且它还实现了浮动IP（或弹性IP），
即Pod的IP即使由于节点崩溃而飘到另一个节点上也不会改变，这对于运行有状态集合应用程序非常有利。</p>
<h3 id="galaxy组件">galaxy组件</h3>
<p>它由三个组件组成-Galaxy，CNI插件和Galaxy IPAM。</p>
<ul>
<li>Galaxy：在每个kubelet节点上运行的守护进程，该进程调用不同种类的CNI插件来设置Pod所需的网络。</li>
<li>Galaxy IPAM：是Kubernetes Scheduler插件(Scheduler Extender方式扩展)，可以用作浮动IP配置和IP分配管理器。</li>
<li>CNI插件</li>
</ul>
<p>galaxy更像是后端可以接多种cni插件的适配器</p>
<h3 id="安装配置">安装配置</h3>
<p>克隆galaxy项目</p>
<pre tabindex="0"><code># git clone https://github.com/tkestack/galaxy.git
git checkout v1.0.4
</code></pre><h4 id="galaxy-cni配置">galaxy cni配置</h4>
<pre tabindex="0"><code>---
apiVersion: v1
kind: ConfigMap
metadata:
  name: cni-etc
  namespace: kube-system
data:
  00-galaxy.conf: |
    {
      &#34;type&#34;: &#34;galaxy-sdn&#34;,
      &#34;capabilities&#34;: {&#34;portMappings&#34;: true},
      &#34;cniVersion&#34;: &#34;0.2.0&#34;
    }
</code></pre><p>galaxy的cni配置文件，调用的是galaxy-sdn的二进制文件，实际上它通过unix socket连接到galaxy server；透传了cni请求的参数</p>
<h4 id="galaxy-server配置">galaxy server配置</h4>
<pre tabindex="0"><code>---
apiVersion: v1
kind: ConfigMap
metadata:
  name: galaxy-etc
  namespace: kube-system
data:
  galaxy.json: |
    {
      &#34;NetworkConf&#34;:[
        {&#34;name&#34;:&#34;tke-route-eni&#34;,&#34;type&#34;:&#34;tke-route-eni&#34;,&#34;eni&#34;:&#34;eth1&#34;,&#34;routeTable&#34;:1},
        {&#34;name&#34;:&#34;galaxy-flannel&#34;,&#34;type&#34;:&#34;galaxy-flannel&#34;, &#34;delegate&#34;:{&#34;type&#34;:&#34;galaxy-veth&#34;},&#34;subnetFile&#34;:&#34;/run/flannel/subnet.env&#34;},
        {&#34;name&#34;:&#34;galaxy-k8s-vlan&#34;,&#34;type&#34;:&#34;galaxy-k8s-vlan&#34;, &#34;device&#34;:&#34;{{ .DeviceName }}&#34;, &#34;default_bridge_name&#34;: &#34;br0&#34;},
        {&#34;name&#34;:&#34;galaxy-k8s-sriov&#34;,&#34;type&#34;: &#34;galaxy-k8s-sriov&#34;, &#34;device&#34;: &#34;{{ .DeviceName }}&#34;, &#34;vf_num&#34;: 10}
      ],
      &#34;DefaultNetworks&#34;: [&#34;galaxy-flannel&#34;]
    }
</code></pre><p>galaxy的配置文件，默认使用的cni插件是flannel(重命名为galaxy-flannel而已)；galaxy-flannel cni配置的delegate参数为galaxy-veth插件</p>
<h4 id="galaxy-daemonset">galaxy daemonset</h4>
<pre tabindex="0"><code>---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  labels:
    app: galaxy
  name: galaxy-daemonset
  namespace: kube-system
spec:
  selector:
    matchLabels:
      app: galaxy
  template:
    metadata:
      labels:
        app: galaxy
    spec:
      serviceAccountName: galaxy
      hostNetwork: true
      hostPID: true
      containers:
      - image: tkestack/galaxy:v1.0.6
        command: [&#34;/bin/sh&#34;]
      # qcloud galaxy should run with --route-eni
        args: [&#34;-c&#34;, &#34;cp -p /etc/galaxy/cni/00-galaxy.conf /etc/cni/net.d/; cp -p /opt/cni/galaxy/bin/galaxy-sdn /opt/cni/galaxy/bin/loopback /opt/cni/bin/; /usr/bin/galaxy --logtostderr=true --v=3 --network-policy&#34;]
      # private-cloud should run without --route-eni
      # args: [&#34;-c&#34;, &#34;cp -p /etc/galaxy/cni/00-galaxy.conf /etc/cni/net.d/; cp -p /opt/cni/galaxy/bin/galaxy-sdn /opt/cni/galaxy/bin/loopback /opt/cni/bin/; /usr/bin/galaxy --logtostderr=true --v=3&#34;]
        imagePullPolicy: IfNotPresent
        env:
          - name: MY_NODE_NAME
            valueFrom:
              fieldRef:
                fieldPath: spec.nodeName
          - name: DOCKER_HOST
            value: unix:///host/run/docker.sock
        name: galaxy
        resources:
          requests:
            cpu: 100m
            memory: 200Mi
        securityContext:
          privileged: true
        volumeMounts:
        - name: galaxy-run
          mountPath: /var/run/galaxy/
        - name: flannel-run
          mountPath: /run/flannel
        - name: galaxy-log
          mountPath: /data/galaxy/logs
        - name: galaxy-etc
          mountPath: /etc/galaxy
        - name: cni-config
          mountPath: /etc/cni/net.d/
        - name: cni-bin
          mountPath: /opt/cni/bin
        - name: cni-etc
          mountPath: /etc/galaxy/cni
        - name: cni-state
          mountPath: /var/lib/cni
        - name: docker-sock
          mountPath: /host/run/
      terminationGracePeriodSeconds: 30
      tolerations:
      - effect: NoSchedule
        operator: Exists
      volumes:
      - name: galaxy-run
        hostPath:
          path: /var/run/galaxy
      - name: flannel-run
        hostPath:
          path: /run/flannel
      - name: galaxy-log
        emptyDir: {}
      - configMap:
          defaultMode: 420
          name: galaxy-etc
        name: galaxy-etc
      - name: cni-config
        hostPath:
          path: /etc/cni/net.d/
      - name: cni-bin
        hostPath:
          path: /opt/cni/bin
      - name: cni-state
        hostPath:
          path: /var/lib/cni
      - configMap:
          defaultMode: 420
          name: cni-etc
        name: cni-etc
      - name: docker-sock
        # in case of docker restart, /run/docker.sock may change, we have to mount the /run directory
        hostPath:
          path: /run/
</code></pre><h4 id="flannel-yaml配置">flannel yaml配置</h4>
<pre tabindex="0"><code># kubectl apply -f flannel-v0.10.0.yaml
---
apiVersion: v1
data:
  cni-conf.json: |
    {
      &#34;name&#34;: &#34;cbr0&#34;,
      &#34;plugins&#34;: [
        {
          &#34;type&#34;: &#34;flannel&#34;,
          &#34;delegate&#34;: {
            &#34;hairpinMode&#34;: true,
            &#34;isDefaultGateway&#34;: true
          }
        },
        {
          &#34;type&#34;: &#34;portmap&#34;,
          &#34;capabilities&#34;: {
            &#34;portMappings&#34;: true
          }
        }
      ]
    }
  net-conf.json: |
    {
      &#34;Network&#34;: &#34;172.28.0.0/16&#34;,
      &#34;Backend&#34;: {
        &#34;Type&#34;: &#34;vxlan&#34;
      }
    }
kind: ConfigMap
metadata:
  labels:
    app: flannel
    tier: node
  name: kube-flannel-cfg
  namespace: kube-system
---
apiVersion: extensions/v1beta1
kind: DaemonSet
metadata:
  labels:
    k8s-app: flannel
  name: flannel
  namespace: kube-system
spec:
  selector:
    matchLabels:
      k8s-app: flannel
  template:
    metadata:
      labels:
        k8s-app: flannel
    spec:
      containers:
      - args:
        - --ip-masq
        - --kube-subnet-mgr
        command:
        - /opt/bin/flanneld
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              apiVersion: v1
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              apiVersion: v1
              fieldPath: metadata.namespace
        image: quay.io/coreos/flannel:v0.10.0-amd64
        imagePullPolicy: IfNotPresent
        name: kube-flannel
        resources:
          limits:
            cpu: 100m
            memory: 256Mi
          requests:
            cpu: 100m
            memory: 50Mi
        securityContext:
          privileged: true
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: File
        volumeMounts:
        - mountPath: /run
          name: run
        - mountPath: /etc/kube-flannel/
          name: flannel-cfg
      dnsPolicy: ClusterFirst
      hostNetwork: true
      nodeSelector:
        beta.kubernetes.io/arch: amd64
      restartPolicy: Always
      schedulerName: default-scheduler
      securityContext: {}
      serviceAccount: flannel
      serviceAccountName: flannel
      terminationGracePeriodSeconds: 30
      tolerations:
      - effect: NoSchedule
        operator: Exists
      volumes:
      - hostPath:
          path: /run
          type: &#34;&#34;
        name: run
      - hostPath:
          path: /etc/cni/net.d
          type: &#34;&#34;
        name: cni
      - configMap:
          defaultMode: 420
          name: kube-flannel-cfg
        name: flannel-cfg
  templateGeneration: 1
  updateStrategy:
    rollingUpdate:
      maxUnavailable: 1
    type: RollingUpdate
</code></pre><p>还是需要安装flannel daemonset，flannel建立节点间的vxlan隧道或host-gw静态路由</p>
<h3 id="源码分析">源码分析</h3>
<h4 id="代码结构">代码结构</h4>
<pre tabindex="0"><code>tkestack.io iceyao$ tree -L 3 galaxy/
galaxy/
├── CONTRIBUTING.md
├── LICENSE
├── Makefile    galaxy的Makefile文件
├── README.md
├── Vagrantfile
├── artifacts   floatingip和pool的crd yaml文件
│   └── examples
│       ├── crd.yaml
│       ├── example-floatip.yaml
│       └── example-pool.yaml
├── build
│   ├── docker
│   │   ├── galaxy       galaxy Dockerfile
│   │   └── galaxy-ipam  galaxy-ipam Dockerfile
│   └── lib              Makefile引用的库
│       ├── build.sh     编译辅助脚本
│       ├── common.mk    Makefile公共变量
│       ├── create-manifest.sh  创建docker manifest文件，用于构建多cpu架构镜像
│       ├── golang.mk    golang编译相关
│       ├── image.mk     docker镜像编译相关
│       └── install-buildx.sh  安装buildx的脚本
├── cmd
│   ├── galaxy           galaxy启动程序入口
│   │   └── galaxy.go
│   └── galaxy-ipam      galaxy-ipam启动程序入口
│       └── galaxy-ipam.go
├── cni                  具体cni插件实现
│   ├── ipam
│   │   └── ipam.go
│   ├── k8s-sriov
│   │   ├── k8s_sriov.go
│   │   └── sriov.conf
│   ├── k8s-vlan
│   │   ├── k8s_vlan.go
│   │   └── myvlan.conf
│   ├── sdn
│   │   ├── sdn.conf
│   │   └── sdn.go
│   ├── tke-route-eni
│   │   ├── cni.go
│   │   ├── driver.go
│   │   └── tke-route-eni.conf
│   ├── underlay
│   │   └── veth
│   └── veth
│       └── veth.go
├── doc    文档
│   ├── building.md
│   ├── contributing.md
│   ├── float-ip.md
│   ├── galaxy-config.md
│   ├── galaxy-ipam-config.md
│   ├── getting-started.md
│   ├── image
│   │   ├── galaxy-ipam-scheduling-process.png
│   │   ├── galaxy-ipam.png
│   │   ├── galaxy.png
│   │   ├── policy-egress-rule.png
│   │   ├── policy-ingress-rule.png
│   │   └── policy-ipset.png
│   ├── network-policy.md
│   ├── supported-cnis.md
│   └── swagger.json
├── e2e             e2e测试用例
│   ├── README.md
│   ├── cni-request
│   │   ├── cni_request_suite_test.go
│   │   └── request_test.go
│   ├── e2e.go
│   ├── helper
│   │   ├── cni.go
│   │   ├── topology.go
│   │   ├── util.go
│   │   └── util_test.go
│   ├── k8s-vlan
│   │   ├── bridge_test.go
│   │   ├── k8s_vlan_suite_test.go
│   │   └── vlan_test.go
│   ├── underlay
│   │   └── veth
│   └── veth
│       ├── veth_suite_test.go
│       └── veth_test.go
├── go.mod
├── go.sum
├── hack                   辅助工具脚本
│   ├── build-native.sh
│   ├── build-tools.sh
│   ├── generate_proto.sh
│   ├── test.sh
│   ├── update-codegen.sh
│   ├── updatevendor.sh
│   └── verify-codegen.sh
├── pkg
│   ├── api
│   │   ├── cniutil   cni工具库，构建/解析CNIArgs，Delegate cmdAdd/cmdDel请求
│   │   ├── docker    docker client对象，与docker交互
│   │   ├── galaxy    galaxy自定义cni请求结构体，自定义pod请求结构体
│   │   └── k8s       hostPort映射关系
│   ├── galaxy        galaxy对象，命令行参数，galaxy server启动, 透传cni请求
│   │   ├── galaxy.go
│   │   ├── options
│   │   └── server.go
│   ├── gc
│   │   ├── flannel_gc.go      flannel垃圾回收器
│   │   ├── flannel_gc_test.go
│   │   └── gc.go
│   ├── ipam
│   │   ├── api
│   │   ├── apis
│   │   ├── client
│   │   ├── cloudprovider
│   │   ├── crd              floatingip/pool Crd定义
│   │   ├── floatingip
│   │   ├── schedulerplugin  调度插件类型定义
│   │   ├── server          Server结构体，命令行启动参数
│   │   └── utils
│   ├── network
│   │   ├── kernel          内核相关参数
│   │   ├── netlink.go
│   │   ├── netlink_test.go
│   │   ├── netns
│   │   ├── portmapping     端口映射，包含iptables规则处理，端口监听操作
│   │   └── vlan
│   ├── policy              networkPolicy实现，同步ipset/iptables规则
│   │   ├── event.go
│   │   ├── policy.go
│   │   └── policy_test.go
│   ├── signal
│   │   └── signal.go
│   ├── tke
│   │   └── eni             弹性网卡模式(公有云场景)
│   └── utils               封装的工具操作库
│       ├── httputil
│       ├── ips
│       ├── ipset
│       ├── iptables         封装了iptables的操作工具库，来自k8s
│       ├── ldflags
│       ├── netlink.go
│       ├── netlink_test.go
│       ├── nets
│       ├── page
│       ├── utils.go
│       └── utils_test.go
├── tools
│   ├── netlink_monitor
│   │   └── monitor.go
│   ├── network
│   │   └── setupvlan.go
│   └── route_monitor
│       ├── Dockerfile
│       ├── daemonset.yaml
│       └── route_monitor.go
├── vagrant.sh
└── yaml                    k8s部署yaml
    ├── galaxy-ipam.yaml
    ├── galaxy.yaml
    └── scheduler-policy.yaml

70 directories, 88 files
</code></pre><h4 id="galaxy-server">galaxy server</h4>
<pre tabindex="0"><code>cmd/galaxy/galaxy.go

func main() {
    // initialize rand seed
    rand.Seed(time.Now().UTC().UnixNano())
    // 初始化galaxy对象
    galaxy := galaxy.NewGalaxy()
    // add command line args
    // 接收命令行参数
    galaxy.AddFlags(pflag.CommandLine)
    flag.InitFlags()
    //日志初始化，默认每隔5秒钟flush下pending的log I/O
    logs.InitLogs()
    defer logs.FlushLogs()

    // if checking version, print it and exit
    ldflags.PrintAndExitIfRequested()
    if err := galaxy.Start(); err != nil {
        glog.Fatalf(&#34;Error start galaxy: %v&#34;, err)
    }
    // handle signals
    signal.BlockSignalHandler(func() {
        if err := galaxy.Stop(); err != nil {
            glog.Errorf(&#34;Error stop galaxy: %v&#34;, err)
        }
    })
}
</code></pre><ol>
<li>设置随机数种子</li>
<li>初始化galaxy对象</li>
<li>初始化galaxy命令行参数</li>
<li>是否打印版本信息</li>
<li>启动galaxy程序</li>
<li>监听退出信号，终止galaxy程序</li>
</ol>
<p>Galaxy结构体</p>
<pre tabindex="0"><code>type Galaxy struct {
    JsonConf
    *options.ServerRunOptions
    quitChan  chan struct{}
    dockerCli *docker.DockerInterface
    netConf   map[string]map[string]interface{}
    pmhandler *portmapping.PortMappingHandler
    client    kubernetes.Interface
    pm        *policy.PolicyManager
}

type JsonConf struct {
    NetworkConf     []map[string]interface{} // all detailed network configurations
    DefaultNetworks []string                 // pod&#39;s default networks if it doesn&#39;t have networks annotation
    // If not empty, set pod&#39;s default network to `ENIIPNetwork` regardless of `DefaultNetworks` if pod wants eni ip
    // and has no networks annotation
    ENIIPNetwork string
}
</code></pre><p>进入Start函数</p>
<pre tabindex="0"><code>func (g *Galaxy) Start() error {
    // 加载galaxy.json配置，初始化dockerCli、netConf、pmhandler变量
    if err := g.Init(); err != nil {
        return err
    }
    // 初始化client变量，并设置k8s clientSet的QPS为1000.0, Burst为2000
    g.initk8sClient()
    // 启动Flannel垃圾回收器
    // 1. 回收IP, 在/var/lib/cni/networks/目录下
    // 2. 回收gc目录下的文件
    //    /var/lib/cni/galaxy/$containerid：记录使用的network type，类似galaxy-flannel或galaxy-sriov等
    //    /var/lib/cni/flannel/$containerid：记录使用的flannel cni plugin chain，类似{&#34;ipMasq&#34;:false,&#34;ipam&#34;:{&#34;routes&#34;:[{&#34;dst&#34;:&#34;172.28.0.0/16&#34;}],&#34;subnet&#34;:&#34;172.28.0.0/24&#34;,&#34;type&#34;:&#34;host-local&#34;},&#34;mtu&#34;:1450,&#34;name&#34;:&#34;&#34;,&#34;type&#34;:&#34;galaxy-veth&#34;}
    //    /var/lib/cni/galaxy/port/$containerid：记录hostPort与pod containerPort的映射关系
    // 3. 回收veth设备
    gc.NewFlannelGC(g.dockerCli, g.quitChan, g.cleanIPtables).Run()
    // 是否开启bridge-nf-call-iptables参数
    kernel.BridgeNFCallIptables(g.quitChan, g.BridgeNFCallIptables)
    // 是否开启ip_forward
    kernel.IPForward(g.quitChan, g.IPForward)
    // 监听hostPort宿主机端口，设置hostPort iptables
    if err := g.setupIPtables(); err != nil {
        return err
    }
    // 根据NetworkPolicy，同步ipset/iptables规则
    if g.NetworkPolicy {
        g.pm = policy.New(g.client, g.quitChan)
        go wait.Until(g.pm.Run, 3*time.Minute, g.quitChan)
    }
    // 弹性网卡模式
    if g.RouteENI {
        // TODO do all sysctl things via a config
        // 禁用rp_filter参数
        kernel.DisableRPFilter(g.quitChan)
        eni.SetupENIs(g.quitChan)
    }
    // 启动galaxy server，监听在unix套接字上
    return g.StartServer()
}
</code></pre><p>进入StartServer()</p>
<pre tabindex="0"><code>// StartServer will start galaxy server.
func (g *Galaxy) StartServer() error {
    // 是否开启pprof
    if g.PProf {
        go func() {
            http.ListenAndServe(&#34;127.0.0.1:0&#34;, nil)
        }()
    }
    // 设置路由
    g.installHandlers()
    if err := os.MkdirAll(private.GalaxySocketDir, 0755); err != nil {
        return fmt.Errorf(&#34;failed to create %s: %v&#34;, private.GalaxySocketDir, err)
    }
    if err := os.Remove(private.GalaxySocketPath); err != nil {
        if !os.IsNotExist(err) {
            return fmt.Errorf(&#34;failed to remove %s: %v&#34;, private.GalaxySocketPath, err)
        }
    }
    l, err := net.Listen(&#34;unix&#34;, private.GalaxySocketPath)
    if err != nil {
        return fmt.Errorf(&#34;failed to listen on pod info socket: %v&#34;, err)
    }
    if err := os.Chmod(private.GalaxySocketPath, 0600); err != nil {
        _ = l.Close()
        return fmt.Errorf(&#34;failed to set pod info socket mode: %v&#34;, err)
    }

    glog.Fatal(http.Serve(l, nil))
    return nil
}
</code></pre><p>g.installHandlers()设置路由</p>
<pre tabindex="0"><code>// 使用github.com/emicklei/go-restful web框架
func (g *Galaxy) installHandlers() {
    ws := new(restful.WebService)
    // GET/POST /cni的路径
    ws.Route(ws.GET(&#34;/cni&#34;).To(g.cni))
    ws.Route(ws.POST(&#34;/cni&#34;).To(g.cni))
    restful.Add(ws)
}

func (g *Galaxy) cni(r *restful.Request, w *restful.Response) {
    // 获取请求的body内容
    data, err := ioutil.ReadAll(r.Request.Body)
    if err != nil {
        glog.Warningf(&#34;bad request %v&#34;, err)
        http.Error(w, fmt.Sprintf(&#34;err read body %v&#34;, err), http.StatusBadRequest)
        return
    }
    defer r.Request.Body.Close() // nolint: errcheck
    // 把cni请求转化为pod请求
    req, err := galaxyapi.CniRequestToPodRequest(data)
    if err != nil {
        glog.Warningf(&#34;bad request %v&#34;, err)
        http.Error(w, fmt.Sprintf(&#34;%v&#34;, err), http.StatusBadRequest)
        return
    }
    // 字符串右边做去除冒号处理
    req.Path = strings.TrimRight(fmt.Sprintf(&#34;%s:%s&#34;, req.Path, strings.Join(g.CNIPaths, &#34;:&#34;)), &#34;:&#34;)
    // 调用requestFunc
    result, err := g.requestFunc(req)
    if err != nil {
        http.Error(w, fmt.Sprintf(&#34;%v&#34;, err), http.StatusInternalServerError)
    } else {
        // Empty response JSON means success with no body
        w.Header().Set(&#34;Content-Type&#34;, &#34;application/json&#34;)
        if _, err := w.Write(result); err != nil {
            glog.Warningf(&#34;Error writing %s HTTP response: %v&#34;, req.Command, err)
        }
    }
}
</code></pre><p>CNIRequest、PodRequest结构体</p>
<pre tabindex="0"><code>// Request sent to the Galaxy by the Galaxy SDN CNI plugin
type CNIRequest struct {
    // CNI environment variables, like CNI_COMMAND and CNI_NETNS
    Env map[string]string `json:&#34;env,omitempty&#34;`
    // CNI configuration passed via stdin to the CNI plugin
    Config []byte `json:&#34;config,omitempty&#34;`
}

// Request structure built from CNIRequest which is passed to the
// handler function given to the CNIServer at creation time
type PodRequest struct {
    // The CNI command of the operation
    Command string
    // kubernetes namespace name
    PodNamespace string
    // kubernetes pod name
    PodName string
    // kubernetes pod ports
    Ports []k8s.Port
    // Channel for returning the operation result to the CNIServer
    Result chan *PodResult
    // Args
    *skel.CmdArgs
    // specific CNI plugin args, key: cni type, inner key: args name, value: args value
    ExtendedCNIArgs map[string]map[string]json.RawMessage
}

// Result of a PodRequest sent through the PodRequest&#39;s Result channel.
type PodResult struct {
    // Response to be returned to the OpenShift SDN CNI plugin on success
    Response []byte
    // Error to be returned to the OpenShift SDN CNI plugin on failure
    Err error
}
</code></pre><p>galaxyapi.CniRequestToPodRequest(data)，把cni请求转化为pod请求</p>
<pre tabindex="0"><code>func CniRequestToPodRequest(data []byte) (*PodRequest, error) {
    var cr CNIRequest
    // 解析CNIRequest
    if err := json.Unmarshal(data, &amp;cr); err != nil {
        return nil, fmt.Errorf(&#34;JSON unmarshal error: %v&#34;, err)
    }
    // 判断是否有CNI_COMMAND变量
    cmd, ok := cr.Env[cniutil.CNI_COMMAND]
    if !ok {
        return nil, fmt.Errorf(&#34;Unexpected or missing %s&#34;, cniutil.CNI_COMMAND)
    }
    // 初始化PodRequest对象
    req := &amp;PodRequest{
        Command: cmd,
        Result:  make(chan *PodResult),
        CmdArgs: &amp;skel.CmdArgs{
            StdinData: cr.Config,
        },
    }
    // 获取CNI请求其它环境变量
    req.ContainerID, ok = cr.Env[cniutil.CNI_CONTAINERID]
    if !ok {
        return nil, fmt.Errorf(&#34;missing %s&#34;, cniutil.CNI_CONTAINERID)
    }
    req.Netns, ok = cr.Env[cniutil.CNI_NETNS]
    if !ok {
        return nil, fmt.Errorf(&#34;missing %s&#34;, cniutil.CNI_NETNS)
    }
    req.IfName, ok = cr.Env[cniutil.CNI_IFNAME]
    if !ok {
        return nil, fmt.Errorf(&#34;missing %s&#34;, cniutil.CNI_IFNAME)
    }
    req.Path, ok = cr.Env[cniutil.CNI_PATH]
    if !ok {
        return nil, fmt.Errorf(&#34;missing %s&#34;, cniutil.CNI_PATH)
    }
    req.Args, ok = cr.Env[cniutil.CNI_ARGS]
    if !ok {
        return nil, fmt.Errorf(&#34;missing %s&#34;, cniutil.CNI_ARGS)
    }
    // 解析CNIArgs环境变量；格式key1=val1;key2=val2
    cniArgs, err := cniutil.ParseCNIArgs(req.Args)
    if err != nil {
        return nil, err
    }
    // 获取K8S_POD_NAMESPACE变量
    req.PodNamespace, ok = cniArgs[k8s.K8S_POD_NAMESPACE]
    if !ok {
        return nil, fmt.Errorf(&#34;missing %s&#34;, k8s.K8S_POD_NAMESPACE)
    }
    // 获取K8S_POD_NAME变量
    req.PodName, ok = cniArgs[k8s.K8S_POD_NAME]
    if !ok {
        return nil, fmt.Errorf(&#34;missing %s&#34;, k8s.K8S_POD_NAME)
    }
    glog.V(4).Infof(&#34;req.Args %s req.StdinData %s&#34;, req.Args, cr.Config)

    return req, nil
}
</code></pre><p>调用g.requestFunc(req)</p>
<pre tabindex="0"><code>// #lizard forgives
func (g *Galaxy) requestFunc(req *galaxyapi.PodRequest) (data []byte, err error) {
    // 打印开始时间
    start := time.Now()
    glog.Infof(&#34;%v, %s+&#34;, req, start.Format(time.StampMicro))
    // ADD操作
    if req.Command == cniutil.COMMAND_ADD {
        // 打印结束时间
        defer func() {
            glog.Infof(&#34;%v, data %s, err %v, %s-&#34;, req, string(data), err, start.Format(time.StampMicro))
        }()
        var pod *corev1.Pod
        // 通过clientSet获取pod对象
        pod, err = g.getPod(req.PodName, req.PodNamespace)
        if err != nil {
            return
        }
        // 调用cmdAdd
        result, err1 := g.cmdAdd(req, pod)
        if err1 != nil {
            err = err1
            return
        } else {
            // 结果转换为0.2.0版本的结果，也校验下IP合法性
            result020, err2 := convertResult(result)
            if err2 != nil {
                err = err2
            } else {
                data, err = json.Marshal(result)
                if err != nil {
                    return
                }
                // 设置hostPort端口转发, 保存端口映射信息至/var/lib/cni/galaxy/port/$ContainerID
                err = g.setupPortMapping(req, req.ContainerID, result020, pod)
                if err != nil {
                    // 设置失败的话，就清除hostPort端口转发
                    g.cleanupPortMapping(req)
                    return
                }
                // pod IP回写到Status
                pod.Status.PodIP = result020.IP4.IP.IP.String()
                // 如果启用NetworkPolicy，同步下iptables/ipset规则
                if g.pm != nil {
                    if err := g.pm.SyncPodChains(pod); err != nil {
                        glog.Warning(err)
                    }
                    g.pm.SyncPodIPInIPSet(pod, true)
                }
            }
        }
      // DEL操作
    } else if req.Command == cniutil.COMMAND_DEL {
        // 打印结束时间
        defer glog.Infof(&#34;%v err %v, %s-&#34;, req, err, start.Format(time.StampMicro))
        err = cniutil.CmdDel(req.CmdArgs, -1)
        if err == nil {
            // 清除hostPort端口转发
            err = g.cleanupPortMapping(req)
        }
    } else {
        err = fmt.Errorf(&#34;unknown command %s&#34;, req.Command)
    }
    return
}
</code></pre><p>ADD操作最终调用g.cmdAdd(req, pod)</p>
<pre tabindex="0"><code>func (g *Galaxy) cmdAdd(req *galaxyapi.PodRequest, pod *corev1.Pod) (types.Result, error) {
    // 解析网络类型参数
    networkInfos, err := g.resolveNetworks(req, pod)
    if err != nil {
        return nil, err
    }
    // 调用CmdAdd
    return cniutil.CmdAdd(req.CmdArgs, networkInfos)
}

// CmdAdd saves networkInfos to disk and executes each cni binary to setup network
func CmdAdd(cmdArgs *skel.CmdArgs, networkInfos []*NetworkInfo) (types.Result, error) {
    if len(networkInfos) == 0 {
        return nil, fmt.Errorf(&#34;No network info returned&#34;)
    }
    // 把网络类型信息写入/var/lib/cni/galaxy/$ContainerID
    if err := saveNetworkInfo(cmdArgs.ContainerID, networkInfos); err != nil {
        return nil, fmt.Errorf(&#34;Error save network info %v for %s: %v&#34;, networkInfos, cmdArgs.ContainerID, err)
    }
    var (
        err    error
        result types.Result
    )
    for idx, networkInfo := range networkInfos {
        //append additional args from network info
        cmdArgs.Args = strings.TrimRight(fmt.Sprintf(&#34;%s;%s&#34;, cmdArgs.Args, BuildCNIArgs(networkInfo.Args)), &#34;;&#34;)
        // 保存上一个结果
        if result != nil {
            networkInfo.Conf[&#34;prevResult&#34;] = result
        }
        // 调用DelegateAdd
        result, err = DelegateAdd(networkInfo.Conf, cmdArgs, networkInfo.IfName)
        if err != nil {
            //fail to add cni, then delete all established CNIs recursively
            glog.Errorf(&#34;fail to add network %s: %v, begin to rollback and delete it&#34;, networkInfo.Args, err)
            // 调用失败的话，直接调用CmdDel
            delErr := CmdDel(cmdArgs, idx)
            glog.Warningf(&#34;fail to delete cni in rollback %v&#34;, delErr)
            return nil, fmt.Errorf(&#34;fail to establish network %s:%v&#34;, networkInfo.Args, err)
        }
    }
    if err != nil {
        return nil, err
    }
    return result, nil
}

// DelegateAdd calles delegate cni binary to execute cmdAdd
func DelegateAdd(netconf map[string]interface{}, args *skel.CmdArgs, ifName string) (types.Result, error) {
    netconfBytes, err := json.Marshal(netconf)
    if err != nil {
        return nil, fmt.Errorf(&#34;error serializing delegate netconf: %v&#34;, err)
    }
    // 在cni插件的目录下寻找对应的cni插件路径
    pluginPath, err := invoke.FindInPath(netconf[&#34;type&#34;].(string), strings.Split(args.Path, &#34;:&#34;))
    if err != nil {
        return nil, err
    }
    //
    glog.Infof(&#34;delegate add %s args %s conf %s&#34;, args.ContainerID, args.Args, string(netconfBytes))
    // 调用cni标准库完成ADD操作
    return invoke.ExecPluginWithResult(pluginPath, netconfBytes, &amp;invoke.Args{
        Command:       &#34;ADD&#34;,
        ContainerID:   args.ContainerID,
        NetNS:         args.Netns,
        PluginArgsStr: args.Args,
        IfName:        ifName,
        Path:          args.Path,
    })
}
</code></pre><p>DEL操作最终调用CmdDel</p>
<pre tabindex="0"><code>// CmdDel restores networkInfos from disk and executes each cni binary to delete network
func CmdDel(cmdArgs *skel.CmdArgs, lastIdx int) error {
    // 读取/var/lib/cni/galaxy/$ContainerID，获取对应的网络类型
    networkInfos, err := consumeNetworkInfo(cmdArgs.ContainerID)
    if err != nil {
        if os.IsNotExist(err) {
            // Duplicated cmdDel invoked by kubelet
            return nil
        }
        return fmt.Errorf(&#34;Error consume network info %v for %s: %v&#34;, networkInfos, cmdArgs.ContainerID, err)
    }
    if lastIdx == -1 {
        lastIdx = len(networkInfos) - 1
    }
    // 维护一个error slice
    var errorSet []string
    var fails []*NetworkInfo
    for idx := lastIdx; idx &gt;= 0; idx-- {
        networkInfo := networkInfos[idx]
        //append additional args from network info
        cmdArgs.Args = strings.TrimRight(fmt.Sprintf(&#34;%s;%s&#34;, cmdArgs.Args, BuildCNIArgs(networkInfo.Args)), &#34;;&#34;)
        err := DelegateDel(networkInfo.Conf, cmdArgs, networkInfo.IfName)
        if err != nil {
            errorSet = append(errorSet, err.Error())
            fails = append(fails, networkInfo)
            glog.Errorf(&#34;failed to delete network %v: %v&#34;, networkInfo.Args, err)
        }
    }
    if len(errorSet) &gt; 0 {
        reverse(fails)
        // 把网络类型信息写入/var/lib/cni/galaxy/$ContainerID
        if err := saveNetworkInfo(cmdArgs.ContainerID, fails); err != nil {
            glog.Warningf(&#34;Error save network info %v for %s: %v&#34;, fails, cmdArgs.ContainerID, err)
        }
        return fmt.Errorf(strings.Join(errorSet, &#34; / &#34;))
    }
    return nil
}

// DelegateDel calles delegate cni binary to execute cmdDEL
func DelegateDel(netconf map[string]interface{}, args *skel.CmdArgs, ifName string) error {
    netconfBytes, err := json.Marshal(netconf)
    if err != nil {
        return fmt.Errorf(&#34;error serializing delegate netconf: %v&#34;, err)
    }
    // 在cni插件的目录下寻找对应的cni插件路径
    pluginPath, err := invoke.FindInPath(netconf[&#34;type&#34;].(string), strings.Split(args.Path, &#34;:&#34;))
    if err != nil {
        return err
    }
    glog.Infof(&#34;delegate del %s args %s conf %s&#34;, args.ContainerID, args.Args, string(netconfBytes))
    // 调用cni标准库完成DEL操作
    return invoke.ExecPluginWithoutResult(pluginPath, netconfBytes, &amp;invoke.Args{
        Command:       &#34;DEL&#34;,
        ContainerID:   args.ContainerID,
        NetNS:         args.Netns,
        PluginArgsStr: args.Args,
        IfName:        ifName,
        Path:          args.Path,
    })
}
</code></pre><h4 id="galaxy-sdn">galaxy sdn</h4>
<pre tabindex="0"><code>package main

import (
    &#34;bytes&#34;
    &#34;encoding/json&#34;
    &#34;fmt&#34;
    &#34;io/ioutil&#34;
    &#34;net&#34;
    &#34;net/http&#34;
    &#34;os&#34;
    &#34;strings&#34;

    &#34;github.com/containernetworking/cni/pkg/skel&#34;
    t020 &#34;github.com/containernetworking/cni/pkg/types/020&#34;
    &#34;github.com/containernetworking/cni/pkg/version&#34;
    galaxyapi &#34;tkestack.io/galaxy/pkg/api/galaxy&#34;
    &#34;tkestack.io/galaxy/pkg/api/galaxy/private&#34;
)

// cniPlugin结构体定义
type cniPlugin struct {
    socketPath string
}

// 初始化函数
func NewCNIPlugin(socketPath string) *cniPlugin {
    return &amp;cniPlugin{socketPath: socketPath}
}

// Create and fill a CNIRequest with this plugin&#39;s environment and stdin which
// contain the CNI variables and configuration
// 构建CNIRequest对象
func newCNIRequest(args *skel.CmdArgs) *galaxyapi.CNIRequest {
    envMap := make(map[string]string)
    for _, item := range os.Environ() {
        idx := strings.Index(item, &#34;=&#34;)
        if idx &gt; 0 {
            envMap[strings.TrimSpace(item[:idx])] = item[idx+1:]
        }
    }
    // envMap存储系统的环境变量
    return &amp;galaxyapi.CNIRequest{
        Env:    envMap,
        Config: args.StdinData,
    }
}

// Send a CNI request to the CNI server via JSON + HTTP over a root-owned unix socket,
// and return the result
func (p *cniPlugin) doCNI(url string, req *galaxyapi.CNIRequest) ([]byte, error) {
    data, err := json.Marshal(req)
    if err != nil {
        return nil, fmt.Errorf(&#34;failed to marshal CNI request %v: %v&#34;, req, err)
    }
    // 初始化http Client对象，地址为unix套接字/var/run/galaxy/galaxy.sock
    client := &amp;http.Client{
        Transport: &amp;http.Transport{
            Dial: func(proto, addr string) (net.Conn, error) {
                return net.Dial(&#34;unix&#34;, p.socketPath)
            },
        },
    }
    // http请求
    resp, err := client.Post(url, &#34;application/json&#34;, bytes.NewReader(data))
    if err != nil {
        return nil, fmt.Errorf(&#34;failed to send CNI request: %v&#34;, err)
    }
    defer resp.Body.Close() // nolint: errcheck

    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        return nil, fmt.Errorf(&#34;failed to read CNI result: %v&#34;, err)
    }

    if resp.StatusCode != 200 {
        return nil, fmt.Errorf(&#34;galaxy returns: %s&#34;, string(body))
    }

    return body, nil
}

// Send the ADD command environment and config to the CNI server, returning
// the IPAM result to the caller
func (p *cniPlugin) CmdAdd(args *skel.CmdArgs) (*t020.Result, error) {
    body, err := p.doCNI(&#34;http://dummy/cni&#34;, newCNIRequest(args))
    if err != nil {
        return nil, err
    }
    // body解析为0.2.0版本的result
    result := &amp;t020.Result{}
    if err := json.Unmarshal(body, result); err != nil {
        return nil, fmt.Errorf(&#34;failed to unmarshal response &#39;%s&#39;: %v&#34;, string(body), err)
    }

    return result, nil
}

// Send the ADD command environment and config to the CNI server, printing
// the IPAM result to stdout when called as a CNI plugin
func (p *cniPlugin) skelCmdAdd(args *skel.CmdArgs) error {
    result, err := p.CmdAdd(args)
    if err != nil {
        return err
    }
    // 标准输出打印
    return result.Print()
}

// Send the DEL command environment and config to the CNI server
// 删除操作
func (p *cniPlugin) CmdDel(args *skel.CmdArgs) error {
    _, err := p.doCNI(&#34;http://dummy/cni&#34;, newCNIRequest(args))
    return err
}

// 主函数
func main() {
    p := NewCNIPlugin(private.GalaxySocketPath)
    skel.PluginMain(p.skelCmdAdd, p.CmdDel, version.Legacy)
}
</code></pre><h4 id="galaxy-ipam">galaxy ipam</h4>
<pre tabindex="0"><code>func main() {
    // initialize rand seed
    rand.Seed(time.Now().UTC().UnixNano())

    s := server.NewServer()
    // add command line args
    s.AddFlags(pflag.CommandLine)

    flag.InitFlags()
    //日志初始化，默认每隔5秒钟flush下pending的log I/O
    logs.InitLogs()
    defer logs.FlushLogs()

    // if checking version, print it and exit
    ldflags.PrintAndExitIfRequested()

    if err := s.Start(); err != nil {
        fmt.Fprintf(os.Stderr, &#34;%v\n&#34;, err) // nolint: errcheck
        os.Exit(1)
    }
    //TODO handle signal ?
}
</code></pre><ol>
<li>设置随机数种子</li>
<li>初始化server对象</li>
<li>初始化server命令行参数</li>
<li>是否打印版本信息</li>
<li>启动server程序</li>
<li>监听退出信号，终止server程序(TODO?)</li>
</ol>
<p>Server结构体</p>
<pre tabindex="0"><code>type JsonConf struct {
    SchedulePluginConf schedulerplugin.Conf `json:&#34;schedule_plugin&#34;`
}

type Server struct {
        //调度相关配置
    JsonConf
    //API server启动参数
    *options.ServerRunOptions
    client               kubernetes.Interface
    crdClient            versioned.Interface
    tappClient           tappVersioned.Interface
    extensionClient      extensionClient.Interface
    plugin               *schedulerplugin.FloatingIPPlugin
    informerFactory      informers.SharedInformerFactory
    crdInformerFactory   crdInformer.SharedInformerFactory
    tappInformerFactory  tappInformers.SharedInformerFactory
    stopChan             chan struct{}
    leaderElectionConfig *leaderelection.LeaderElectionConfig
}
</code></pre><p>s.Start()函数</p>
<pre tabindex="0"><code>func (s *Server) Start() error {
    // 初始化Server变量
    if err := s.init(); err != nil {
        return fmt.Errorf(&#34;init server: %v&#34;, err)
    }

    if s.LeaderElection.LeaderElect &amp;&amp; s.leaderElectionConfig != nil {
        leaderelection.RunOrDie(context.Background(), *s.leaderElectionConfig)
        return nil
    }
    return s.Run()
}
</code></pre><p>Server的init函数</p>
<pre tabindex="0"><code>func (s *Server) init() error {
    if options.JsonConfigPath == &#34;&#34; {
        return fmt.Errorf(&#34;json config is required&#34;)
    }
    // 解析JsonConf
    data, err := ioutil.ReadFile(options.JsonConfigPath)
    if err != nil {
        return fmt.Errorf(&#34;read json config: %v&#34;, err)
    }
    if err := json.Unmarshal(data, &amp;s.JsonConf); err != nil {
        return fmt.Errorf(&#34;bad config %s: %v&#34;, string(data), err)
    }
    // 初始化k8s client、ipam crd client、extensionClient、tappClient、leaderElectionConfig参数
    s.initk8sClient()
    // 初始化informerFactory
    s.informerFactory = informers.NewFilteredSharedInformerFactory(s.client, time.Minute, v1.NamespaceAll, nil)
    // 初始化podInformer、statefulsetInformer、deploymentInformer
    podInformer := s.informerFactory.Core().V1().Pods()
    statefulsetInformer := s.informerFactory.Apps().V1().StatefulSets()
    deploymentInformer := s.informerFactory.Apps().V1().Deployments()
    // 初始化crdInformerFactory，crd资源用crd的informer来创建
    s.crdInformerFactory = crdInformer.NewSharedInformerFactory(s.crdClient, 0)
    // 初始化poolInformer、fipInformer
    poolInformer := s.crdInformerFactory.Galaxy().V1alpha1().Pools()
    fipInformer := s.crdInformerFactory.Galaxy().V1alpha1().FloatingIPs()
    // 初始化PluginFactoryArgs对象
    pluginArgs := &amp;schedulerplugin.PluginFactoryArgs{
        PodLister:         podInformer.Lister(),
        StatefulSetLister: statefulsetInformer.Lister(),
        DeploymentLister:  deploymentInformer.Lister(),
        Client:            s.client,
        TAppClient:        s.tappClient,
        PodHasSynced:      podInformer.Informer().HasSynced,
        StatefulSetSynced: statefulsetInformer.Informer().HasSynced,
        DeploymentSynced:  deploymentInformer.Informer().HasSynced,
        PoolLister:        poolInformer.Lister(),
        PoolSynced:        poolInformer.Informer().HasSynced,
        CrdClient:         s.crdClient,
        ExtClient:         s.extensionClient,
        FIPInformer:       fipInformer,
    }
    if s.tappClient != nil {
        s.tappInformerFactory = tappInformers.NewSharedInformerFactory(s.tappClient, time.Minute)
        tappInformer := s.tappInformerFactory.Tappcontroller().V1().TApps()
        pluginArgs.TAppLister = tappInformer.Lister()
        pluginArgs.TAppHasSynced = tappInformer.Informer().HasSynced
    }
    // 初始化FloatingIPPlugin对象
    s.plugin, err = schedulerplugin.NewFloatingIPPlugin(s.SchedulePluginConf, pluginArgs)
    if err != nil {
        return err
    }
    // podInformer设置EventHandler
    // AddEventHandler函数的参数类型是一个叫ResourceEventHandler的interface
    podInformer.Informer().AddEventHandler(eventhandler.NewPodEventHandler(s.plugin))
    return nil
}
</code></pre><p>初始化FloatingIPPlugin对象的函数</p>
<pre tabindex="0"><code>// Conf结构体
type Conf struct {
    FloatingIPs           []*floatingip.FloatingIPPool `json:&#34;floatingips,omitempty&#34;`
    ResyncInterval        uint                         `json:&#34;resyncInterval&#34;`
    ConfigMapName         string                       `json:&#34;configMapName&#34;`
    ConfigMapNamespace    string                       `json:&#34;configMapNamespace&#34;`
    FloatingIPKey         string                       `json:&#34;floatingipKey&#34;`       // configmap floatingip data key
    SecondFloatingIPKey   string                       `json:&#34;secondFloatingipKey&#34;` // configmap second floatingip data key
    CloudProviderGRPCAddr string                       `json:&#34;cloudProviderGrpcAddr&#34;`
}

// NewFloatingIPPlugin creates FloatingIPPlugin
func NewFloatingIPPlugin(conf Conf, args *PluginFactoryArgs) (*FloatingIPPlugin, error) {
    // conf对象变量的校验
    conf.validate()
    glog.Infof(&#34;floating ip config: %v&#34;, conf)
    plugin := &amp;FloatingIPPlugin{
        nodeSubnet:        make(map[string]*net.IPNet),
        PluginFactoryArgs: args,
        conf:              &amp;conf,
        unreleased:        make(chan *releaseEvent, 1000),
        dpLockPool:        keymutex.NewHashed(500000),
        podLockPool:       keymutex.NewHashed(500000),
    }
    // 初始化crdIpam对象，设置FIPInformer的EventHandler
    plugin.ipam = floatingip.NewCrdIPAM(args.CrdClient, floatingip.InternalIp, plugin.FIPInformer)
    // we can&#39;t add two event handler for the same informer.
    // The later registed event handler will replace the former one, So pass nil informer to secondIPAM
    // TODO remove secondIPAM and let ipam do allocating all ips
    // 外部IP不设置FIPInformer的EventHandler
    plugin.secondIPAM = floatingip.NewCrdIPAM(args.CrdClient, floatingip.ExternalIp, nil)
    plugin.hasSecondIPConf.Store(false)
    // 初始化cloudProvider(客户端)，连接到第三方公有云的grpc server
    if conf.CloudProviderGRPCAddr != &#34;&#34; {
        plugin.cloudProvider = cloudprovider.NewGRPCCloudProvider(conf.CloudProviderGRPCAddr)
    }
    return plugin, nil
}
</code></pre><p>为podInformer设置Event的AddEventHandler, 实际上是实现的ResourceEventHandler接口的对象</p>
<pre tabindex="0"><code>// ResourceEventHandler接口
type ResourceEventHandler interface {
    OnAdd(obj interface{})
    OnUpdate(oldObj, newObj interface{})
    OnDelete(obj interface{})
}

// PodEventHandler实现了ResourceEventHandler接口
func NewPodEventHandler(watcher PodWatcher) *PodEventHandler {
    return &amp;PodEventHandler{watcher: watcher}
}

// NewPodEventHandler的参数类型PodWatcher也是一个接口类型
// FloatingIPPlugin/PolicyManager对象都实现了PodWatcher接口
type PodWatcher interface {
    AddPod(pod *corev1.Pod) error
    UpdatePod(oldPod, newPod *corev1.Pod) error
    DeletePod(pod *corev1.Pod) error
}
</code></pre><p>上述初始化参数都完成，进入Server Run函数</p>
<pre tabindex="0"><code>// *s.leaderElectionConfig里面的OnStartedLeading回调函数是s.Run()
func (s *Server) Run() error {
    // 启动informer
    go s.informerFactory.Start(s.stopChan)
    go s.crdInformerFactory.Start(s.stopChan)
    if s.tappInformerFactory != nil {
        go s.tappInformerFactory.Start(s.stopChan)
    }
    // 确保创建floatingip和pool的crd
    if err := crd.EnsureCRDCreated(s.extensionClient); err != nil {
        return err
    }
    // FloatingIPPlugin初始化
    if err := s.plugin.Init(); err != nil {
        return err
    }
    // 启动FloatingIPPlugin
    s.plugin.Run(s.stopChan)
    // 创建/v1/ip /v1/pool路由
    go s.startAPIServer()
    // 创建/v1/filter、/v1/priority、/v1/bind、/v1/healthy路由
    s.startServer()
    return nil
}
</code></pre><p>FloatingIPPlugin初始化</p>
<pre tabindex="0"><code>// Init retrieves floatingips from json config or config map and calls ipam to update
func (p *FloatingIPPlugin) Init() error {
    // Conf结构体变量, 从galaxy-ipam-etc configmap中的galaxy-ipam.json解析
    if len(p.conf.FloatingIPs) &gt; 0 {
        if err := p.ipam.ConfigurePool(p.conf.FloatingIPs); err != nil {
            return err
        }
    } else {
        // 如果galaxy-ipam.json配置文件没有配置floatingips，从floatingip-config cm中查找
        glog.Infof(&#34;empty floatingips from config, fetching from configmap&#34;)
        if err := wait.PollInfinite(time.Second, func() (done bool, err error) {
            updated, err := p.updateConfigMap()
            if err != nil {
                glog.Warning(err)
            }
            return updated, nil
        }); err != nil {
            return fmt.Errorf(&#34;failed to get floatingip config from configmap: %v&#34;, err)
        }
    }
    // 等待informer的cache同步
    wait.PollInfinite(time.Second, func() (done bool, err error) {
        glog.Infof(&#34;waiting store ready&#34;)
        return p.storeReady(), nil
    })
    glog.Infof(&#34;store is ready, plugin init done&#34;)
    return nil
}
</code></pre><p>进入FloatingIPPlugin的Run函数</p>
<pre tabindex="0"><code>// Run starts resyncing pod routine
func (p *FloatingIPPlugin) Run(stop chan struct{}) {
    // 再次从floatingip-config cm中查找
    if len(p.conf.FloatingIPs) == 0 {
        go wait.Until(func() {
            if _, err := p.updateConfigMap(); err != nil {
                glog.Warning(err)
            }
        }, time.Minute, stop)
    }
    firstTime := true
    go wait.Until(func() {
        if firstTime {
            glog.Infof(&#34;start resyncing for the first time&#34;)
            defer glog.Infof(&#34;resyncing complete for the first time&#34;)
            firstTime = false
        }
        // 重新同步pod已分配的IP
        if err := p.resyncPod(p.ipam); err != nil {
            glog.Warningf(&#34;[%s] %v&#34;, p.ipam.Name(), err)
        }
        // 是否启用第二个IP
        if p.hasSecondIPConf.Load().(bool) {
            if err := p.resyncPod(p.secondIPAM); err != nil {
                glog.Warningf(&#34;[%s] %v&#34;, p.secondIPAM.Name(), err)
            }
        }
        p.syncPodIPsIntoDB()
    }, time.Duration(p.conf.ResyncInterval)*time.Minute, stop)
    for i := 0; i &lt; 5; i++ {
        go p.loop(stop)
    }
}
</code></pre><p>resyncPod函数</p>
<pre tabindex="0"><code>// IPAM存储的key对象定义
type KeyObj struct {
    // stores the key format in IPAM
    // for deployment dp_namespace_deploymentName_podName,
    // for pool pool__poolName_dp_namespace_deploymentName_podName, for statefulset
    // sts_namespace_statefulsetName_podName
    // If deployment name is 63 bytes, e.g. dp1234567890dp1234567890dp1234567890dp1234567890dp1234567890dp1
    // deployment pod name will be 63 bytes with modified suffix, e.g.
    // dp1234567890dp1234567890dp1234567890dp1234567890dp1234567848p74
    // So we can&#39;t get deployment name from pod name and have to store deployment name with pod name
    KeyInDB       string
    AppName       string
    AppTypePrefix string
    PodName       string
    Namespace     string
    // the annotation value if pod has pool annotation
    PoolName string
}

type resyncObj struct {
    keyObj *util.KeyObj
    fip    floatingip.FloatingIP
}

type resyncMeta struct {
    allocatedIPs map[string]resyncObj // allocated ips from galaxy pool
    existPods    map[string]*corev1.Pod
    tappMap      map[string]*tappv1.TApp
    ssMap        map[string]*appv1.StatefulSet
}

// resyncPod releases ips from
// 1. deleted pods whose parent app does not exist
// 2. deleted pods whose parent deployment or statefulset exist but is not ip immutable
// 3. deleted pods whose parent deployment no need so many ips
// 4. deleted pods whose parent statefulset/tapp exist but pod index &gt; .spec.replica
// 5. existing pods but its status is evicted
func (p *FloatingIPPlugin) resyncPod(ipam floatingip.IPAM) error {
    glog.V(4).Infof(&#34;resync pods+&#34;)
    defer glog.V(4).Infof(&#34;resync pods-&#34;)
    resyncMeta := &amp;resyncMeta{
        allocatedIPs: make(map[string]resyncObj),
    }
    // 检测未被分配的浮动IP池里的所有IP, 根据fip.Key解析为keyObj对象
    // 过滤keyObj.PodName、keyObj.AppName为空，然后放入allocatedIPs map
    if err := p.fetchChecklist(ipam, resyncMeta); err != nil {
        return err
    }
    // 初始化resyncMeta的existPods、tappMap、ssMap变量
    if err := p.fetchAppAndPodMeta(resyncMeta); err != nil {
        return err
    }
    // 重新同步已配分的IP
    p.resyncAllocatedIPs(ipam, resyncMeta)
    return nil
}
</code></pre><p>/v1/filter、/v1/priority、/v1/bind、/v1/healthy路由(实现scheduler extender webhook的方式)</p>
<pre tabindex="0"><code>// /v1/filter路由 优选函数
func (s *Server) filter(request *restful.Request, response *restful.Response) {
    args := new(schedulerapi.ExtenderArgs)
    if err := request.ReadEntity(&amp;args); err != nil {
        glog.Error(err)
        _ = response.WriteError(http.StatusInternalServerError, err)
        return
    }
    glog.V(5).Infof(&#34;POST filter %v&#34;, *args)
    start := time.Now()
    glog.V(3).Infof(&#34;filtering %s_%s, start at %d+&#34;, args.Pod.Name, args.Pod.Namespace, start.UnixNano())
    // 调用FloatingIPPlugin的Filter函数，过滤没有足够浮动IP的节点
    filteredNodes, failedNodesMap, err := s.plugin.Filter(&amp;args.Pod, args.Nodes.Items)
    glog.V(3).Infof(&#34;filtering %s_%s, start at %d-&#34;, args.Pod.Name, args.Pod.Namespace, start.UnixNano())
    args.Nodes.Items = filteredNodes
    errStr := &#34;&#34;
    if err != nil {
        errStr = err.Error()
    }
    _ = response.WriteEntity(schedulerapi.ExtenderFilterResult{
        Nodes:       args.Nodes,
        FailedNodes: failedNodesMap,
        Error:       errStr,
    })
}

// /v1/priority路由  打分函数
func (s *Server) priority(request *restful.Request, response *restful.Response) {
    args := new(schedulerapi.ExtenderArgs)
    if err := request.ReadEntity(&amp;args); err != nil {
        glog.Error(err)
        _ = response.WriteError(http.StatusInternalServerError, err)
        return
    }
    glog.V(5).Infof(&#34;POST priority %v&#34;, *args)
    // 调用FloatingIPPlugin的Prioritize函数，实际上什么都没做？
    hostPriorityList, err := s.plugin.Prioritize(&amp;args.Pod, args.Nodes.Items)
    if err != nil {
        glog.Warningf(&#34;prioritize err: %v&#34;, err)
    }
    _ = response.WriteEntity(*hostPriorityList)
}

// /v1/bind路由  绑定函数
func (s *Server) bind(request *restful.Request, response *restful.Response) {
    args := new(schedulerapi.ExtenderBindingArgs)
    if err := request.ReadEntity(&amp;args); err != nil {
        glog.Error(err)
        _ = response.WriteError(http.StatusInternalServerError, err)
        return
    }
    glog.V(5).Infof(&#34;POST bind %v&#34;, *args)
    start := time.Now()
    glog.V(3).Infof(&#34;binding %s_%s to %s, start at %d+&#34;, args.PodName, args.PodNamespace, args.Node, start.UnixNano())
    // 调用FloatingIPPlugin的Bind函数，
    err := s.plugin.Bind(args)
    glog.V(3).Infof(&#34;binding %s_%s to %s, start at %d-&#34;, args.PodName, args.PodNamespace, args.Node, start.UnixNano())
    var result schedulerapi.ExtenderBindingResult
    if err != nil {
        glog.Warningf(&#34;bind err: %v&#34;, err)
        result.Error = err.Error()
    }
    _ = response.WriteEntity(result)
}

// /v1/healthy路由
func (s *Server) healthy(request *restful.Request, response *restful.Response) {
    response.WriteHeader(http.StatusOK)
    _, _ = response.Write([]byte(&#34;ok&#34;))
}
</code></pre><p>没有在cni插件中指定ipam，pod是如何获取到ip呢？pod如果启用eniNetwork，在galaxy-ipam调度过程bind阶段会为每个pod的annotation带上网络信息，格式如<code>k8s.v1.cni.galaxy.io/args: '{&quot;common&quot;:{&quot;ipinfos&quot;:[{&quot;ip&quot;:&quot;19.16.104.163/24&quot;,&quot;vlan&quot;:0,&quot;gateway&quot;:&quot;19.16.104.254&quot;}]}}'</code>，
galaxy-sdn cni插件会发请求至<code>http://dummy/cni</code>, galaxy server会收到该请求，最终调用到<code>cniutil.CmdAdd</code></p>
<pre tabindex="0"><code># github.com/yaoice/galaxy/pkg/galaxy/server.go
installHandlers -&gt; g.cni -&gt; g.requestFunc -&gt; g.cmdAdd -&gt; cniutil.CmdAdd

// CmdAdd saves networkInfos to disk and executes each cni binary to setup network
func CmdAdd(cmdArgs *skel.CmdArgs, networkInfos []*NetworkInfo) (types.Result, error) {
    if len(networkInfos) == 0 {
        return nil, fmt.Errorf(&#34;No network info returned&#34;)
    }
    if err := saveNetworkInfo(cmdArgs.ContainerID, networkInfos); err != nil {
        return nil, fmt.Errorf(&#34;Error save network info %v for %s: %v&#34;, networkInfos, cmdArgs.ContainerID, err)
    }
    var (
        err    error
        result types.Result
    )
    for idx, networkInfo := range networkInfos {
        //append additional args from network info
        // networkInfo的地址信息赋值给cmdArgs.Args
        cmdArgs.Args = strings.TrimRight(fmt.Sprintf(&#34;%s;%s&#34;, cmdArgs.Args, BuildCNIArgs(networkInfo.Args)), &#34;;&#34;)
        if result != nil {
            networkInfo.Conf[&#34;prevResult&#34;] = result
        }
        // 继续调用其它cni插件执行cmdAdd
        result, err = DelegateAdd(networkInfo.Conf, cmdArgs, networkInfo.IfName)
        if err != nil {
            //fail to add cni, then delete all established CNIs recursively
            glog.Errorf(&#34;fail to add network %s: %v, begin to rollback and delete it&#34;, networkInfo.Args, err)
            delErr := CmdDel(cmdArgs, idx)
            glog.Warningf(&#34;fail to delete cni in rollback %v&#34;, delErr)
            return nil, fmt.Errorf(&#34;fail to establish network %s:%v&#34;, networkInfo.Args, err)
        }
    }
    if err != nil {
        return nil, err
    }
    return result, nil
}

# k8s vlan插件
func cmdAdd(args *skel.CmdArgs) error {
    conf, err := d.LoadConf(args.StdinData)
    if err != nil {
        return err
    }
    // args里携带了上面的网络地址信息
    vlanIds, results, err := ipam.Allocate(conf.IPAM.Type, args)
    ......
}

const (
    IPInfosKey = &#34;ipinfos&#34;
)

// Allocate tries to find IPInfo from args firstly
// Otherwise invoke third party ipam binaries
func Allocate(ipamType string, args *skel.CmdArgs) ([]uint16, []types.Result, error) {
    var (
        vlanId uint16
        err    error
    )
    // 解析args.Args
    kvMap, err := cniutil.ParseCNIArgs(args.Args)
    if err != nil {
        return nil, nil, err
    }
    var results []types.Result
    var vlanIDs []uint16
    // 获取ipinfos key对应的地址信息
    // 格式：&#39;{&#34;common&#34;:{&#34;ipinfos&#34;:[{&#34;ip&#34;:&#34;19.16.104.163/24&#34;,&#34;vlan&#34;:0,&#34;gateway&#34;:&#34;19.16.104.254&#34;}]}}&#39;
    if ipInfoStr := kvMap[constant.IPInfosKey]; ipInfoStr != &#34;&#34; {
        // get ipinfo from cni args
        var ipInfos []constant.IPInfo
        if err := json.Unmarshal([]byte(ipInfoStr), &amp;ipInfos); err != nil {
            return nil, nil, fmt.Errorf(&#34;failed to unmarshal ipInfo from args %q: %v&#34;, args.Args, err)
        }
    ......
}
</code></pre><p>通过scheduler bind阶段把网络地址信息记录在pod的annotation上，然后再通过kubelet加载的galaxy-sdn cni插件把cni请求截获发到galaxy server端，
解析pod的annotation提取网络地址信息，用于构建cni请求的CmdArgs，最后再去请求对应的cni插件</p>
<h4 id="固定ip如何实现">固定IP如何实现</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>apiVersion: galaxy.k8s.io<span style="color:#ff79c6">/</span>v1alpha1
</span></span><span style="display:flex;"><span>kind: FloatingIP
</span></span><span style="display:flex;"><span>metadata:
</span></span><span style="display:flex;"><span>  name: <span style="color:#bd93f9">19.16.104.15</span>
</span></span><span style="display:flex;"><span>  selfLink: <span style="color:#ff79c6">/</span>apis<span style="color:#ff79c6">/</span>galaxy.k8s.io<span style="color:#ff79c6">/</span>v1alpha1<span style="color:#ff79c6">/</span>floatingips<span style="color:#ff79c6">/</span><span style="color:#bd93f9">19.16.104.15</span>
</span></span><span style="display:flex;"><span>  uid: d360cf8c<span style="color:#ff79c6">-</span><span style="color:#bd93f9">6</span>b34<span style="color:#ff79c6">-</span><span style="color:#bd93f9">4</span>a82<span style="color:#ff79c6">-</span>bffb<span style="color:#ff79c6">-</span>c5e2951d1249
</span></span><span style="display:flex;"><span>spec:
</span></span><span style="display:flex;"><span>  attribute: &#39;{<span style="color:#f1fa8c">&#34;NodeName&#34;</span>:<span style="color:#f1fa8c">&#34;12.16.0.6&#34;</span>,<span style="color:#f1fa8c">&#34;Uid&#34;</span>:<span style="color:#f1fa8c">&#34;0f136ed1-6154-4c93-889c-9328fb273e47&#34;</span>}&#39;
</span></span><span style="display:flex;"><span>  key: dp_default_double<span style="color:#ff79c6">-</span><span style="color:#8be9fd;font-style:italic">interface</span><span style="color:#ff79c6">-</span>deployment_double<span style="color:#ff79c6">-</span><span style="color:#8be9fd;font-style:italic">interface</span><span style="color:#ff79c6">-</span>deployment<span style="color:#ff79c6">-</span><span style="color:#bd93f9">698</span>d96ff8b<span style="color:#ff79c6">-</span>smnh7
</span></span><span style="display:flex;"><span>  policy: <span style="color:#bd93f9">2</span>
</span></span></code></pre></div><p>ip可以key产生对应关系，key由工作负载类型、浮动IP池、命名空间工作负载名、pod名组合而成，
当配置了<code>k8s.v1.cni.galaxy.io/release-policy: &quot;never&quot;</code>策略后，表明IP不释放。
如何保证ip被这个工作负载再利用呢？如果删除了这个工作负载，这个浮动IP的cr还在，key变为范匹配<code>dp_default_double-interface-deployment_</code></p>
<p>在什么时候什么地方修改浮动IP cr的key呢？在删除pod的时候，看下在哪里监听这个事件，FloatingIPPlugin Run函数最终会进入loop函数，一直监听p.unreleased的事件.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (p <span style="color:#ff79c6">*</span>FloatingIPPlugin) Run <span style="color:#ff79c6">-</span>&gt; <span style="color:#8be9fd;font-style:italic">func</span> (p <span style="color:#ff79c6">*</span>FloatingIPPlugin) <span style="color:#50fa7b">loop</span>(stop <span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{})
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6272a4">//监听p.unreleased的事件
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// loop pulls release event from chan and calls unbind to unbind pod
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (p <span style="color:#ff79c6">*</span>FloatingIPPlugin) <span style="color:#50fa7b">loop</span>(stop <span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">select</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span>stop:
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">case</span> event <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&lt;-</span>p.unreleased:
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>(event <span style="color:#ff79c6">*</span>releaseEvent) {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> p.<span style="color:#50fa7b">unbind</span>(event.pod); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>                    event.retryTimes<span style="color:#ff79c6">++</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">if</span> event.retryTimes &gt; <span style="color:#bd93f9">3</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#6272a4">// leave it to resync to protect chan from explosion
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                        glog.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;abort unbind for pod %s, retried %d times: %v&#34;</span>, util.<span style="color:#50fa7b">PodName</span>(event.pod),
</span></span><span style="display:flex;"><span>                            event.retryTimes, err)
</span></span><span style="display:flex;"><span>                    } <span style="color:#ff79c6">else</span> {
</span></span><span style="display:flex;"><span>                        glog.<span style="color:#50fa7b">Warningf</span>(<span style="color:#f1fa8c">&#34;unbind pod %s failed for %d times: %v&#34;</span>, util.<span style="color:#50fa7b">PodName</span>(event.pod),
</span></span><span style="display:flex;"><span>                            event.retryTimes, err)
</span></span><span style="display:flex;"><span>                        <span style="color:#6272a4">// backoff time if required
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                        time.<span style="color:#50fa7b">Sleep</span>(<span style="color:#bd93f9">100</span> <span style="color:#ff79c6">*</span> time.Millisecond <span style="color:#ff79c6">*</span> time.<span style="color:#50fa7b">Duration</span>(event.retryTimes))
</span></span><span style="display:flex;"><span>                        p.unreleased <span style="color:#ff79c6">&lt;-</span> event
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }(event)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>p.unreleased事件从哪里传来？是从FloatingIPPlugin对象</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6272a4">//galaxy server启动了一个podInformer，监听pod事件
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//s.plugin=FloatingIPPlugin
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>s.PodInformer.<span style="color:#50fa7b">Informer</span>().<span style="color:#50fa7b">AddEventHandler</span>(eventhandler.<span style="color:#50fa7b">NewPodEventHandler</span>(s.plugin))
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6272a4">//FloatingIPPlugin实现了PodWatcher接口
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// AddPod does nothing
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (p <span style="color:#ff79c6">*</span>FloatingIPPlugin) <span style="color:#50fa7b">AddPod</span>(pod <span style="color:#ff79c6">*</span>corev1.Pod) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// UpdatePod syncs pod ip with ipam
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (p <span style="color:#ff79c6">*</span>FloatingIPPlugin) <span style="color:#50fa7b">UpdatePod</span>(oldPod, newPod <span style="color:#ff79c6">*</span>corev1.Pod) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> !p.<span style="color:#50fa7b">hasResourceName</span>(<span style="color:#ff79c6">&amp;</span>newPod.Spec) {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> !<span style="color:#50fa7b">finished</span>(oldPod) <span style="color:#ff79c6">&amp;&amp;</span> <span style="color:#50fa7b">finished</span>(newPod) {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// Deployments will leave evicted pods
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// If it&#39;s a evicted one, release its ip
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        glog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;release ip from %s_%s, phase %s&#34;</span>, newPod.Name, newPod.Namespace, <span style="color:#8be9fd;font-style:italic">string</span>(newPod.Status.Phase))
</span></span><span style="display:flex;"><span>        p.unreleased <span style="color:#ff79c6">&lt;-</span> <span style="color:#ff79c6">&amp;</span>releaseEvent{pod: newPod}
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> p.<span style="color:#50fa7b">syncPodIP</span>(newPod); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        glog.<span style="color:#50fa7b">Warningf</span>(<span style="color:#f1fa8c">&#34;failed to sync pod ip: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// DeletePod unbinds pod from ipam
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (p <span style="color:#ff79c6">*</span>FloatingIPPlugin) <span style="color:#50fa7b">DeletePod</span>(pod <span style="color:#ff79c6">*</span>corev1.Pod) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> !p.<span style="color:#50fa7b">hasResourceName</span>(<span style="color:#ff79c6">&amp;</span>pod.Spec) {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    glog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;handle pod delete event: %s_%s&#34;</span>, pod.Name, pod.Namespace)
</span></span><span style="display:flex;"><span>    p.unreleased <span style="color:#ff79c6">&lt;-</span> <span style="color:#ff79c6">&amp;</span>releaseEvent{pod: pod}
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//PodWatcher接口
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> PodWatcher <span style="color:#8be9fd;font-style:italic">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">AddPod</span>(pod <span style="color:#ff79c6">*</span>corev1.Pod) <span style="color:#8be9fd">error</span>
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">UpdatePod</span>(oldPod, newPod <span style="color:#ff79c6">*</span>corev1.Pod) <span style="color:#8be9fd">error</span>
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">DeletePod</span>(pod <span style="color:#ff79c6">*</span>corev1.Pod) <span style="color:#8be9fd">error</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>一旦收到p.unreleased的事件，就会执行p.unbind(event.pod)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (p <span style="color:#ff79c6">*</span>FloatingIPPlugin) <span style="color:#50fa7b">lockPod</span>(name, namespace <span style="color:#8be9fd">string</span>) <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>    key <span style="color:#ff79c6">:=</span> fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;%s_%s&#34;</span>, namespace, name)
</span></span><span style="display:flex;"><span>    start <span style="color:#ff79c6">:=</span> time.<span style="color:#50fa7b">Now</span>()
</span></span><span style="display:flex;"><span>    p.podLockPool.<span style="color:#50fa7b">LockKey</span>(key)
</span></span><span style="display:flex;"><span>    elapsed <span style="color:#ff79c6">:=</span> (time.<span style="color:#50fa7b">Now</span>().<span style="color:#50fa7b">UnixNano</span>() <span style="color:#ff79c6">-</span> start.<span style="color:#50fa7b">UnixNano</span>()) <span style="color:#ff79c6">/</span> <span style="color:#bd93f9">1e6</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> elapsed &gt; <span style="color:#bd93f9">500</span> {
</span></span><span style="display:flex;"><span>        glog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;acquire lock for %s took %d ms, started at %s, %s&#34;</span>, key, elapsed,
</span></span><span style="display:flex;"><span>            start.<span style="color:#50fa7b">Format</span>(<span style="color:#f1fa8c">&#34;15:04:05.000&#34;</span>), <span style="color:#50fa7b">getCaller</span>())
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>        _ = p.podLockPool.<span style="color:#50fa7b">UnlockKey</span>(key)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// unbind release ip from pod
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (p <span style="color:#ff79c6">*</span>FloatingIPPlugin) <span style="color:#50fa7b">unbind</span>(pod <span style="color:#ff79c6">*</span>corev1.Pod) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//先执行lockPod函数里面的语句，然后再执行unbind函数里面的非defer语句，最后再执行unbind的returen func
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">defer</span> p.<span style="color:#50fa7b">lockPod</span>(pod.Name, pod.Namespace)()
</span></span><span style="display:flex;"><span>    glog.<span style="color:#50fa7b">V</span>(<span style="color:#bd93f9">3</span>).<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;handle unbind pod %s&#34;</span>, pod.Name)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//计算浮动IP的key形如：dp_default_double-interface-deployment_double-interface-deployment-698d96ff8b-smnh7
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    keyObj, err <span style="color:#ff79c6">:=</span> util.<span style="color:#50fa7b">FormatKey</span>(pod)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    key <span style="color:#ff79c6">:=</span> keyObj.KeyInDB
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//对接第三方公有云的grpc server
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> p.cloudProvider <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        ipInfos, err <span style="color:#ff79c6">:=</span> p.ipam.<span style="color:#50fa7b">ByKeyAndIPRanges</span>(key, <span style="color:#ff79c6">nil</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;query floating ip by key %s: %v&#34;</span>, key, err)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">for</span> _, ipInfo <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> ipInfos {
</span></span><span style="display:flex;"><span>            ipStr <span style="color:#ff79c6">:=</span> ipInfo.IPInfo.IP.IP.<span style="color:#50fa7b">String</span>()
</span></span><span style="display:flex;"><span>            glog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;UnAssignIP nodeName %s, ip %s, key %s&#34;</span>, ipInfo.NodeName, ipStr, key)
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> err = p.<span style="color:#50fa7b">cloudProviderUnAssignIP</span>(<span style="color:#ff79c6">&amp;</span>rpc.UnAssignIPRequest{
</span></span><span style="display:flex;"><span>                NodeName:  ipInfo.NodeName,
</span></span><span style="display:flex;"><span>                IPAddress: ipStr,
</span></span><span style="display:flex;"><span>            }); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">return</span> fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;failed to unassign ip %s from %s: %v&#34;</span>, ipStr, key, err)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//解析ip释放策略，优先级区分
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">//1.如果配置了浮动IP池的annotation，ip释放策略为never
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">//2.如果配置了浮动IP的annotation，ip释放策略为该配置的策略
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">//3.上述都没匹配到的话，即为默认策略，尽可能快释放ip
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    policy <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">parseReleasePolicy</span>(<span style="color:#ff79c6">&amp;</span>pod.ObjectMeta)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> keyObj.<span style="color:#50fa7b">Deployment</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">//deployment类型
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">//根据不同浮动ip释放策略区分
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">//1.默认策略，即释放ip
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">//2.never策略，即保留ip，举例deployment类型，更新浮动ip cr的key为dp_default_double-interface-deployment_
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">//3.immutable策略，即删除pod或scale down过程释放ip
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">return</span> p.<span style="color:#50fa7b">unbindDpPod</span>(keyObj, policy, <span style="color:#f1fa8c">&#34;during unbinding pod&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//非deployment类型
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">//也是根据不同浮动ip释放策略区分
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">return</span> p.<span style="color:#50fa7b">unbindNoneDpPod</span>(keyObj, policy, <span style="color:#f1fa8c">&#34;during unbinding pod&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>galaxy-ipam复用原来的ip在调度filter阶段，在filter阶段完成浮动ip key的更新，例如把key从<code>dp_default_double-interface-deployment</code>_更新为<code>dp_default_double-interface-deployment_double-interface-deployment-698d96ff8b-ns7gv</code>，然后再在bind阶段完成ip信息写到pod的annotation.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6272a4">//filter阶段最终会调用到allocateDuringFilter函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (p <span style="color:#ff79c6">*</span>FloatingIPPlugin) Filter <span style="color:#ff79c6">-</span>&gt;  p.<span style="color:#50fa7b">getSubnet</span>(pod) <span style="color:#ff79c6">-</span>&gt; p.<span style="color:#50fa7b">allocateDuringFilter</span>(keyObj, reserve, isPoolSizeDefined, reserveSubnet, policy, <span style="color:#8be9fd;font-style:italic">string</span>(pod.UID))
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (p <span style="color:#ff79c6">*</span>FloatingIPPlugin) <span style="color:#50fa7b">allocateDuringFilter</span>(keyObj <span style="color:#ff79c6">*</span>util.KeyObj, reserve, isPoolSizeDefined <span style="color:#8be9fd">bool</span>,
</span></span><span style="display:flex;"><span>    reserveSubnet <span style="color:#8be9fd">string</span>, policy constant.ReleasePolicy, uid <span style="color:#8be9fd">string</span>) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// we can&#39;t get nodename during filter, update attr on bind
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    attr <span style="color:#ff79c6">:=</span> floatingip.Attr{Policy: policy, NodeName: <span style="color:#f1fa8c">&#34;&#34;</span>, Uid: uid}
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> reserve {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">//浮动ip释放策略为never的话，reserve为true
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> p.<span style="color:#50fa7b">allocateInSubnetWithKey</span>(keyObj.<span style="color:#50fa7b">PoolPrefix</span>(), keyObj.KeyInDB, reserveSubnet, attr,
</span></span><span style="display:flex;"><span>            <span style="color:#f1fa8c">&#34;filter&#34;</span>); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#ff79c6">else</span> <span style="color:#ff79c6">if</span> isPoolSizeDefined {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// if pool size defined and we got no reserved IP, we need to allocate IP from empty key
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        _, ipNet, err <span style="color:#ff79c6">:=</span> net.<span style="color:#50fa7b">ParseCIDR</span>(reserveSubnet)
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> p.<span style="color:#50fa7b">allocateInSubnet</span>(keyObj.KeyInDB, ipNet, attr, <span style="color:#f1fa8c">&#34;filter&#34;</span>); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (p <span style="color:#ff79c6">*</span>FloatingIPPlugin) <span style="color:#50fa7b">allocateInSubnetWithKey</span>(oldK, newK, subnet <span style="color:#8be9fd">string</span>, attr floatingip.Attr, when <span style="color:#8be9fd">string</span>) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//获取最近更新时间的浮动IP，也就是UpdatedAt时间最大的，并完成key的更新
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> p.ipam.<span style="color:#50fa7b">AllocateInSubnetWithKey</span>(oldK, newK, subnet, attr); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//获取第一个匹配到的ip
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    fip, err <span style="color:#ff79c6">:=</span> p.ipam.<span style="color:#50fa7b">First</span>(newK)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    glog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;allocated ip %s to %s from %s during %s&#34;</span>, fip.IPInfo.IP.<span style="color:#50fa7b">String</span>(), newK, oldK, when)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="galaxy-yaml-sample">galaxy yaml sample</h3>
<p>这里是一个使用k8s ipvlan模式的配置，ipvlan支持需要内核4.2以上</p>
<h4 id="galayx-yaml">galayx yaml</h4>
<pre tabindex="0"><code># vim galaxy-v1.0.6.yaml
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  labels:
    app: galaxy
  name: galaxy-daemonset
  namespace: kube-system
spec:
  selector:
    matchLabels:
      app: galaxy
  template:
    metadata:
      labels:
        app: galaxy
    spec:
      serviceAccountName: galaxy
      hostNetwork: true
      hostPID: true
      containers:
      - image: tkestack/galaxy:v1.0.6.fix-ipvlan
        command: [&#34;/bin/sh&#34;]
      # qcloud galaxy should run with --route-eni
        args: [&#34;-c&#34;, &#34;cp -p /etc/galaxy/cni/00-galaxy.conf /etc/cni/net.d/; cp -p /opt/cni/galaxy/bin/galaxy-sdn /opt/cni/galaxy/bin/loopback /opt/cni/bin/; /usr/bin/galaxy --logtostderr=true --v=3 --network-policy&#34;]
      # private-cloud should run without --route-eni
      # args: [&#34;-c&#34;, &#34;cp -p /etc/galaxy/cni/00-galaxy.conf /etc/cni/net.d/; cp -p /opt/cni/galaxy/bin/galaxy-sdn /opt/cni/galaxy/bin/loopback /opt/cni/bin/; /usr/bin/galaxy --logtostderr=true --v=3&#34;]
        imagePullPolicy: IfNotPresent
        env:
          - name: MY_NODE_NAME
            valueFrom:
              fieldRef:
                fieldPath: spec.nodeName
          - name: DOCKER_HOST
            value: unix:///host/run/docker.sock
        name: galaxy
        resources:
          requests:
            cpu: 100m
            memory: 200Mi
        securityContext:
          privileged: true
        volumeMounts:
        - name: galaxy-run
          mountPath: /var/run/galaxy/
        - name: flannel-run
          mountPath: /run/flannel
        - name: galaxy-log
          mountPath: /data/galaxy/logs
        - name: galaxy-etc
          mountPath: /etc/galaxy
        - name: cni-config
          mountPath: /etc/cni/net.d/
        - name: cni-bin
          mountPath: /opt/cni/bin
        - name: cni-etc
          mountPath: /etc/galaxy/cni
        - name: cni-state
          mountPath: /var/lib/cni
        - name: docker-sock
          mountPath: /host/run/
      terminationGracePeriodSeconds: 30
      tolerations:
      - effect: NoSchedule
        operator: Exists
      volumes:
      - name: galaxy-run
        hostPath:
          path: /var/run/galaxy
      - name: flannel-run
        hostPath:
          path: /run/flannel
      - name: galaxy-log
        emptyDir: {}
      - configMap:
          defaultMode: 420
          name: galaxy-etc
        name: galaxy-etc
      - name: cni-config
        hostPath:
          path: /etc/cni/net.d/
      - name: cni-bin
        hostPath:
          path: /opt/cni/bin
      - name: cni-state
        hostPath:
          path: /var/lib/cni
      - configMap:
          defaultMode: 420
          name: cni-etc
        name: cni-etc
      - name: docker-sock
        # in case of docker restart, /run/docker.sock may change, we have to mount the /run directory
        hostPath:
          path: /run/
</code></pre><p>DefaultNetworks使用galaxy-k8s-vlan</p>
<pre tabindex="0"><code># kubectl -n kube-system edit cm galaxy-etc
  galaxy.json: |
    {
      &#34;NetworkConf&#34;:[
        {&#34;name&#34;:&#34;tke-route-eni&#34;,&#34;type&#34;:&#34;tke-route-eni&#34;,&#34;eni&#34;:&#34;eth1&#34;,&#34;routeTable&#34;:1},
        {&#34;name&#34;:&#34;galaxy-flannel&#34;,&#34;type&#34;:&#34;galaxy-flannel&#34;, &#34;delegate&#34;:{&#34;type&#34;:&#34;galaxy-veth&#34;},&#34;subnetFile&#34;:&#34;/run/flannel/subnet.env&#34;},
        {&#34;name&#34;:&#34;galaxy-k8s-vlan&#34;,&#34;type&#34;:&#34;galaxy-k8s-vlan&#34;, &#34;device&#34;:&#34;eth0&#34;, &#34;switch&#34;:&#34;ipvlan&#34;, &#34;ipvlan_mode&#34;:&#34;l2&#34;},
        {&#34;name&#34;:&#34;galaxy-k8s-sriov&#34;,&#34;type&#34;: &#34;galaxy-k8s-sriov&#34;, &#34;device&#34;: &#34;eth0&#34;, &#34;vf_num&#34;: 10}
      ],
      &#34;DefaultNetworks&#34;: [&#34;galaxy-k8s-vlan&#34;]
    }
</code></pre><h4 id="galaxy-ipam-yaml">galaxy-ipam yaml</h4>
<pre tabindex="0"><code># vim galaxy-ipam-v1.0.6.yaml
apiVersion: v1
kind: Service
metadata:
  name: galaxy-ipam
  namespace: kube-system
  labels:
    app: galaxy-ipam
spec:
  type: NodePort
  ports:
  - name: scheduler-port
    port: 9040
    targetPort: 9040
    nodePort: 32760
    protocol: TCP
  - name: api-port
    port: 9041
    targetPort: 9041
    nodePort: 32761
    protocol: TCP
  selector:
    app: galaxy-ipam
---
apiVersion: rbac.authorization.k8s.io/v1
# kubernetes versions before 1.8.0 should use rbac.authorization.k8s.io/v1beta1
kind: ClusterRole
metadata:
  name: galaxy-ipam
rules:
- apiGroups: [&#34;&#34;]
  resources:
  - pods
  - namespaces
  - nodes
  - pods/binding
  verbs: [&#34;list&#34;, &#34;watch&#34;, &#34;get&#34;, &#34;patch&#34;, &#34;create&#34;]
- apiGroups: [&#34;apps&#34;, &#34;extensions&#34;]
  resources:
  - statefulsets
  - deployments
  verbs: [&#34;list&#34;, &#34;watch&#34;]
- apiGroups: [&#34;&#34;]
  resources:
  - configmaps
  - endpoints
  - events
  verbs: [&#34;get&#34;, &#34;list&#34;, &#34;watch&#34;, &#34;update&#34;, &#34;create&#34;, &#34;patch&#34;]
- apiGroups: [&#34;galaxy.k8s.io&#34;]
  resources:
  - pools
  - floatingips
  verbs: [&#34;get&#34;, &#34;list&#34;, &#34;watch&#34;, &#34;update&#34;, &#34;create&#34;, &#34;patch&#34;, &#34;delete&#34;]
- apiGroups: [&#34;apiextensions.k8s.io&#34;]
  resources:
  - customresourcedefinitions
  verbs:
  - &#34;*&#34;
- apiGroups: [&#34;apps.tkestack.io&#34;]
  resources:
  - tapps
  verbs: [&#34;list&#34;, &#34;watch&#34;]
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: galaxy-ipam
  namespace: kube-system
---
apiVersion: rbac.authorization.k8s.io/v1
# kubernetes versions before 1.8.0 should use rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  name: galaxy-ipam
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: galaxy-ipam
subjects:
  - kind: ServiceAccount
    name: galaxy-ipam
    namespace: kube-system
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: galaxy-ipam
  name: galaxy-ipam
  namespace: kube-system
spec:
  replicas: 1
  selector:
    matchLabels:
      app: galaxy-ipam
  template:
    metadata:
      labels:
        app: galaxy-ipam
    spec:
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
              - key: app
                operator: In
                values:
                - galaxy-ipam
            topologyKey: &#34;kubernetes.io/hostname&#34;
      serviceAccountName: galaxy-ipam
      hostNetwork: true
      dnsPolicy: ClusterFirstWithHostNet
      containers:
      - image: tkestack/galaxy-ipam:v1.0.6
        args:
          - --logtostderr=true
          - --profiling
          - --v=3
          - --config=/etc/galaxy/galaxy-ipam.json
          - --port=9040
          - --api-port=9041
          - --leader-elect
        command:
          - /usr/bin/galaxy-ipam
        ports:
          - containerPort: 9040
          - containerPort: 9041
        imagePullPolicy: Always
        name: galaxy-ipam
        resources:
          requests:
            cpu: 100m
            memory: 200Mi
        volumeMounts:
        - name: kube-config
          mountPath: /etc/kubernetes/
        - name: galaxy-ipam-log
          mountPath: /data/galaxy-ipam/logs
        - name: galaxy-ipam-etc
          mountPath: /etc/galaxy
      terminationGracePeriodSeconds: 30
      tolerations:
        - effect: NoSchedule
          key: node-role.kubernetes.io/master
          operator: Exists
      volumes:
      - name: kube-config
        hostPath:
          path: /etc/kubernetes/
      - name: galaxy-ipam-log
        emptyDir: {}
      - configMap:
          defaultMode: 420
          name: galaxy-ipam-etc
        name: galaxy-ipam-etc
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: galaxy-ipam-etc
  namespace: kube-system
data:
  # delete cloudProviderGrpcAddr if not ENI
  galaxy-ipam.json: |
    {
      &#34;schedule_plugin&#34;: {
      }
    }
</code></pre><h4 id="scheduler-policy-config">scheduler policy config</h4>
<pre tabindex="0"><code># cp /etc/kubernetes/{scheduler-policy-config.json,scheduler-policy-config.json.bak}
</code></pre><p>编辑scheduler policy配置</p>
<pre tabindex="0"><code># vim /etc/kubernetes/scheduler-policy-config.json
{
  &#34;kind&#34;: &#34;Policy&#34;,
  &#34;apiVersion&#34;: &#34;v1&#34;,
  &#34;extenders&#34;: [
    {
      &#34;urlPrefix&#34;: &#34;http://127.0.0.1:32760/v1&#34;,
      &#34;httpTimeout&#34;: 10000000000,
      &#34;filterVerb&#34;: &#34;filter&#34;,
      &#34;bindVerb&#34;: &#34;bind&#34;,
      &#34;weight&#34;: 1,
      &#34;enableHttps&#34;: false,
      &#34;managedResources&#34;: [
        {
          &#34;name&#34;: &#34;tke.cloud.tencent.com/eni-ip&#34;,
          &#34;ignoredByScheduler&#34;: true
        }
      ]
    }
  ]
}
</code></pre><h3 id="场景">场景</h3>
<h4 id="浮动ip池">浮动IP池</h4>
<pre tabindex="0"><code>cat &lt;&lt;EOF | kubectl create -f -
kind: ConfigMap
apiVersion: v1
metadata:
 name: floatingip-config
 namespace: kube-system
data:
 floatingips: &#39;[{&#34;nodeSubnets&#34;:[&#34;192.168.104.0/24&#34;],&#34;ips&#34;:[&#34;192.168.104.130~192.168.104.180&#34;],&#34;subnet&#34;:&#34;192.168.104.0/24&#34;,&#34;gateway&#34;:&#34;192.168.104.254&#34;}]&#39;
EOF
</code></pre><p>配置节点所在的网络，pod要使用的网络, 所有节点对应的neutron port需要设置对应的allow_address_pairs: 192.168.104.0/24; 放行这个网段；ips设置多个地址范围</p>
<p>配置多个subnet cidr</p>
<pre tabindex="0"><code># kubectl -n kube-system edit cm floatingip-config
floatingips: &#39;[{&#34;nodeSubnets&#34;:[&#34;192.168.104.0/24&#34;],&#34;ips&#34;:[&#34;192.168.99.130~192.168.99.131&#34;],&#34;subnet&#34;:&#34;192.168.99.0/24&#34;,&#34;gateway&#34;:&#34;192.168.99.254&#34;},
{&#34;nodeSubnets&#34;:[&#34;192.168.104.0/24&#34;],&#34;ips&#34;:[&#34;192.168.100.130~192.168.100.180&#34;],&#34;subnet&#34;:&#34;192.168.100.0/24&#34;,&#34;gateway&#34;:&#34;192.168.100.254&#34;}]&#39;
</code></pre><h4 id="多网卡">多网卡</h4>
<p>deployment多网卡写法</p>
<pre tabindex="0"><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: double-interface-deployment
  labels:
    app: web
spec:
  selector:
    matchLabels:
      app: web
  replicas: 2
  strategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        app: web
      annotations:
        k8s.v1.cni.cncf.io/networks: &#34;galaxy-flannel,galaxy-k8s-vlan&#34;
    spec:
      containers:
        - name: nginx
          image: nginx
          ports:
            - containerPort: 80
          resources:
            requests:
              tke.cloud.tencent.com/eni-ip: &#34;1&#34;
            limits:
              tke.cloud.tencent.com/eni-ip: &#34;1&#34;
</code></pre><p>pod多网卡写法</p>
<pre tabindex="0"><code>apiVersion: v1
kind: Pod
metadata:
  name: double-interface-pod
  annotations:
    k8s.v1.cni.cncf.io/networks: &#34;galaxy-flannel,galaxy-k8s-vlan&#34;
spec:
  containers:
    - name: nginx
      image: nginx
      resources:
        requests:
          tke.cloud.tencent.com/eni-ip: &#34;1&#34;
        limits:
          tke.cloud.tencent.com/eni-ip: &#34;1&#34;
</code></pre><h4 id="固定ip">固定IP</h4>
<p>对deployment、statefulset类型都生效</p>
<pre tabindex="0"><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: double-interface-deployment
  labels:
    app: web
spec:
  selector:
    matchLabels:
      app: web
  replicas: 2
  strategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        app: web
      annotations:
        k8s.v1.cni.galaxy.io/release-policy: &#34;never&#34;
        k8s.v1.cni.cncf.io/networks: &#34;galaxy-k8s-vlan,galaxy-flannel&#34;
    spec:
      containers:
        - name: nginx
          image: nginx
          ports:
            - containerPort: 80
          resources:
            requests:
              tke.cloud.tencent.com/eni-ip: &#34;1&#34;
            limits:
              tke.cloud.tencent.com/eni-ip: &#34;1&#34;
</code></pre><ul>
<li><code>k8s.v1.cni.galaxy.io/release-policy: never</code>: 不释放IP</li>
<li><code>k8s.v1.cni.galaxy.io/release-policy: immutable</code>: 在删除或scale down的情况下才释放IP</li>
</ul>
<h4 id="测试">测试</h4>
<pre tabindex="0"><code>[root@localhost ~]# cat common-nginx.yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: common-nginx
  labels:
    app: common-nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: common-nginx
  template:
    metadata:
      name: common-nginx
      labels:
        app: common-nginx
      annotations:
        k8s.v1.cni.cncf.io/networks: &#34;galaxy-k8s-vlan&#34;
    spec:
      containers:
      - name: nginx
        image: registry.xxx.com/library/nginx
        resources:
          requests:
            tke.cloud.tencent.com/eni-ip: &#34;1&#34;
          limits:
            tke.cloud.tencent.com/eni-ip: &#34;1&#34;
</code></pre><pre tabindex="0"><code>[root@localhost ~]# kubectl get pod -o wide
NAME                 READY   STATUS    RESTARTS   AGE   IP                NODE              NOMINATED NODE   READINESS GATES
common-nginx-c7d8f   1/1     Running   0          68m   192.168.104.131   192.168.104.111   &lt;none&gt;           &lt;none&gt;
common-nginx-ftpcf   1/1     Running   0          68m   192.168.104.153   192.168.104.128   &lt;none&gt;           &lt;none&gt;
common-nginx-gk8ss   1/1     Running   0          68m   192.168.104.158   192.168.104.111   &lt;none&gt;           &lt;none&gt;
common-nginx-lwh2p   1/1     Running   0          68m   192.168.104.130   192.168.104.111   &lt;none&gt;           &lt;none&gt;
common-nginx-q8mq8   1/1     Running   0          68m   192.168.104.133   192.168.104.111   &lt;none&gt;           &lt;none&gt;
common-nginx-z85cj   1/1     Running   0          68m   192.168.104.142   192.168.104.111   &lt;none&gt;           &lt;none&gt;

[root@localhost ~]# kubectl get floatingips.galaxy.k8s.io
NAME              AGE
192.168.104.130   68m
192.168.104.131   68m
192.168.104.133   68m
192.168.104.142   68m
192.168.104.153   68m
192.168.104.158   68m
</code></pre><p>进入ip为192.168.104.153的pod的namespace，能够ping通网关</p>
<pre tabindex="0"><code>[root@localhost ~]# e common-nginx-ftpcf default
entering pod netns for default/common-nginx-ftpcf
nsenter -n --target 27501
[root@localhost ~]# ip a
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
8: eth0@if2: &lt;BROADCAST,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UNKNOWN group default
    link/ether fa:16:3e:5e:b8:71 brd ff:ff:ff:ff:ff:ff
    inet 192.168.104.153/24 brd 192.168.104.255 scope global eth0
       valid_lft forever preferred_lft forever
[root@localhost ~]#
[root@localhost ~]# route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.104.254 0.0.0.0         UG    0      0        0 eth0
192.168.104.0   0.0.0.0         255.255.255.0   U     0      0        0 eth0
</code></pre><p>外部能够通过<!-- raw HTML omitted -->，直接访问其服务</p>
<h3 id="参考链接">参考链接</h3>
<ul>
<li><a href="https://github.com/tkestack/galaxy">https://github.com/tkestack/galaxy</a></li>
</ul>


                
                
<div class="entry-shang text-center">
    
	    <p>「真诚赞赏，手留余香」</p>
	
	<button class="zs show-zs btn btn-bred">赞赏支持</button>
</div>
<div class="zs-modal-bg"></div>
<div class="zs-modal-box">
	<div class="zs-modal-head">
		<button type="button" class="close">×</button>
		<span class="author"><a href="https://www.iceyao.com.cn/"><img src="/img/favicon.png" />爱折腾的工程师</a></span>
        
	        <p class="tip"><i></i><span>真诚赞赏，手留余香</span></p>
		
 
	</div>
	<div class="zs-modal-body">
		<div class="zs-modal-btns">
			<button class="btn btn-blink" data-num="2">2元</button>
			<button class="btn btn-blink" data-num="5">5元</button>
			<button class="btn btn-blink" data-num="10">10元</button>
			<button class="btn btn-blink" data-num="50">50元</button>
			<button class="btn btn-blink" data-num="100">100元</button>
			<button class="btn btn-blink" data-num="1">任意金额</button>
		</div>
		<div class="zs-modal-pay">
			<button class="btn btn-bred" id="pay-text">2元</button>
			<p>使用<span id="pay-type">微信</span>扫描二维码完成支付</p>
			<img src="/img/reward/wechat-2.png"  id="pay-image"/>
		</div>
	</div>
	<div class="zs-modal-footer">
		<label><input type="radio" name="zs-type" value="wechat" class="zs-type" checked="checked"><span ><span class="zs-wechat"><img src="/img/reward/wechat-btn.png"/></span></label>
		<label><input type="radio" name="zs-type" value="alipay" class="zs-type" class="zs-alipay"><img src="/img/reward/alipay-btn.png"/></span></label>
	</div>
</div>
<script type="text/javascript" src="/js/reward.js"></script>

                

                
                <hr>
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/post/2020-06-25-first_day_of_training/" data-toggle="tooltip" data-placement="top" title="练车(第一天)">&larr;
                            Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/post/2020-07-14-tke-installer_source_code_readnote/" data-toggle="tooltip" data-placement="top" title="TKEStack tke-installer源码阅读笔记">Next
                            Post &rarr;</a>
                    </li>
                    
                </ul>
                

                


<script src="https://giscus.app/client.js"
        data-repo="yaoice/yaoice.github.io"
        data-repo-id="R_kgDOJnxqVg"
        data-category="General"
        data-category-id="DIC_kwDOJnxqVs4CWwUs"
        data-mapping="pathname"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-theme="light"
        data-lang="en"
        crossorigin="anonymous"
        async>
</script>


            </div>

            
            
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
            

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                        
                        
                        
                        
                        
                        <a href="/tags/devops" title="devops">
                            devops
                        </a>
                        
                        
                        
                        <a href="/tags/go" title="go">
                            go
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/k8s" title="k8s">
                            k8s
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/llm" title="llm">
                            llm
                        </a>
                        
                        
                        
                        <a href="/tags/openstack" title="openstack">
                            openstack
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/tkestack" title="tkestack">
                            tkestack
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/%E7%BB%83%E8%BD%A6" title="练车">
                            练车
                        </a>
                        
                        
                    </div>
                </section>
                

                
                
            </div>
        </div>
    </div>
</article>









<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">                  
                    
                    <li>
                        <a href="mailto:yao3690093@gmail.com">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		           
                    
                    
                    
                    

		            
                    
                    <li>
                        <a target="_blank" href="/img/wechat.jpeg">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-weixin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		            
                    
                    <li>
                        <a target="_blank" href="https://github.com/yaoice">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		            
                    
                    
                    
                    
                    
                    
                    
                    
                    
            
            
            
           
                   <li>
                       <a href='' rel="alternate" type="application/rss+xml" title="爱折腾的工程师" >
                           <span class="fa-stack fa-lg">
                               <i class="fas fa-circle fa-stack-2x"></i>
                               <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                           </span>
                       </a>
                   </li>
            
             </ul>
		<p class="copyright text-muted">
                    Copyright &copy; 爱折腾的工程师 2024
                </p>
            </div>
        </div>
    </div>
</footer>




<script>
    function loadAsync(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>






<script>
    
    if($('#tag_cloud').length !== 0){
        loadAsync("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>


<script>
    loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>



<script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https'){
       bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else{
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>


<script>
    
    var _baId = '92c175994ded75a3cd2074bc1123e2be';

    
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>




<script type="text/javascript">
    function generateCatalog(selector) {

        
        
        
        
            _containerSelector = 'div.post-container'
        

        
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        
        $(selector).html('')

        
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    
    $(".catalog-toggle").click((function (e) {
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    


    loadAsync("\/js\/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>







</body>
</html>
