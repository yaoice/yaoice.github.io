<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="爱折腾的工程师"><meta property="og:type" content="article"><meta property="og:image" content="https://www.iceyao.com.cn//img/post-bg-unix-linux.jpg"><meta property="twitter:image" content="https://www.iceyao.com.cn//img/post-bg-unix-linux.jpg"><meta name=title content="常用数据结构与算法"><meta property="og:title" content="常用数据结构与算法"><meta property="twitter:title" content="常用数据结构与算法"><meta name=description content="iceyao，程序员, 开源爱好者，生活探险家 | 这里是iceyao的博客，与你一起发现更大的世界。"><meta property="og:description" content="iceyao，程序员, 开源爱好者，生活探险家 | 这里是iceyao的博客，与你一起发现更大的世界。"><meta property="twitter:description" content="iceyao，程序员, 开源爱好者，生活探险家 | 这里是iceyao的博客，与你一起发现更大的世界。"><meta property="twitter:card" content="summary"><meta name=keyword content="iceyao, IceYao's Blog, 博客, 个人网站, 互联网, Web, 云原生, PaaS, Istio, Kubernetes, 微服务, Microservice"><link rel="shortcut icon" href=/img/favicon.ico><title>常用数据结构与算法 | 爱折腾的工程师 | IceYao's Blog</title>
<link rel=canonical href=/post/2020-05-03-common_data_structures_and_algorithms/><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=/css/zanshang.css><link rel=stylesheet href=/css/font-awesome.all.min.css><script src=/js/jquery.min.js></script><script src=/js/bootstrap.min.js></script><script src=/js/hux-blog.min.js></script><script src=/js/lazysizes.min.js></script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-9J7CKFVPPM"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9J7CKFVPPM")}</script><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=/>爱折腾的工程师</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/>All Posts</a></li><li><a href=/archive//>ARCHIVE</a></li><li><a href=/notes//>NOTES</a></li><li><a href=/about//>ABOUT</a></li><li><a href=/search><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(/img/post-bg-unix-linux.jpg)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/go title=Go>Go</a></div><h1>常用数据结构与算法</h1><h2 class=subheading></h2><span class=meta>Posted by
爱折腾的工程师
on
Sunday, May 3, 2020</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><h3 id=算法复杂度>算法复杂度</h3><h4 id=时间复杂度>时间复杂度</h4><p>大O复杂度表示法: 表示代码执行时间随数据规模增长的变化趋势</p><pre tabindex=0><code>T(n) = O(f(n))
</code></pre><p>时间复杂度分析</p><ul><li>只关注循环次数最多的那段代码</li><li>加法法则，总复杂度等于量级最大的那段代码的复杂度</li><li>乘法法则，嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li></ul><p>常见时间复杂度量级(按数量级递增)：</p><ul><li><p>多项式量级</p><ul><li>常量阶 O(1)</li><li>对数阶 O(logN)</li><li>线性阶 O(n)</li><li>线性对数阶 O(nlogN)</li><li>平方阶 O(n^2) O(n^3) O(n^k)</li></ul></li><li><p>非多项式量级</p><ul><li>指数阶 O(2^n)</li><li>阶乘阶 O(n!)</li></ul></li></ul><h4 id=空间复杂度>空间复杂度</h4><p>表示算法 的存储空间与数据规模之间的增⻓关系</p><p>空间复杂度分析
常⻅的空间复杂度有：</p><ul><li>O(1)</li><li>O(n)</li><li>O(n2 )</li></ul><p>像O(logn)、O(nlogn)对数阶复杂度一般都用不到；空间复杂度分析比时间复杂度分析简单</p><h4 id=进阶复杂度分析>进阶复杂度分析</h4><ul><li>最好情况时间复杂度</li><li>最坏情况时间复杂度</li><li>平均情况时间复杂度</li><li>均摊时间复杂度</li></ul><h3 id=常见数据结构>常见数据结构</h3><h4 id=数组>数组</h4><pre tabindex=0><code>package main

import (
    &#34;errors&#34;
    &#34;fmt&#34;
)

/**
 * 1) 数组的插入、删除、按照下标随机访问操作；
 * 2）数组中的数据是int类型的；
 *
 */

type Array struct {
    data []int
    length uint
}

func NewArray(capacity uint) *Array {
    if capacity == 0 {
        return nil
    }
    return &amp;Array{
        data:   make([]int, capacity, capacity),
        length: 0,
    }
}

func (a *Array) Len() uint {
    return a.length
}

// 越界
func (a *Array) OutOfCap(index uint) error {
    if index &gt;= uint(cap(a.data)) {
        return errors.New(&#34;out of cap&#34;)
    }
    return nil
}

// 插入
func (a *Array) Insert(index uint, v int) error {
    if a.Len() == uint(cap(a.data)) {
        return errors.New(&#34;full cap&#34;)
    }

    // 是否越界
    if err := a.OutOfCap(index); err != nil {
        return err
    }

    for i:=a.Len(); i&gt;index; i-- {
        a.data[i] = a.data[i-1]
    }
    a.data[index] = v
    a.length++
    return nil
}

// 删除
func (a *Array) Delete(index uint) error {
    // 是否越界
    if err := a.OutOfCap(index); err != nil {
        return err
    }
    for i:=index; i&lt;a.Len()-1; i++{
        a.data[i] = a.data[i+1]
    }
    a.data[a.Len()-1] = 0
    a.length--
    return nil
}

// 按照下标随机访问
func (a *Array) Find(index uint) (*int, error) {
    if err := a.OutOfCap(index); err != nil {
        return nil, err
    }
    findInt := a.data[index]
    return &amp;findInt, nil
}

// 遍历
func (a *Array) Print() {
    for i := uint(0); i &lt; uint(cap(a.data)); i++ {
        fmt.Println(a.data[i])
    }
}

func main() {
    testArray := NewArray(10)
    testArray.Insert(0, 0)
    testArray.Insert(1, 1)
    testArray.Insert(2, 2)
    testArray.Insert(3, 3)
    testArray.Delete(2)
    testArray.Print()
}
</code></pre><p>数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为O(n)</p><h4 id=单向链表>单向链表</h4><p>链表插入/删除平均情况时间复杂度为O(1)，随机访问平均时间复杂度为O(n)</p><pre tabindex=0><code>package main

import (
    &#34;fmt&#34;
)

/*
 * 单向链表基本操作
 */

type LinkedNode struct {
    value int
    next  *LinkedNode
}

type LinkedList struct {
    head   *LinkedNode
    length uint
}

func (l *LinkedList) Len() uint {
    return l.length
}

// 之后插入
func (l *LinkedList) InsertAfter(p *LinkedNode, v int) bool {
    if p == nil {
        return false
    }
    originNext := p.next
    linkedNode := &amp;LinkedNode{
        value: v,
        next:  originNext,
    }
    p.next = linkedNode
    l.length++
    return true
}

// 之前插入
func (l *LinkedList) InsertBefore(p *LinkedNode, v int) bool {
    if p == nil {
        return false
    }

    current := l.head
    for current.next != nil {
        if current.next == p {
            break
        }
        current = current.next
    }
    linkedNode := &amp;LinkedNode{
        value: v,
        next:  p,
    }
    current.next = linkedNode
    l.length++
    return true
}

// 删除
func (l *LinkedList) Delete(p *LinkedNode) bool {
    current := l.head
    if current == p {
        l.head = current.next
        l.length--
        return true
    }
    for current.next != nil {
        if current.next == p {
            break
        }
        current = current.next
    }
    if current.next == nil {
        return false
    }
    current.next = p.next
    l.length--
    return true
}

// 查找
func (l *LinkedList) Find(index int) *LinkedNode {
    current := l.head
    for i := 0; i &lt; index-1; i++ {
        if current.next != nil {
            current = current.next
        }
    }
    return current
}

// 遍历
func (l *LinkedList) Print() {
    current := l.head
    for {
        fmt.Println(current.value)
        if current.next == nil {
            return
        }
        current = current.next
    }
}

func main() {
    n5 := &amp;LinkedNode{value: 5, next: nil}
    n4 := &amp;LinkedNode{value: 4, next: n5}
    n3 := &amp;LinkedNode{value: 3, next: n4}
    n2 := &amp;LinkedNode{value: 2, next: n3}
    n1 := &amp;LinkedNode{value: 1, next: n2}

    linkedList := &amp;LinkedList{
        head:   n1,
        length: 5,
    }

    linkedList.InsertBefore(n2, 222)
    linkedList.InsertAfter(n5, 222)

    tar := linkedList.Find(6)
    linkedList.Delete(tar)

    linkedList.Print()
}
</code></pre><h4 id=双向链表>双向链表</h4><p>双向链表，之前插入和删除，不需要再遍历了</p><pre tabindex=0><code>package main

import (
    &#34;fmt&#34;
)

/*
 * 双向链表基本操作
 */

type LinkedNode struct {
    value int
    pre   *LinkedNode
    next  *LinkedNode
}

type LinkedList struct {
    head   *LinkedNode
    length uint
}

func (l *LinkedList) Len() uint {
    return l.length
}

// 之后插入
func (l *LinkedList) InsertAfter(p *LinkedNode, v int) bool {
    if p == nil {
        return false
    }
    lastNode := p.next
    linkedNode := &amp;LinkedNode{
        pre: p,
        value: v,
        next: lastNode,
    }
    p.next = linkedNode
    lastNode.pre = linkedNode
    l.length++
    return true
}

// 之前插入
func (l *LinkedList) InsertBefore(p *LinkedNode, v int) bool {
    if p == nil {
        return false
    }
    preNode := p.pre
    linkedNode := &amp;LinkedNode{
        value: v,
        pre:  preNode,
        next: p,
    }
    preNode.next = linkedNode
    p.pre = linkedNode
    l.length++
    return true
}

// 删除
func (l *LinkedList) Delete(p *LinkedNode) bool {
    // 首节点
    if l.head == p {
        l.head = p.next
        if p.next != nil {
            p.next.pre = nil
        }
        l.length--
        return true
    }
    // 尾节点
    if p.next == nil {
        preNode := p.pre
        preNode.next = nil
        l.length--
        return true
    }
    preNode := p.pre
    lastNode := p.next
    preNode.next = lastNode
    lastNode.pre = preNode
    l.length--
    return true
}

// 查找
func (l *LinkedList) Find(index int) *LinkedNode {
    current := l.head
    for i := 0; i &lt; index-1; i++ {
        if current.next != nil {
            current = current.next
        }
    }
    return current
}

// 遍历
func (l *LinkedList) Print() {
    current := l.head
    for {
        fmt.Println(current.value)
        if current.next == nil {
            return
        }
        current = current.next
    }
}

func main() {
    n5 := &amp;LinkedNode{value: 5, next: nil}
    n4 := &amp;LinkedNode{value: 4, next: n5}
    n3 := &amp;LinkedNode{value: 3, next: n4}
    n2 := &amp;LinkedNode{value: 2, next: n3}
    n1 := &amp;LinkedNode{value: 1, next: n2}

    n1.pre = nil
    n2.pre = n1
    n3.pre = n2
    n4.pre = n3
    n5.pre = n4

    linkedList := &amp;LinkedList{
        head:   n1,
        length: 5,
    }

    linkedList.InsertBefore(n2, 222)
    linkedList.InsertAfter(n3, 222)
    tar := linkedList.Find(7)
    linkedList.Delete(tar)
    linkedList.Print()
}
</code></pre><h4 id=双向循环链表>双向循环链表</h4><pre tabindex=0><code>package main

import (
    &#34;fmt&#34;
)

/*
 * 双向循环链表基本操作(约瑟夫问题)
 */

type LinkedNode struct {
    value int
    pre   *LinkedNode
    next  *LinkedNode
}

type LinkedList struct {
    head   *LinkedNode
    length uint
}

func (l *LinkedList) Len() uint {
    return l.length
}

// 之后插入
func (l *LinkedList) InsertAfter(p *LinkedNode, v int) bool {
    if p == nil {
        return false
    }
    lastNode := p.next
    linkedNode := &amp;LinkedNode{
        pre: p,
        value: v,
        next: lastNode,
    }
    p.next = linkedNode
    lastNode.pre = linkedNode
    l.length++
    return true
}

// 之前插入
func (l *LinkedList) InsertBefore(p *LinkedNode, v int) bool {
    if p == nil {
        return false
    }
    preNode := p.pre
    linkedNode := &amp;LinkedNode{
        value: v,
        pre:  preNode,
        next: p,
    }
    preNode.next = linkedNode
    p.pre = linkedNode
    l.length++
    return true
}

// 删除
func (l *LinkedList) Delete(p *LinkedNode) bool {
    if p.pre == p || p.next == p {
        l.head = nil
        l.length--
        return true
    }
    preNode := p.pre
    lastNode := p.next
    preNode.next = lastNode
    lastNode.pre = preNode
    if l.head == p {
        l.head = p.next
    }
    p.next = nil
    p.pre = nil
    p.value = 0
    l.length--
    return true
}

// 查找
func (l *LinkedList) Find(index int) *LinkedNode {
    current := l.head
    for i := 0; i &lt; index-1; i++ {
        if current.next != nil {
            current = current.next
        }
    }
    return current
}

// 遍历
func (l *LinkedList) Print() {
    current := l.head
    for i:= 0; i&lt;int(l.Len()); i++ {
        fmt.Println(current.value)
        if current.next == nil {
            return
        }
        current = current.next
    }
}

func main() {
    n5 := &amp;LinkedNode{value: 5}
    n4 := &amp;LinkedNode{value: 4}
    n3 := &amp;LinkedNode{value: 3}
    n2 := &amp;LinkedNode{value: 2}
    n1 := &amp;LinkedNode{value: 1}

    n1.pre = n5
    n2.pre = n1
    n3.pre = n2
    n4.pre = n3
    n5.pre = n4

    n1.next = n2
    n2.next = n3
    n3.next = n4
    n4.next = n5
    n5.next = n1

    linkedList := &amp;LinkedList{
        head:   n1,
        length: 5,
    }

    linkedList.InsertBefore(n2, 222)
    linkedList.InsertAfter(n3, 222)
    tar := linkedList.Find(1)
    linkedList.Delete(tar)
    linkedList.Print()
}
</code></pre><h4 id=进阶链表>进阶链表</h4><ul><li>单链表反转</li><li>链表中环的检测</li><li>两个有序的链表合并</li><li>删除链表倒数第n个结点</li><li>求链表的中间结点</li></ul><pre tabindex=0><code>// 反转
/*
 * 使用p和q两个指针配合工作，使得两个节点间的指向反向，同时用r记录剩下的链表
 */
func (l *LinkedList) Reverse() {
    if nil == l.head || nil == l.head.next {
        return
    }

    p := l.head
    q := p.next
    p.next = nil
    for {
        r := q.next
        q.next = p
        p = q
        q = r
        if r == nil {
            break
        }
    }
    l.head = p
}
</code></pre><h4 id=顺序栈>顺序栈</h4><pre tabindex=0><code>package main

import (
    &#34;fmt&#34;
)

/*
 * 基于数组的顺序栈
 */

type Stack struct {
    length int
    size int
    items []string
}

func (s *Stack) Len() int {
    return s.length
}

func NewStack(size int) *Stack {
    return &amp;Stack{
        length: 0,
        size:   size,
        items:  make([]string, size),
    }
}

// 入栈
func (s *Stack) Push(item string) bool {
    if s.length == s.size {
        return false
    }
    s.items[s.length] = item
    s.length++
    return true
}

// 出栈
func (s *Stack) Pop() string {
    if s.length == 0 {
        return &#34;&#34;
    }
    item := s.items[s.length-1]
    s.items = s.items[:s.length-1]
    s.length--
    return item
}

// 遍历
func (s *Stack) Print() {
    for i:=0; i&lt;s.length; i++ {
        fmt.Println(s.items[i])
    }
}

func main() {
    s := NewStack(10)
    s.Push(&#34;1&#34;)
    s.Push(&#34;2&#34;)
    s.Push(&#34;3&#34;)
    fmt.Println(&#34;origin:&#34;)
    s.Print()
    s.Pop()
    s.Pop()
    fmt.Println(&#34;now:&#34;)
    s.Print()
}
</code></pre><h4 id=链式栈>链式栈</h4><pre tabindex=0><code>package main

import (
    &#34;fmt&#34;
)

/*
 * 基于链表的非顺序栈
 */

type LinkedNode struct {
    value int
    next  *LinkedNode
}

type Stack struct {
    head   *LinkedNode
    length int
    size int
}

func NewStack(head   *LinkedNode, size int) *Stack {
    return &amp;Stack{
        head: head,
        length: 0,
        size:   size,
    }
}

func (s *Stack) Len() int {
    return s.length
}

// 入栈
func (s *Stack) Push(v int) bool {
    if s.length == s.size {
        return false
    }
    linkedNode := &amp;LinkedNode{
        value: v,
        next:  nil,
    }
    if s.head == nil {
        s.head = linkedNode
        return true
    }
    tail := s.head
    for tail.next != nil {
        tail = tail.next
    }
    tail.next = linkedNode
    s.length++
    return true
}

// 出栈
func (s *Stack) Pop() *int {
    beforeTail := new(LinkedNode)
    tail := s.head
    if tail == nil {
        return nil
    }
    beforeTail = tail
    for tail.next != nil {
        beforeTail = tail
        tail = tail.next
    }
    beforeTail.next = nil
    s.length--
    return &amp;tail.value
}

// 遍历
func (s *Stack) Print() {
    current := s.head
    for {
        fmt.Println(current.value)
        if current.next == nil {
            return
        }
        current = current.next
    }
}

func main() {
    n5 := &amp;LinkedNode{value: 5, next: nil}
    n4 := &amp;LinkedNode{value: 4, next: n5}
    n3 := &amp;LinkedNode{value: 3, next: n4}
    n2 := &amp;LinkedNode{value: 2, next: n3}
    n1 := &amp;LinkedNode{value: 1, next: n2}

    s := NewStack(n1, 5)
    s.Push(6)
    s.Push(10)
    s.Push(11)
    s.Pop()
    s.Print()
}
</code></pre><h4 id=顺序队列>顺序队列</h4><pre tabindex=0><code>package main

import (
    &#34;fmt&#34;
)

/*
 * 基于数组的顺序队列
 */

type Queue struct {
    length int
    size int
    items []string
}

func (s *Queue) Len() int {
    return s.length
}

func NewQueue(size int) *Queue {
    return &amp;Queue{
        length: 0,
        size:   size,
        items:  make([]string, size),
    }
}

// 入队列
func (s *Queue) Push(item string) bool {
    if s.length == s.size {
        return false
    }
    s.items[s.length] = item
    s.length++
    return true
}

// 出队列
func (s *Queue) Pop() string {
    if s.length == 0 {
        return &#34;&#34;
    }
    item := s.items[0]
    s.items = s.items[1:]
    s.length--
    return item
}

// 遍历
func (s *Queue) Print() {
    for i:=0; i&lt;s.length; i++ {
        fmt.Println(s.items[i])
    }
}

func main() {
    s := NewQueue(10)
    fmt.Println(&#34;origin:&#34;)
    s.Push(&#34;1&#34;)
    s.Push(&#34;2&#34;)
    s.Push(&#34;3&#34;)
    s.Print()
    s.Pop()
    fmt.Println(&#34;now:&#34;)
    s.Print()
}
</code></pre><h4 id=链式队列>链式队列</h4><pre tabindex=0><code>package main

import (
    &#34;fmt&#34;
)

/*
 * 基于链表的非顺序队列
 */

type LinkedNode struct {
    value int
    next  *LinkedNode
}

type Queue struct {
    head   *LinkedNode
    length int
    size int
}

func NewQueue(head   *LinkedNode, size int) *Queue {
    return &amp;Queue{
        head: head,
        length: 0,
        size:   size,
    }
}

func (q *Queue) Len() int {
    return q.length
}

// 入队列
func (q *Queue) Push(v int) bool {
    if q.length == q.size {
        return false
    }
    linkedNode := &amp;LinkedNode{
        value: v,
        next:  nil,
    }
    if q.head == nil {
        q.head = linkedNode
        return true
    }
    tail := q.head
    for tail.next != nil {
        tail = tail.next
    }
    tail.next = linkedNode
    q.length++
    return true
}

// 出队列
func (q *Queue) Pop() *int {
    if q.head == nil {
        return nil
    }
    popValue := q.head.value
    q.head = q.head.next
    q.length--
    return &amp;popValue
}

// 遍历
func (q *Queue) Print() {
    current := q.head
    for {
        fmt.Println(current.value)
        if current.next == nil {
            return
        }
        current = current.next
    }
}

func main() {
    n5 := &amp;LinkedNode{value: 5, next: nil}
    n4 := &amp;LinkedNode{value: 4, next: n5}
    n3 := &amp;LinkedNode{value: 3, next: n4}
    n2 := &amp;LinkedNode{value: 2, next: n3}
    n1 := &amp;LinkedNode{value: 1, next: n2}

    q := NewQueue(n1, 5)
    q.Push(6)
    q.Push(10)
    q.Push(11)
    q.Pop()
    q.Print()
}
</code></pre><h4 id=循环队列>循环队列</h4><p>基于数组实现的队列，在出队列的时候会有数据搬迁；循环队列可以不用数据搬迁</p><pre tabindex=0><code>package main

import (
    &#34;fmt&#34;
)

/*
 * 基于数组的循环队列，分别用head、tail记录队列头部、尾部位置
 */

type Queue struct {
    size int
    head int
    tail int
    items []interface{}
}

func NewQueue(size int) *Queue {
    return &amp;Queue{
        size:   size,
        head: 0,
        tail: 0,
        items:  make([]interface{}, size),
    }
}

// 是否满队列
func (s *Queue) IsFull() bool {
    if s.head == (s.tail+1) % s.size {
        return true
    }
    return false
}

// 是否空队列
func (s *Queue) IsEmpty() bool {
    if s.head == s.tail {
        return true
    }
    return false
}

// 入队列
func (s *Queue) Push(item interface{}) bool {
    if s.IsFull() {
        return false
    }
    s.items[s.tail] = item
    s.tail = (s.tail+1) % s.size
    return true
}

// 出队列
func (s *Queue) Pop() interface{} {
    if s.IsEmpty() {
        return false
    }
    item := s.items[s.head]
    s.head = (s.head+1) % s.size
    return item
}

// 遍历
func (s *Queue) String() string {
    if s.IsEmpty() {
        return &#34;empty queue&#34;
    }
    result := &#34;head&#34;
    var i = s.head
    for true {
        result += fmt.Sprintf(&#34;&lt;-%+v&#34;, s.items[i])
        i = (i + 1) % s.size
        if i == s.tail {
            break
        }
    }
    result += &#34;&lt;-tail&#34;
    return result
}

func main() {
    s := NewQueue(10)
    fmt.Println(&#34;origin:&#34;)
    s.Push(&#34;1&#34;)
    s.Push(&#34;2&#34;)
    s.Push(&#34;3&#34;)
    fmt.Println(s)
    s.Pop()
    fmt.Println(&#34;now:&#34;)
    fmt.Println(s)
}
</code></pre><h3 id=算法>算法</h3><h4 id=bitmap位图>bitmap(位图)</h4><pre tabindex=0><code>/*
BitMap解决海量数据寻找重复、判断个别元素是否在海量数据当中

（来自《编程珠玑》）：给一台普通PC，2G内存，要求处理一个包含40亿个不重复并且没有排过序的无符号的int整数，
给出一个整数，问如果快速地判断这个整数是否在文件40亿个数据当中？

问题思考：
40亿个int占（40亿*4）/1024/1024/1024 大概为14.9G左右，很明显内存只有2G，放不下，
因此不可能将这40亿数据放到内存中计算。

要快速的解决这个问题最好的方案就是将数据搁内存了，所以现在的问题就在如何在2G内存空间以内存储着40亿整数。

一个int整数在golang中是占4个字节的即要32bit位，如果能够用一个bit位来标识一个int整数那么存储空间将大大减少，
算一下40亿个int需要的内存空间为40亿/8/1024/1024大概为476.83 mb，这样的话我们完全可以将这40亿个int数放到内存中进行处理。

具体思路：
1个int占4字节即4*8=32位，那么我们只需要申请一个int数组长度为 int tmp[1+N/32]即可存储完这些数据，
其中N代表要进行查找的总数，tmp中的每个元素在内存在占32位可以对应表示十进制数0~31,所以可得到BitMap表:

tmp[0]:可表示0~31
tmp[1]:可表示32~63
tmp[2]可表示64~95
*/

package bitmap

import (
    &#34;bytes&#34;
    &#34;fmt&#34;
)

type Bitmap struct {
    words  []uint64
    length uint64
}

func New() *Bitmap {
    return &amp;Bitmap{}
}
func (bitmap *Bitmap) Has(num int) bool {
    word, bit := num/64, uint(num%64)
    return word &lt; len(bitmap.words) &amp;&amp; (bitmap.words[word]&amp;(1&lt;&lt;bit)) != 0
}

func (bitmap *Bitmap) Add(num int) {
    word, bit := num/64, uint(num%64)
    for word &gt;= len(bitmap.words) {
        bitmap.words = append(bitmap.words, 0)
    }
    // 判断num是否已经存在bitmap中
    if bitmap.words[word]&amp;(1&lt;&lt;bit) == 0 {
        bitmap.words[word] |= 1 &lt;&lt; bit
        bitmap.length++
    }
}

func (bitmap *Bitmap) Len() int {
    return bitmap.length
}

func (bitmap *Bitmap) String() string {
    var buf bytes.Buffer
    buf.WriteByte(&#39;{&#39;)
    for i, v := range bitmap.words {
        if v == 0 {
            continue
        }
        for j := uint(0); j &lt; 64; j++ {
            if v&amp;(1&lt;&lt;j) != 0 {
                if buf.Len() &gt; len(&#34;{&#34;) {
                    buf.WriteByte(&#39; &#39;)
                }
                fmt.Fprintf(&amp;buf, &#34;%d&#34;, 64*uint(i)+j)
            }
        }
    }
    buf.WriteByte(&#39;}&#39;)
    fmt.Fprintf(&amp;buf,&#34;\nLength: %d&#34;, bitmap.length)
    return buf.String()
}
</code></pre><p>排序算法一览：</p><p><img src=/img/posts/2020-05-03/sort.png alt></p><h4 id=冒泡排序>冒泡排序</h4><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。</p><p>算法步骤：</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><pre tabindex=0><code>func bubbleSort(arr []int) []int {
    length := len(arr)
    for i := 0; i &lt; length; i++ {
        for j := 0; j &lt; length-1-i; j++ {
            if arr[j] &gt; arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
    return arr
}
</code></pre><h4 id=选择排序>选择排序</h4><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是O(n²)的时间复杂度。</p><p>算法步骤：</p><ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。</li></ol><pre tabindex=0><code>func selectorSort(arr []int) []int {
    length := len(arr)
    for i := 0; i &lt; length; i++ {
        max := i
        for j := i+1; j &lt; length; j++ {
            if arr[j] &gt; arr[max] {
                max = j
            }
        }

        if max != i {
            arr[max], arr[i] = arr[i], arr[max]
        }
    }
    return arr
}
</code></pre><h4 id=插入排序>插入排序</h4><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，
插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p><p>算法步骤：</p><ol><li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li><li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li></ol><pre tabindex=0><code>func insertSort(arr []int) []int {
    for i := range arr {
        preIndex := i - 1
        current := arr[i]
        for preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current {
            arr[preIndex+1] = arr[preIndex]
            preIndex -= 1
        }
        arr[preIndex+1] = current
    }
    return arr
}
</code></pre><h4 id=归并排序>归并排序</h4><p>归并排序(Merge sort)是建立在归并操作上的一种有效的排序算法。该算法是采用分治法(Divide and Conquer)的一个非常典型的应用。</p><p>归并排序的实现由两种方法：</p><ul><li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第2种方法）</li><li>自下而上的迭代</li></ul><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn)的时间复杂度。代价是需要额外的内存空间。</p><p>算法步骤：</p><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复步骤3直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol><p>自下而上的迭代</p><pre tabindex=0><code>func mergeSort(arr []int) []int {
    length := len(arr)
    if length &lt; 2 {
        return arr
    }
    middle := length / 2
    left := arr[0:middle]
    right := arr[middle:]

   return merge(mergeSort(left), mergeSort(right))
}

func merge(left []int, right []int) []int {
    var result []int

    for len(left) != 0 &amp;&amp; len(right) != 0 {
        if left[0] &lt; right[0] {
            result = append(result, left[0])
            left = left[1:]
        } else {
            result = append(result, right[0])
            right = right[1:]
        }
    }
    for len(left) != 0 {
        result = append(result, left[0])
        left = left[1:]
    }

    for len(right) != 0 {
        result = append(result, right[0])
        right = right[1:]
    }
    return result
}
</code></pre><h4 id=二叉树最大深度>二叉树最大深度</h4><p>方法一：深度优先搜索(DFS)</p><p>堆栈实现, 利用递归的方式不停下探树的深度; 递归的终止条件是如果节点为空就返回0</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff79c6>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>type</span> TreeNode <span style=color:#8be9fd;font-style:italic>struct</span> {
</span></span><span style=display:flex><span>    left <span style=color:#ff79c6>*</span>TreeNode <span style=color:#6272a4>// 左子节点
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    right <span style=color:#ff79c6>*</span>TreeNode <span style=color:#6272a4>// 右子节点
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    value <span style=color:#8be9fd>int</span> <span style=color:#6272a4>// 值
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>maxDepth</span>(root <span style=color:#ff79c6>*</span>TreeNode) <span style=color:#8be9fd>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 递归终止条件
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#8be9fd;font-style:italic>max</span>(<span style=color:#50fa7b>maxDepth</span>(root.left), <span style=color:#50fa7b>maxDepth</span>(root.right)) <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#8be9fd;font-style:italic>max</span>(a, b <span style=color:#8be9fd>int</span>) <span style=color:#8be9fd>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> a &gt; b {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> a
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> b
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>方法二：广度优先搜索(BFS)</p><p>队列实现, 利用迭代的方式将每一层的节点都放入到队列当中; 队列出队清空进入下一层。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff79c6>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>type</span> TreeNode <span style=color:#8be9fd;font-style:italic>struct</span> {
</span></span><span style=display:flex><span>    left <span style=color:#ff79c6>*</span>TreeNode <span style=color:#6272a4>// 左子节点
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    right <span style=color:#ff79c6>*</span>TreeNode <span style=color:#6272a4>// 右子节点
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    value <span style=color:#8be9fd>int</span> <span style=color:#6272a4>// 值
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>maxDepth</span>(root <span style=color:#ff79c6>*</span>TreeNode) <span style=color:#8be9fd>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 没有根节点
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> root <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 创建队列
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    queue <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>make</span>([]<span style=color:#ff79c6>*</span>TreeNode, <span style=color:#bd93f9>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 根节点入队列
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    queue = <span style=color:#8be9fd;font-style:italic>append</span>(queue, root)
</span></span><span style=display:flex><span>    depth <span style=color:#ff79c6>:=</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 清算队列
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>for</span> <span style=color:#8be9fd;font-style:italic>len</span>(queue) &gt; <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 把当前层的队列全部遍历一遍全部出队列
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        size <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>len</span>(queue)
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> i<span style=color:#ff79c6>:=</span><span style=color:#bd93f9>0</span>; i&lt;size; i<span style=color:#ff79c6>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 出队列
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            v <span style=color:#ff79c6>:=</span> queue[<span style=color:#bd93f9>0</span>]
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> v.left <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>                queue = <span style=color:#8be9fd;font-style:italic>append</span>(queue, v.left)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> v.right <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>                queue = <span style=color:#8be9fd;font-style:italic>append</span>(queue, v.right)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        depth<span style=color:#ff79c6>++</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> depth
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>DFS一般是解决连通性问题, 而BFS一般是解决最短路径问题.</p><h4 id=lru缓存>LRU缓存</h4><p>LRU: 最近一段时间最久未被使用的缓存优先删除</p><p>采用哈希表+双向链表实现；哈希表存放key对应的链节点(缓存数据)，双向链表的顺序代表数据访问的新旧程度，
头部位置代表最近被访问的数据，尾部位置代表最近许久未被访问的数据，如果缓存数据超过链表容量，删除尾部位置节点</p><pre tabindex=0><code>package main

import &#34;fmt&#34;

/*
采用哈希表+双向链表
*/

type LRUCache struct {
    size, cap int
    head, tail *LinkNode
    cache map[int]*LinkNode
}

type LinkNode struct {
    key, value int
    pre, next *LinkNode
}

func (l *LRUCache) Get(key int) int {
    linkNode, ok := l.cache[key]
    //不存在，返回-1
    if !ok {
        return -1
    }
    //存在，移动节点到链表头
    l.moveToHead(linkNode)
    return linkNode.value
}

func (l *LRUCache) Put(key, value int) {
    linkNode, ok := l.cache[key]
    if !ok {
        //是新节点
        newLinkNode := initLinkNode(key, value)
        l.addToHead(newLinkNode)
        l.cache[key] = newLinkNode
        l.size++

        if l.size &gt; l.cap {
            //超过链表容量，剔除链表尾部节点
            removedNode := l.tail.pre
            l.removeNode(removedNode)
            //从map删除
            delete(l.cache, removedNode.key)
            l.size--
        }
    } else {
        //节点已存在
        if linkNode.value != value {
            linkNode.value = value
        }
        l.moveToHead(linkNode)
    }
}

func (l *LRUCache) removeNode(linkNode *LinkNode) {
    linkNode.pre.next = linkNode.next
    linkNode.next.pre = linkNode.pre
}

func (l *LRUCache) removeTail(linkNode *LinkNode) {
    l.removeNode(linkNode)
    l.tail.next = nil
}

func (l *LRUCache) addToHead(linkNode *LinkNode) {
    linkNode.pre = l.head
    linkNode.next = l.head.next

    l.head.next.pre = linkNode
    l.head.next = linkNode
}

func (l *LRUCache) moveToHead(linkNode *LinkNode) {
    //1. 删除节点原来的位置
    l.removeNode(linkNode)
    //2. 插入到链表头部
    l.addToHead(linkNode)
}


func initLinkNode(key, value int) *LinkNode {
    return &amp;LinkNode{
        key: key,
        value: value,
    }
}

func conStructLRUCache(cap int) *LRUCache {
    l := &amp;LRUCache{
        size:  0,
        cap:   cap,
        head:  initLinkNode(0, 0),
        tail:  initLinkNode(0,0),
        cache: make(map[int]*LinkNode, 0),
    }
    l.head.next = l.tail
    l.head.pre = nil
    l.tail.pre = l.head
    l.tail.next = nil
    return l
}

func (l *LRUCache) print() {
    for key, value := range l.cache {
        fmt.Printf(&#34; key: %d, value: %d&#34;, key, value.value)
    }
}

func main() {
    l := conStructLRUCache(2)
    fmt.Println(&#34;\n第一次put&#34;)
    l.Put(1,1)
    l.print()
    fmt.Println(&#34;\n第二次put&#34;)
    l.Put(2,2)
    l.print()
    l.Get(1)
    fmt.Println(&#34;\n第三次put&#34;)
    l.Put(3,3)
    l.print()
    fmt.Println(&#34;\n第四次put&#34;)
    l.Put(4,4)
    l.print()
    fmt.Println(&#34;\n第五次put&#34;)
    l.Put(4,8)
    l.print()
    fmt.Println(&#34;\n第六次put&#34;)
    l.Put(6,6)
    l.print()
}
</code></pre><h3 id=参考链接>参考链接</h3><ul><li>数据结构与算法之美(极客时间王争)</li><li><a href=https://github.com/hustcc/JS-Sorting-Algorithm>十大经典排序算法</a></li></ul><div class="entry-shang text-center"><p>「真诚赞赏，手留余香」</p><button class="zs show-zs btn btn-bred">赞赏支持</button></div><div class=zs-modal-bg></div><div class=zs-modal-box><div class=zs-modal-head><button type=button class=close>×</button>
<span class=author><a href=https://www.iceyao.com.cn/><img src=/img/favicon.png>爱折腾的工程师</a></span><p class=tip><i></i><span>真诚赞赏，手留余香</span></p></div><div class=zs-modal-body><div class=zs-modal-btns><button class="btn btn-blink" data-num=2>2元</button>
<button class="btn btn-blink" data-num=5>5元</button>
<button class="btn btn-blink" data-num=10>10元</button>
<button class="btn btn-blink" data-num=50>50元</button>
<button class="btn btn-blink" data-num=100>100元</button>
<button class="btn btn-blink" data-num=1>任意金额</button></div><div class=zs-modal-pay><button class="btn btn-bred" id=pay-text>2元</button><p>使用<span id=pay-type>微信</span>扫描二维码完成支付</p><img src=/img/reward/wechat-2.png id=pay-image></div></div><div class=zs-modal-footer><label><input type=radio name=zs-type value=wechat class=zs-type checked><span><span class=zs-wechat><img src=/img/reward/wechat-btn.png></span></label>
<label><input type=radio name=zs-type value=alipay class=zs-type class=zs-alipay><img src=/img/reward/alipay-btn.png></span></label></div></div><script type=text/javascript src=/js/reward.js></script><hr><ul class=pager><li class=previous><a href=/post/2020-04-27-k8s-network-develop_remote_debug/ data-toggle=tooltip data-placement=top title=k8s远程调试(开山篇)>&larr;
Previous Post</a></li><li class=next><a href=/post/2020-05-06-k8s_network_with_openstack_1/ data-toggle=tooltip data-placement=top title=k8s、OpenStack网络打通(一)>Next
Post &rarr;</a></li></ul><script src=https://giscus.app/client.js data-repo=yaoice/yaoice.github.io data-repo-id=R_kgDOJnxqVg data-category=General data-category-id=DIC_kwDOJnxqVs4CWwUs data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-theme=light data-lang=en crossorigin=anonymous async></script></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5><a href=/tags/>FEATURED TAGS</a></h5><div class=tags><a href=/tags/devops title=devops>devops
</a><a href=/tags/go title=go>go
</a><a href=/tags/k8s title=k8s>k8s
</a><a href=/tags/llm title=llm>llm
</a><a href=/tags/openstack title=openstack>openstack
</a><a href=/tags/tkestack title=tkestack>tkestack
</a><a href=/tags/%E7%BB%83%E8%BD%A6 title=练车>练车</a></div></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:yao3690093@gmail.com><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=/img/wechat.jpeg><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-weixin fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/yaoice><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href rel=alternate type=application/rss+xml title=爱折腾的工程师><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 爱折腾的工程师 2024</p></div></div></div></footer><script>function loadAsync(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(null,e)},!1),i.parentNode.insertBefore(n,i)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script>(function(){var t,e=document.createElement("script"),n=window.location.protocol.split(":")[0];n==="https"?e.src="https://zz.bdstatic.com/linksubmit/push.js":e.src="http://push.zhanzhang.baidu.com/push.js",t=document.getElementsByTagName("script")[0],t.parentNode.insertBefore(e,t)})()</script><script>var _baId="92c175994ded75a3cd2074bc1123e2be",_hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="//hm.baidu.com/hm.js?"+_baId,e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,a=$(_containerSelector),r=a.find("h1,h2,h3,h4,h5,h6");return $(e).html(""),r.each(function(){t=$(this).prop("tagName").toLowerCase(),o="#"+$(this).prop("id"),n=$(this).text(),i=$('<a href="'+o+'" rel="nofollow">'+n+"</a>"),s=$('<li class="'+t+'_nav"></li>').append(i),$(e).append(s)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script></body></html>