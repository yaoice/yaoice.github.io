<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    

    
    <meta property="og:site_name" content="爱折腾的工程师">
    <meta property="og:type" content="article">

    
    <meta property="og:image" content="https://www.iceyao.com.cn//img/post-bg-unix-linux.jpg">
    <meta property="twitter:image" content="https://www.iceyao.com.cn//img/post-bg-unix-linux.jpg" />
    

    
    <meta name="title" content="容器网络发展" />
    <meta property="og:title" content="容器网络发展" />
    <meta property="twitter:title" content="容器网络发展" />
    

    
    <meta name="description" content="iceyao，程序员, 开源爱好者，生活探险家 | 这里是iceyao的博客，与你一起发现更大的世界。">
    <meta property="og:description" content="iceyao，程序员, 开源爱好者，生活探险家 | 这里是iceyao的博客，与你一起发现更大的世界。" />
    <meta property="twitter:description" content="iceyao，程序员, 开源爱好者，生活探险家 | 这里是iceyao的博客，与你一起发现更大的世界。" />
    

    
    <meta property="twitter:card" content="summary" />
    
    

    <meta name="keyword"  content="iceyao, IceYao&#39;s Blog, 博客, 个人网站, 互联网, Web, 云原生, PaaS, Istio, Kubernetes, 微服务, Microservice">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>容器网络发展 | 爱折腾的工程师 | IceYao&#39;s Blog</title>

    <link rel="canonical" href="/post/2021-07-19-container_network_development/">

    

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css">

    
    <link rel="stylesheet" href="/css/hugo-theme-cleanwhite.min.css">

    
    <link rel="stylesheet" href="/css/zanshang.css">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css">

    
    

    
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script>

    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js"></script>

    
    <script src="/js/hux-blog.min.js"></script>

    
    <script src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script>

    
    

</head>



  
    
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-9J7CKFVPPM"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-9J7CKFVPPM');
        }
      </script>
    
  







<nav class="navbar navbar-default navbar-custom navbar-fixed-top">

    <div class="container-fluid">
        
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">爱折腾的工程师</a>
        </div>

        
        
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">All Posts</a>
                    </li>
                    
                        
                    
                    
		    
                        <li><a href="/archive//">ARCHIVE</a></li>
                    
                        <li><a href="/notes//">NOTES</a></li>
                    
                        <li><a href="/about//">ABOUT</a></li>
                    
		            <li>
                        <a href="/search"><i class="fa fa-search"></i></a>
		           </li>
                </ul>
            </div>
        </div>
        
    </div>
    
</nav>
<script>
    
    
    
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        
            $navbar.className = " ";
            
            setTimeout(function(){
                
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>




<style type="text/css">
    header.intro-header {
        background-image: url('/img/post-bg-unix-linux.jpg')
    }
</style>

<header class="intro-header" >

    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/k8s" title="k8s">
                            k8s
                        </a>
                        
                    </div>
                    <h1>容器网络发展</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        
                            Posted by 
                            
                                    爱折腾的工程师
                             
                            on 
                            Monday, July 19, 2021
                            
                            
                            
                            
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>




<article>
    <div class="container">
        <div class="row">

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                
                <p>[toc]</p>
<h2 id="1-容器网络基础">1. 容器网络基础</h2>
<h3 id="11-network-namespace">1.1 network namespace</h3>
<p>Network Namespace （以下简称netns）是Linux内核提供的一项实现网络隔离的功能，它能隔离多个不同的网络空间，并且各自拥有独立的网络协议栈，这其中便包括了网络接口（网卡），路由表，iptables规则等。例如大名鼎鼎的docker便是基于netns实现的网络隔离。</p>
<p>
  <img src="https://segmentfault.com/img/remote/1460000024474310" alt="100%">

</p>
<h3 id="12-bridge">1.2 bridge</h3>
<p>网桥是一个二层的虚拟网络设备，把若干个网络接口“连接”起来，使得网口之间的报文可以转发。网桥能够解析收发的报文，读取目标的Mac地址信息，和自己的Mac地址表结合，来决策报文转发的目标网口。为了实现这些功能，网桥会学习源Mac地址。在转发报文时，网桥只需要向特定的端口转发，从而避免不必要的网络交互。如果它遇到了一个自己从未学过的地址，就无法知道这个报文应该向哪个网口转发，就将报文广播给除了报文来源之外的所有网口。</p>
<p>
  <img src="https://segmentfault.com/img/remote/1460000024474312" alt="100%">

</p>
<h3 id="13-arp">1.3 arp</h3>
<p>ARP（Address Resolution Protocol）即地址解析协议， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址。</p>
<p>
  <img src="http://cache.yisu.com/upload/admin/customer_case_img/2019-06-20/1561028184.jpg" alt="80%">

</p>
<p>linux查看arp缓存</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#6272a4"># ip neigh show</span>
</span></span><span style="display:flex;"><span>172.20.0.17 dev v-h28edb3920 lladdr ee:7a:dd:24:73:ee REACHABLE
</span></span><span style="display:flex;"><span>172.17.0.2 dev docker0 lladdr 02:42:ac:11:00:02 STALE
</span></span></code></pre></div><h3 id="14-veth">1.4 veth</h3>
<p>Veth Pair设备的特点是：它被创建出来后，总是以两张虚拟网卡（Veth Peer）的形式出现。并且，其中一个网卡发出的数据包，可以直接出现在另一张“网卡”上，哪怕这两张网卡在不同的Network Namespace中。</p>
<p>
  <img src="https://segmentfault.com/img/remote/1460000024474313" alt="100%">

</p>
<h3 id="15-iptablesnetfilter">1.5 iptables/netfilter</h3>
<p>netfilter/iptables（简称为iptables）组成Linux平台下的包过滤防火墙，与大多数的Linux软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换（NAT）等功能。</p>
<p>iptables 5张表5条链</p>
<p>5张表:</p>
<ul>
<li>filter: 过滤某个链上的数据包</li>
<li>nat: 网络地址转换，转换数据包的源地址和目的地址</li>
<li>mangle: 修改数据包的IP头部信息</li>
<li>raw: iptables本身是有状态的，对数据包有链接追踪(/proc/net/nf_conntrack可看到)，raw 可以用来消除这种追踪机制</li>
<li>security: 数据包上使用selinux</li>
</ul>
<p>5条链:</p>
<ul>
<li>PREROUTING: 数据包进入内核网络模块之后, 获得路由之前(可进行DNAT)</li>
<li>INPUT: 数据包被决定路由到本机之后, 一般处理本地进程的数据包, 目的地址是本机</li>
<li>FORWARD: 数据包被决定路由到其他主机之后, 一般处理转发到其它主机/网络命名空间的数据包</li>
<li>OUTPUT: 离开本机的数据包进入内核网络模块之后, 一般处理本地进程的输出数据包, 源地址是本机</li>
<li>POSTROUTING: 对于离开本机或者FORWARD的数据包, 当数据包被发送到网卡之前(可进行SNAT)</li>
</ul>
<p>
  <img src="http://www.iceyao.com.cn/img/posts/2020-02-19/1.png" alt="Fit">

</p>
<h3 id="16-tc">1.6 tc</h3>
<p>tc是Linux内核提供的流量限速、整形和策略控制机制。它以<code>qdisc-class-filter</code>的树形结构来实现对流量的分层控制 ：</p>
<p>tc由<code>qdisc</code>、<code>fitler</code>和<code>class</code>三部分组成：</p>
<ul>
<li><code>qdisc</code>通过队列将数据包缓存起来，用来控制网络收发的速度</li>
<li><code>class</code>用来表示控制策略</li>
<li><code>filter</code>用来将数据包划分到具体的控制策略中</li>
</ul>
<p>网络流量的控制通常发生在输出网卡处，Linux内核中由TC(Traffic Control)实现。TC是利用队列规定建立处理数据包的队列，并定义队列中的数据包被发送的方式，从而实现流量控制。基本原理：</p>
<p>
  <img src="https://www.pianshen.com/images/877/4168e0283f247d275fd8b864219b014d.png" alt="inline">

</p>
<h3 id="17-路由">1.7 路由</h3>
<h4 id="171-静态路由">1.7.1 静态路由</h4>
<p>静态路由是一种路由的方式，路由项由手动配置，而非动态决定。</p>
<p>
  <img src="https://pic1.xuehuaimg.com/proxy/csdn/https://img-blog.csdnimg.cn/20190806171213339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhcmhvaWE=,size_16,color_FFFFFF,t_70" alt="inline">

</p>
<p>linux系统上的路由表</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#ff79c6">[</span>root@lianbang-xuexi-server24 ~<span style="color:#ff79c6">]</span><span style="color:#6272a4"># route -n</span>
</span></span><span style="display:flex;"><span>Kernel IP routing table
</span></span><span style="display:flex;"><span>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
</span></span><span style="display:flex;"><span>0.0.0.0         172.16.87.1     0.0.0.0         UG    <span style="color:#bd93f9">100</span>    <span style="color:#bd93f9">0</span>        <span style="color:#bd93f9">0</span> ens160
</span></span><span style="display:flex;"><span>10.12.0.2       0.0.0.0         255.255.255.255 UH    <span style="color:#bd93f9">0</span>      <span style="color:#bd93f9">0</span>        <span style="color:#bd93f9">0</span> v-hd976c297e
</span></span><span style="display:flex;"><span>10.12.1.0       10.12.1.0       255.255.255.0   UG    <span style="color:#bd93f9">0</span>      <span style="color:#bd93f9">0</span>        <span style="color:#bd93f9">0</span> flannel.1
</span></span></code></pre></div><p>发到127.0.0.1的包怎么没在<code>route -n</code>的路由表体现？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#ff79c6">[</span>root@lianbang-xuexi-server24 ~<span style="color:#ff79c6">]</span><span style="color:#6272a4"># ip route show table local</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">local</span> 10.12.0.0 dev flannel.1 proto kernel scope host src 10.12.0.0
</span></span><span style="display:flex;"><span>broadcast 127.0.0.0 dev lo proto kernel scope link src 127.0.0.1
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">local</span> 127.0.0.0/8 dev lo proto kernel scope host src 127.0.0.1
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">local</span> 127.0.0.1 dev lo proto kernel scope host src 127.0.0.1
</span></span><span style="display:flex;"><span>broadcast 127.255.255.255 dev lo proto kernel scope link src 127.0.0.1
</span></span><span style="display:flex;"><span>broadcast 172.16.87.0 dev ens160 proto kernel scope link src 172.16.87.24
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">local</span> 172.16.87.24 dev ens160 proto kernel scope host src 172.16.87.24
</span></span><span style="display:flex;"><span>broadcast 172.16.87.255 dev ens160 proto kernel scope link src 172.16.87.24
</span></span><span style="display:flex;"><span>broadcast 172.17.0.0 dev docker0 proto kernel scope link src 172.17.0.1
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">local</span> 172.17.0.1 dev docker0 proto kernel scope host src 172.17.0.1
</span></span><span style="display:flex;"><span>broadcast 172.17.255.255 dev docker0 proto kernel scope link src 172.17.0.1
</span></span></code></pre></div><h4 id="172-动态路由">1.7.2 动态路由</h4>
<h5 id="1721-rip">1.7.2.1 RIP</h5>
<p>RIP(Routing Information Protocol,<a href="https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF%E5%8D%8F%E8%AE%AE/2707187">路由信息协议</a>）是一种<a href="https://baike.baidu.com/item/%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE/167192">内部网关协议</a>（IGP），是一种<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9/1250467">动态路由选择</a>协议，用于自治系统（AS）内的路由信息的传递。RIP协议基于距离矢量算法（DistanceVectorAlgorithms），使用“跳数”(即metric)来衡量到达目标地址的路由距离。这种协议的<a href="https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E5%99%A8/108294">路由器</a>只关心自己周围的<a href="https://baike.baidu.com/item/%E4%B8%96%E7%95%8C/24458">世界</a>，只与自己相邻的路由器交换信息，范围限制在15跳(15度)之内，再远，它就不关心了。</p>
<p>
  <img src="https://s4.51cto.com/images/blog/201806/03/506fdf4f4e4f6cade2dbfd55308f89de.jpg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="100%">

</p>
<h5 id="1722-ospf">1.7.2.2 OSPF</h5>
<p>开放式最短路径优先（Open Shortest Path First，OSPF）是广泛使用的一种动态路由协议，它属于链路状态路由协议，具有路由变化收敛速度快、无路由环路、支持变长子网掩码（VLSM）和汇总、层次区域划分等优点。</p>
<p>
  <img src="https://img2020.cnblogs.com/blog/2050139/202007/2050139-20200701193908006-1290678158.png" alt="inline">

</p>
<h5 id="1723-bgp">1.7.2.3 BGP</h5>
<p>BGP（边界网关协议）协议主要用于互联网AS（自治系统）之间的互联，BGP的最主要功能在于控制路由的传播和选择最好的路由。</p>
<p>
  <img src="https://img-blog.csdnimg.cn/20191025114515745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0YXJ0ZXJfX19fXw==,size_16,color_FFFFFF,t_70" alt="inline">

</p>
<p>|         区别          |                OSPF协议                |               BGP协议                |
| :      -: | :            : | :           -: |
|       网关协议        |              内部网关协议              |             外部网关协议             |
| 消除生成树协议（STP） |                   是                   |                  是                  |
|         配置          |                  简单                  |                 复杂                 |
|       收敛时间        |                   短                   |                  长                  |
|       网络结构        |            分层网络拓扑设计            |             网状拓扑设计             |
|     所需设备资源      |        大量内存与密集型CPU资源         | 其路由表的大小决定了其所需的设备资源 |
|       网络规模        | 主要是用于较小规模的网络，可以集中管理 |     通常用于大型网络，例如互联网     |
|         功能          |     最快路由路径优先于最短路由路径     |           确定最佳路由路径           |
|      使用的算法       |              Dijkstra算法              |             最佳路径算法             |
|         协议          |            互联网协议（IP）            |         传输控制协议（TCP）          |</p>
<h4 id="173-策略路由">1.7.3 策略路由</h4>
<p>基于策略的路由比传统路由在功能上更强大，使用更灵活，它使网络管理员不仅能够根据目的地址而且能够根据报文大小，应用或IP源地址等属性来选择转发路径。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ip rule命令：
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Usage: ip rule <span style="color:#ff79c6">[</span> list | add | del <span style="color:#ff79c6">]</span> SELECTOR ACTION （add 添加；del 删除； llist 列表）
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>SELECTOR :<span style="color:#ff79c6">=</span> <span style="color:#ff79c6">[</span> from PREFIX 数据包源地址<span style="color:#ff79c6">]</span> <span style="color:#ff79c6">[</span> to PREFIX 数据包目的地址<span style="color:#ff79c6">]</span> <span style="color:#ff79c6">[</span> tos TOS 服务类型<span style="color:#ff79c6">]</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">[</span> dev STRING 物理接口<span style="color:#ff79c6">]</span> <span style="color:#ff79c6">[</span> pref NUMBER <span style="color:#ff79c6">]</span> <span style="color:#ff79c6">[</span>fwmark MARK iptables 标签<span style="color:#ff79c6">]</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>ACTION :<span style="color:#ff79c6">=</span> <span style="color:#ff79c6">[</span> table TABLE_ID 指定所使用的路由表<span style="color:#ff79c6">]</span> <span style="color:#ff79c6">[</span> nat ADDRESS 网络地址转换<span style="color:#ff79c6">]</span>
</span></span><span style="display:flex;"><span>          <span style="color:#ff79c6">[</span> prohibit 丢弃该表| reject 拒绝该包| unreachable 丢弃该包<span style="color:#ff79c6">]</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span> flowid CLASSID <span style="color:#ff79c6">]</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>TABLE_ID :<span style="color:#ff79c6">=</span> <span style="color:#ff79c6">[</span> <span style="color:#8be9fd;font-style:italic">local</span> | main | default | new | NUMBER <span style="color:#ff79c6">]</span>
</span></span></code></pre></div><p>规则指向路由表，多个规则可以引用一个路由表</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#6272a4">#把源地址为1.2.3.4的数据报的源地址转换为11.22.33.44，并通过表1进行路由</span>
</span></span><span style="display:flex;"><span>ip rule add from 1.2.3.4 nat 11.22.33.44 table <span style="color:#bd93f9">1</span> prio <span style="color:#bd93f9">320</span>
</span></span></code></pre></div><p>查看所有策略路由</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#6272a4"># ip rule show </span>
</span></span><span style="display:flex;"><span>0:      from all lookup <span style="color:#8be9fd;font-style:italic">local</span> 
</span></span><span style="display:flex;"><span>32766:  from all lookup main 
</span></span><span style="display:flex;"><span>32767:  from all lookup default 
</span></span></code></pre></div><p>查看所有路由表</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#ff79c6">[</span>root@lianbang-xuexi-server24 ~<span style="color:#ff79c6">]</span><span style="color:#6272a4"># cat /etc/iproute2/rt_tables</span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#</span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># reserved values</span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#</span>
</span></span><span style="display:flex;"><span>255	<span style="color:#8be9fd;font-style:italic">local</span>
</span></span><span style="display:flex;"><span>254	main
</span></span><span style="display:flex;"><span>253	default
</span></span><span style="display:flex;"><span>0	unspec
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#</span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># local</span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#</span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#1	inr.ruhep</span>
</span></span></code></pre></div><h3 id="18-tunnel">1.8 tunnel</h3>
<p>Overlay网络是建立在已有物理网络上的虚拟网络，具有独立的控制和转发平面，对于连接到Overlay的终端设备（例如服务器）来说，物理网络是透明的</p>
<h4 id="181-gre">1.8.1 gre</h4>
<p>gre: 通用路由封装（Generic Routing Encapsulation），定义了在任意网络层协议上封装其他网络层协议的机制，所以对于 IPv4 和 IPv6 都适用</p>
<p>
  <img src="http://www.m2mlib.com/uploads/article/20171106/595f09271b77def22f78d65debed2c8c.png" alt="GRE、PPTP、L2TP隧道协议对比介绍">

</p>
<p>gre的缺陷：</p>
<p>（1）隧道数量问题</p>
<p>gre是一种点对点实现。所有节点之间都会建立 GRE Tunnel。节点不多的时候，没什么问题。</p>
<p>（2）扩大的广播域</p>
<p>GRE 不支持組播，一个网络（同一个 GRE Tunnel ID）中的一个虚拟机发出一个广播包后，gre会将其广播到所有与该节点有隧道连接的节点</p>
<p>（3）GRE 封裝的IP包的过滤和负载均衡问题</p>
<p>目前还是有很多的防火墙和三层网络设备无法解析 GRE Header，因此它們无法对GRE 封裝包做合适的过滤和负载均衡</p>
<h4 id="182-vxlan">1.8.2 vxlan</h4>
<p>VXLAN（Virtual eXtensible Local Area Network）或许是目前最热门的网络虚拟化技术。网络虚拟化是指在一套物理网络设备上虚拟出多个二层网络。VXLAN由RFC7348定义，这是2014年定稿的一个协议，VXLAN协议将Ethernet帧封装在UDP内，再加上8个字节的VXLAN header，用来标识不同的二层网络。</p>
<p>
  <img src="https://download.huawei.com/mdl/image/download?uuid=7cbc9dea85ca497a8dc89f31d44ccd83" alt="What Is VXLAN - Huawei">

</p>
<p>vxlan通过组播的方式来定位节点</p>
<h4 id="183-ipip">1.8.3 ipip</h4>
<p>ipip: 普通的 IPIP 隧道，就是在报文的基础上再封装成一个 IPv4 报文</p>
<p>
  <img src="https://i.loli.net/2020/01/29/95RPciVgDqtSmNb.jpg" alt="network-ipip-2.jpg">

</p>
<p>ipip vs vxlan ?</p>
<h2 id="2-docker网络">2. docker网络</h2>
<p>Docker 网络架构由 3 个主要部分构成：CNM、Libnetwork 和驱动。</p>
<ul>
<li>CNM 是设计标准。在 CNM 中，规定了 Docker 网络架构的基础组成要素。</li>
<li>Libnetwork 是 CNM 的具体实现，并且被 Docker 采用，Libnetwork 通过 Go 语言编写，并实现了 CNM 中列举的核心组件。</li>
<li>驱动通过实现特定网络拓扑的方式来拓展该模型的能力</li>
</ul>
<p>
  <img src="http://c.biancheng.net/uploads/allimg/190418/4-1Z41Q55633c8.gif" alt="inline">

</p>
<p>CNM 定义了 3 个基本要素：沙盒（Sandbox）、终端（Endpoint）和网络（Network）。</p>
<ul>
<li>沙盒是一个独立的网络栈。其中包括以太网接口、端口、路由表以及 DNS 配置。</li>
<li>终端就是虚拟网络接口。就像普通网络接口一样，终端主要职责是负责创建连接。在 CNM 中，终端负责将沙盒连接到网络。</li>
<li>网络是 802.1d 网桥（类似大家熟知的交换机）的软件实现。因此，网络就是需要交互的终端的集合，并且终端之间相互独立</li>
</ul>
<p>
  <img src="http://c.biancheng.net/uploads/allimg/190418/4-1Z41Q55GJ60.gif" alt="CNM">

</p>
<p>
  <img src="http://c.biancheng.net/uploads/allimg/190418/4-1Z41Q60231L7.gif" alt="控制层、管理层与数据层的关系">

</p>
<h3 id="21-单机通信">2.1 单机通信</h3>
<h4 id="211-bridge模式">2.1.1 bridge模式</h4>
<p>
  <img src="https://img2018.cnblogs.com/blog/1254238/201811/1254238-20181120223907788-1986792101.png" alt="img">

</p>
<h4 id="212-container模式">2.1.2 container模式</h4>
<p>docker在创建容器的时候会指定使用已经存在的容器的网卡设备作为新建容器的网卡设备。这中模式需要注意，由于是多个容器共用同一个eth0</p>
<p>
  <img src="https://img2018.cnblogs.com/blog/1254238/201811/1254238-20181120230818639-1413560441.png" alt="img">

</p>
<h4 id="213-host模式">2.1.3 host模式</h4>
<p>
  <img src="https://img2018.cnblogs.com/blog/1254238/201811/1254238-20181120231410520-860628530.png" alt="img">

</p>
<h4 id="214-none模式">2.1.4 none模式</h4>
<p>这种模式下，容器无法与外界通信，只能使用容器内部的回环(127.0.0.1)在容器内部通信。</p>
<p>
  <img src="https://img2018.cnblogs.com/blog/1254238/201811/1254238-20181120234353025-1330295419.png" alt="img">

</p>
<h3 id="22-跨主机通信">2.2 跨主机通信</h3>
<p>
  <img src="http://mmbiz.qpic.cn/mmbiz_png/Hia4HVYXRicqHpH8y0uwPo7xIHs4UP99pxFCYRJFib59Gqbvn3gP3J3EHCjqhOWaSI4VNmqMwoE38Mrqn5Zat2icwQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片">

</p>
<h2 id="3-k8s网络">3. k8s网络</h2>
<h3 id="31-service">3.1 service</h3>
<p>
  <img src="https://miro.medium.com/max/1400/1*CdyUtG-8CfGu2oFC5s0KwA.png" alt="Kubernetes NodePort vs LoadBalancer vs Ingress? When should I use what? |  by Sandeep Dinesh | Google Cloud - Community | Medium">

</p>
<p>service的更新是由k8s哪个组件负责？</p>
<h4 id="311-userspace模式">3.1.1 userspace模式</h4>
<p>
  <img src="https://d33wubrfki0l68.cloudfront.net/e351b830334b8622a700a8da6568cb081c464a9b/13020/images/docs/services-userspace-overview.svg" alt="Services overview diagram for userspace proxy">

</p>
<p>什么场景用到了这种模式？</p>
<h4 id="312-iptables模式">3.1.2 iptables模式</h4>
<p>
  <img src="https://d33wubrfki0l68.cloudfront.net/27b2978647a8d7bdc2a96b213f0c0d3242ef9ce0/e8c9b/images/docs/services-iptables-overview.svg" alt="Services overview diagram for iptables proxy">

</p>
<h4 id="313-ipvs模式">3.1.3 ipvs模式</h4>
<p>
  <img src="https://d33wubrfki0l68.cloudfront.net/2d3d2b521cf7f9ff83238218dac1c019c270b1ed/9ac5c/images/docs/services-ipvs-overview.svg" alt="Services overview diagram for IPVS proxy">

</p>
<p>ipvs vs iptables?</p>
<h3 id="32-ingress">3.2 ingress</h3>
<p>
  <img src="https://miro.medium.com/max/3970/1*KIVa4hUVZxg-8Ncabo8pdg.png" alt="iT 邦幫忙::一起幫忙解決難題，拯救IT 人的一天">

</p>
<p>从外部访问ingress，流量是从ingress -&gt; service -&gt; pod吗？</p>
<h4 id="321-ingress-controller对比">3.2.1 ingress controller对比</h4>
<p>
  <img src="https://pic2.zhimg.com/80/v2-e11d1a3fef7f0bab2ce64a8f721360bd_1440w.jpg" alt="img">

</p>
<h3 id="33-cni">3.3 cni</h3>
<p>CNI（Container Network Interface）是 CNCF 旗下的一个项目，由一组用于配置 Linux 容器的网络接口的规范和库组成，同时还包含了一些插件。CNI 仅关心容器创建时的网络分配，和当容器被删除时释放网络资源。</p>
<p><a href="https://github.com/containernetworking/plugins/tree/master/plugins">https://github.com/containernetworking/plugins/tree/master/plugins</a></p>
<p>
  <img src="https://feisky.gitbooks.io/sdn/content/container/cni/Chart_Container-Network-Interface-Drivers.png" alt="img">

</p>
<p>
  <img src="https://ucc.alicdn.com/pic/developer-ecology/eb89cb969a514b2e9b2bdcf6273f31f9.png" alt="1.png">

</p>
<h4 id="331-flannel">3.3.1 Flannel</h4>
<p>Flannel是CoreOS团队针对Kubernetes设计的一个网络规划服务</p>
<p>flannel整体架构：</p>
<p><!-- raw HTML omitted -->![](<a href="https://i.ibb.co/4RT1YYP/image.png%22">https://i.ibb.co/4RT1YYP/image.png&quot;</a> alt=&ldquo;image&rdquo; border=&ldquo;0)/&gt;<!-- raw HTML omitted --></p>
<h5 id="3311-udp">3.3.1.1 udp</h5>
<p>多出了flanneld的处理过程，这个过程，使用了flannel0这个TUN设备，仅在发出IP包的过程中就要经过了三次用户态到内核态的数据拷贝（linux的上下文切换代价比较大），所以性能非常差</p>
<p>
  <img src="https://img2018.cnblogs.com/blog/662544/201910/662544-20191022103006305-198547277.png" alt="img">

</p>
<h5 id="3312-host-gw">3.3.1.2 host-gw</h5>
<p>
  <img src="https://img2018.cnblogs.com/blog/662544/201910/662544-20191022103224393-1472403318.png" alt="img">

</p>
<p>节点处于同一个大二层网络</p>
<h5 id="3312-vxlan">3.3.1.2 vxlan</h5>
<p>
  <img src="https://img2018.cnblogs.com/blog/662544/201910/662544-20191022103037567-147724494.png" alt="img">

</p>
<p>vxlan模式的directrouting模式，相当于vxlan+host-gw的结合体</p>
<h5 id="3313-ipip">3.3.1.3 ipip</h5>
<p>性能优于纯vxlan模式，ipip的报头比vxlan报头小</p>
<h5 id="3314-ipsec">3.3.1.4 ipsec</h5>
<p>加密pod间通信</p>
<h4 id="332-calico">3.3.2 Calico</h4>
<p><a href="https://www.projectcalico.org/">Calico</a> 是一个纯三层的数据中心网络方案（不需要 Overlay），并且与 OpenStack、Kubernetes、AWS、GCE 等 IaaS 和容器平台都有良好的集成。</p>
<p>Calico 在每一个计算节点利用 Linux Kernel 实现了一个高效的 vRouter 来负责数据转发，而每个 vRouter 通过 BGP 协议负责把自己上运行的 workload 的路由信息像整个 Calico 网络内传播——小规模部署可以直接互联，大规模下可通过指定的 BGP route reflector 来完成。 这样保证最终所有的 workload 之间的数据流量都是通过 IP 路由的方式完成互联的。Calico 节点组网可以直接利用数据中心的网络结构（无论是 L2 或者 L3），不需要额外的 NAT，隧道或者 Overlay Network。</p>
<p>此外，Calico 基于 iptables 还提供了丰富而灵活的网络 Policy，保证通过各个节点上的 ACLs 来提供 Workload 的多租户隔离、安全组以及其他可达性限制等功能。</p>
<p>
  <img src="https://feisky.gitbooks.io/kubernetes/content/network/calico/calico.png" alt="img">

</p>
<p>Calico 主要由 Felix、etcd、BGP client 以及 BGP Route Reflector 组成</p>
<ol>
<li>Felix，Calico Agent，跑在每台需要运行 Workload 的节点上，主要负责配置路由及 ACLs 等信息来确保 Endpoint 的连通状态；</li>
<li>etcd，分布式键值存储，主要负责网络元数据一致性，确保 Calico 网络状态的准确性；</li>
<li>BGP Client（BIRD）, 主要负责把 Felix 写入 Kernel 的路由信息分发到当前 Calico 网络，确保 Workload 间的通信的有效性；</li>
<li>BGP Route Reflector（BIRD），大规模部署时使用，摒弃所有节点互联的 mesh 模式，通过一个或者多个 BGP Route Reflector 来完成集中式的路由分发。</li>
<li>calico/calico-ipam，主要用作 Kubernetes 的 CNI 插件</li>
</ol>
<h4 id="333-antrea">3.3.3 Antrea</h4>
<p><a href="https://github.com/vmware-tanzu/antrea">Antrea</a> 项目是一个开源的联网解决方案，旨在成为 Kubernetes 原生的网络解决方案。它利用 Open vSwitch 作为网络数据平面。 Open vSwitch 是一个高性能可编程的虚拟交换机，支持 Linux 和 Windows 平台。 Open vSwitch 使 Antrea 能够以高性能和高效的方式实现 Kubernetes 的网络策略。 借助 Open vSwitch 可编程的特性，Antrea 能够在 Open vSwitch 之上实现广泛的联网、安全功能和服务。</p>
<p>![](<a href="https://github.com/antrea-io/antrea/blob/main/docs/assets/antrea_overview.svg.png?raw=true%22">https://github.com/antrea-io/antrea/blob/main/docs/assets/antrea_overview.svg.png?raw=true&quot;</a> alt=&ldquo;antrea_overview.svg.png&rdquo; style=&ldquo;zoom:67%;)/&gt;</p>
<p><a href="https://github.com/antrea-io/antrea/blob/main/docs/design/architecture.md">https://github.com/antrea-io/antrea/blob/main/docs/design/architecture.md</a></p>
<h4 id="334-aws-vpc-cni">3.3.4 AWS VPC CNI</h4>
<p><a href="https://github.com/aws/amazon-vpc-cni-k8s">AWS VPC CNI</a> 为 Kubernetes 集群提供了集成的 AWS 虚拟私有云（VPC）网络。该 CNI 插件提供了高吞吐量和可用性，低延迟以及最小的网络抖动。 此外，用户可以使用现有的 AWS VPC 网络和安全最佳实践来构建 Kubernetes 集群。 这包括使用 VPC 流日志、VPC 路由策略和安全组进行网络流量隔离的功能。</p>
<p>使用该 CNI 插件，可使 Kubernetes Pod 拥有与在 VPC 网络上相同的 IP 地址。 CNI 将 AWS 弹性网络接口（ENI）分配给每个 Kubernetes 节点，并将每个 ENI 的辅助 IP 范围用于该节点上的 Pod 。 CNI 包含用于 ENI 和 IP 地址的预分配的控件，以便加快 Pod 的启动时间，并且能够支持多达 2000 个节点的大型集群。</p>
<p>CNI 可以与 <a href="https://docs.aws.amazon.com/eks/latest/userguide/calico.html">用于执行网络策略的 Calico</a> 一起运行。</p>
<h4 id="335-azure-cni">3.3.5 Azure CNI</h4>
<p><a href="https://docs.microsoft.com/en-us/azure/virtual-network/container-networking-overview">Azure CNI</a> 是一个<a href="https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md">开源插件</a>， 将 Kubernetes Pods 和 Azure 虚拟网络（也称为 VNet）集成在一起，可提供与 VM 相当的网络性能。 Pod 可以通过 Express Route 或者 站点到站点的 VPN 来连接到对等的 VNet ， 也可以从这些网络来直接访问 Pod。Pod 可以访问受服务端点或者受保护链接的 Azure 服务，比如存储和 SQL。 你可以使用 VNet 安全策略和路由来筛选 Pod 流量。 该插件通过利用在 Kubernetes 节点的网络接口上预分配的辅助 IP 池将 VNet 分配给 Pod 。</p>
<h4 id="333-culium">3.3.3 Culium</h4>
<p><a href="https://github.com/cilium/cilium">Cilium </a>是一个基于 eBPF 和 XDP 的高性能容器网络方案，其主要功能特性包括</p>
<ul>
<li>安全上，支持 L3/L4/L7 安全策略，这些策略按照使用方法又可以分为
<ul>
<li>基于身份的安全策略（security identity）</li>
<li>基于 CIDR 的安全策略</li>
<li>基于标签的安全策略</li>
</ul>
</li>
<li>网络上，支持三层平面网络（flat layer 3 network），如
<ul>
<li>覆盖网络（Overlay），包括 VXLAN 和 Geneve 等</li>
<li>Linux 路由网络，包括原生的 Linux 路由和云服务商的高级网络路由等</li>
</ul>
</li>
<li>提供基于 BPF 的负载均衡</li>
<li>提供便利的监控和排错能力</li>
</ul>
<p>
  <img src="https://camo.githubusercontent.com/714c5d777b0025dda66b46f14e28badc01e3e3360ef264be204f54846a7c9573/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f63696c69756d2f63696c69756d406d61737465722f446f63756d656e746174696f6e2f696d616765732f63696c69756d5f6f766572766965772e706e67" alt="https://cdn.jsdelivr.net/gh/cilium/cilium@master/Documentation/images/cilium_overview.png">

</p>
<h5 id="3331-ebpf">3.3.3.1 eBPF</h5>
<p>eBPF（extended Berkeley Packet Filter）起源于BPF，它提供了内核的数据包过滤机制。BPF的基本思想是对用户提供两种SOCKET选项：<code>SO_ATTACH_FILTER</code>和<code>SO_ATTACH_BPF</code>，允许用户在sokcet上添加自定义的filter，只有满足该filter指定条件的数据包才会上发到用户空间。<code>SO_ATTACH_FILTER</code>插入的是cBPF代码，<code>SO_ATTACH_BPF</code>插入的是eBPF代码。eBPF是对cBPF的增强，目前用户端的tcpdump等程序还是用的cBPF版本，其加载到内核中后会被内核自动的转变为eBPF。Linux 3.15 开始引入 eBPF。其扩充了 BPF 的功能，丰富了指令集。它在内核提供了一个虚拟机，用户态将过滤规则以虚拟机指令的形式传递到内核，由内核根据这些指令来过滤网络数据包。</p>
<p>
  <img src="https://feisky.gitbooks.io/sdn/content/container/cilium/bpf.png" alt="img">

</p>
<h5 id="3332-xdp">3.3.3.2 XDP</h5>
<p>XDP（eXpress Data Path）为Linux内核提供了高性能、可编程的网络数据路径。由于网络包在还未进入网络协议栈之前就处理，它给Linux网络带来了巨大的性能提升。XDP 看起来跟 DPDK 比较像，但它比 DPDK 有更多的优点，如</p>
<ul>
<li>无需第三方代码库和许可</li>
<li>同时支持轮询式和中断式网络</li>
<li>无需分配大页</li>
<li>无需专用的CPU</li>
<li>无需定义新的安全网络模型</li>
</ul>
<p>当然，XDP的性能提升是有代价的，它牺牲了通用型和公平性：（1）不提供缓存队列（qdisc），TX设备太慢时直接丢包，因而不要在RX比TX快的设备上使用XDP；（2）XDP程序是专用的，不具备网络协议栈的通用性。</p>
<p><a href="https://github.com/cilium/cilium">https://github.com/cilium/cilium</a></p>
<h4 id="334-cni-ipvlan-vpc-k8s">3.3.4 cni-ipvlan-vpc-k8s</h4>
<p><a href="https://github.com/lyft/cni-ipvlan-vpc-k8s">cni-ipvlan-vpc-k8s</a> 包含了一组 CNI 和 IPAM 插件来提供一个简单的、本地主机、低延迟、高吞吐量 以及通过使用 Amazon 弹性网络接口（ENI）并使用 Linux 内核的 IPv2 驱动程序 以 L2 模式将 AWS 管理的 IP 绑定到 Pod 中， 在 Amazon Virtual Private Cloud（VPC）环境中为 Kubernetes 兼容的网络堆栈。</p>
<p>这些插件旨在直接在 VPC 中进行配置和部署，Kubelets 先启动， 然后根据需要进行自我配置和扩展它们的 IP 使用率，而无需经常建议复杂的管理 覆盖网络、BGP、禁用源/目标检查或调整 VPC 路由表以向每个主机提供每个实例子网的 复杂性（每个 VPC 限制为50-100个条目）。 简而言之，cni-ipvlan-vpc-k8s 大大降低了在 AWS 中大规模部署 Kubernetes 所需的网络复杂性。</p>
<h4 id="335-contiv">3.3.5 Contiv</h4>
<p><a href="https://github.com/contiv/netplugin">Contiv</a> 为各种使用情况提供了一个可配置网络（使用了 BGP 的本地 L3， 使用 vxlan 、经典 L2 或 Cisco-SDN/ACI 的覆盖网络）。 <a href="https://contiv.io/">Contiv</a> 是完全开源的。</p>
<ul>
<li>为同一主机上的容器提供不重叠网络的多租户环境</li>
<li>SDN 应用程序和与 SDN 解决方案的互操作性</li>
<li>与非容器环境的互操作性和到物理网络的切换</li>
<li>与容器相关的策略/ACL/QoS</li>
<li>多播或多目标相关应用程序</li>
<li>与现有 IPAM 工具集成以迁移客户</li>
<li>处理 NIC 的加速功能（SRIOV/Offload/等等）</li>
</ul>
<p><a href="https://github.com/contiv/netplugin">https://github.com/contiv/netplugin</a></p>
<h4 id="336-kube-ovn">3.3.6 kube-ovn</h4>
<p><a href="https://github.com/alauda/kube-ovn">Kube-OVN</a> 是一个基于 OVN 的用于企业的 Kubernetes 网络架构。 借助于 OVN/OVS ，它提供了一些高级覆盖网络功能，例如子网、QoS、静态 IP 分配、流量镜像、网关、 基于 openflow 的网络策略和服务代理。</p>
<p>
  <img src="https://github.com/kubeovn/kube-ovn/raw/master/docs/ovn-network-topology.png" alt="topology">

</p>
<p>多网卡模式(借助multus实现)</p>
<p>
  <img src="https://github.com/kubeovn/kube-ovn/raw/master/docs/multi-nic.png" alt="topology">

</p>
<h4 id="337-kube-router">3.3.7 kube-router</h4>
<p><a href="https://github.com/cloudnativelabs/kube-router">Kube-router</a> 是 Kubernetes 的专用网络解决方案， 旨在提供高性能和易操作性。 Kube-router 提供了一个基于 Linux <a href="https://www.linuxvirtualserver.org/software/ipvs.html">LVS/IPVS</a> 的服务代理、一个基于 Linux 内核转发的无覆盖 Pod-to-Pod 网络解决方案和基于 iptables/ipset 的网络策略执行器。</p>
<p>
  <img src="https://github.com/cloudnativelabs/kube-router/raw/master/docs/img/kube-router-arch.png" alt="Arch">

</p>
<h4 id="338-romana">3.3.8 Romana</h4>
<p><a href="https://romana.io/">Romana</a> 是一个开源网络和安全自动化解决方案。 它可以让你在没有覆盖网络的情况下部署 Kubernetes。 Romana 支持 Kubernetes <a href="https://kubernetes.io/zh/docs/concepts/services-networking/network-policies/">网络策略</a>， 来提供跨网络命名空间的隔离。可以运行BGP或OSPF</p>
<h4 id="339-weave-net">3.3.9 Weave Net</h4>
<p>Weave Net是一个多主机容器网络方案，支持去中心化的控制平面，各个host上的wRouter间通过建立Full Mesh的TCP链接，并通过Gossip协议来同步控制信息。这种方式省去了集中式的K/V Store，能够在一定程度上减低部署的复杂性，Weave将其称为“data centric”</p>
<p>数据平面上，Weave通过UDP封装实现L2 Overlay，封装支持两种模式：</p>
<ul>
<li>运行在user space的sleeve mode：通过pcap设备在Linux bridge上截获数据包并由wRouter完成UDP封装，支持对L2 traffic进行加密，还支持Partial Connection，但是性能损失明显。</li>
<li>运行在kernal space的 fastpath mode：即通过OVS的odp封装VxLAN并完成转发，wRouter不直接参与转发，而是通过下发odp 流表的方式控制转发，这种方式可以明显地提升吞吐量，但是不支持加密等高级功能。</li>
</ul>
<p>
  <img src="https://user-images.githubusercontent.com/11160747/36148997-cfd44de8-10df-11e8-94b9-6d68db7b3a24.png" alt="Weave-net always renders one node unhealthy in the cluster · Issue #3243 ·  weaveworks/weave · GitHub">

</p>
<h4 id="3310-canal">3.3.10 Canal</h4>
<p><a href="https://github.com/tigera/canal">Canal</a> 是 Flannel 和 Calico 联合发布的一个统一网络插件，提供 CNI 网络插件，并支持 network policy。</p>
<p>
  <img src="https://github.com/projectcalico/canal/blob/master/Canal%20Phase%201%20Diagram.png?raw=true" alt="Canal Phase 1 Diagram.png">

</p>
<h4 id="3311-danm多cni">3.3.11 danm(多cni)</h4>
<p><a href="https://github.com/nokia/danm">DANM</a> 是一个针对在 Kubernetes 集群中运行的电信工作负载的网络解决方案。 它由以下几个组件构成：</p>
<ul>
<li>能够配置具有高级功能的 IPVLAN 接口的 CNI 插件</li>
<li>一个内置的 IPAM 模块，能够管理多个、群集内的、不连续的 L3 网络，并按请求提供动态、静态或无 IP 分配方案</li>
<li>CNI 元插件能够通过自己的 CNI 或通过将任务授权给其他任何流行的 CNI 解决方案（例如 SRI-OV 或 Flannel）来实现将多个网络接口连接到容器</li>
<li>Kubernetes 控制器能够集中管理所有 Kubernetes 主机的 VxLAN 和 VLAN 接口</li>
<li>另一个 Kubernetes 控制器扩展了 Kubernetes 的基于服务的服务发现概念，以在 Pod 的所有网络接口上工作</li>
</ul>
<p>通过这个工具集，DANM 可以提供多个分离的网络接口，可以为 Pod 使用不同的网络后端和高级 IPAM 功能。</p>
<p><a href="https://github.com/nokia/danm">https://github.com/nokia/danm</a></p>
<h4 id="3312-multus多cni">3.3.12 multus(多cni)</h4>
<p><a href="https://github.com/Intel-Corp/multus-cni">Multus</a> 是一个多 CNI 插件， 使用 Kubernetes 中基于 CRD 的网络对象来支持实现 Kubernetes 多网络系统。</p>
<p>Multus 支持所有<a href="https://github.com/containernetworking/plugins">参考插件</a>（比如： <a href="https://github.com/containernetworking/plugins/tree/master/plugins/meta/flannel">Flannel</a>、 <a href="https://github.com/containernetworking/plugins/tree/master/plugins/ipam/dhcp">DHCP</a>、 <a href="https://github.com/containernetworking/plugins/tree/master/plugins/main/macvlan">Macvlan</a> ） 来实现 CNI 规范和第三方插件（比如： <a href="https://github.com/projectcalico/cni-plugin">Calico</a>、 <a href="https://github.com/weaveworks/weave">Weave</a>、 <a href="https://github.com/cilium/cilium">Cilium</a>、 <a href="https://github.com/contiv/netplugin">Contiv</a>）。 除此之外， Multus 还支持 <a href="https://github.com/hustcat/sriov-cni">SRIOV</a>、 <a href="https://github.com/Intel-Corp/sriov-cni">DPDK</a>、 <a href="https://github.com/intel/vhost-user-net-plugin">OVS-DPDK &amp; VPP</a> 的工作负载， 以及 Kubernetes 中基于云的本机应用程序和基于 NFV 的应用程序。</p>
<p>
  <img src="https://github.com/k8snetworkplumbingwg/multus-cni/raw/master/docs/images/multus-pod-image.svg" alt="multus-pod-image">

</p>
<p>缺少一个cluster-wide ipam（https://github.com/k8snetworkplumbingwg/whereabouts）</p>
<h4 id="3313-cni-genie多cni">3.3.13 cni-genie(多cni)</h4>
<p><a href="https://github.com/Huawei-PaaS/CNI-Genie">CNI-Genie</a> 是一个 CNI 插件， 可以让 Kubernetes 在运行时使用不同的<a href="https://kubernetes.io/zh/docs/concepts/cluster-administration/networking/#the-kubernetes-network-model">网络模型</a>的 <a href="https://github.com/Huawei-PaaS/CNI-Genie/blob/master/docs/multiple-cni-plugins/README.md#what-cni-genie-feature-1-multiple-cni-plugins-enables">实现同时被访问</a>。 这包括以 <a href="https://github.com/containernetworking/cni#3rd-party-plugins">CNI 插件</a>运行的任何实现，比如 <a href="https://github.com/coreos/flannel#flannel">Flannel</a>、 <a href="https://docs.projectcalico.org/">Calico</a>、 <a href="https://romana.io/">Romana</a>、 <a href="https://www.weave.works/products/weave-net/">Weave-net</a>。</p>
<p>CNI-Genie 还支持<a href="https://github.com/Huawei-PaaS/CNI-Genie/blob/master/docs/multiple-ips/README.md#feature-2-extension-cni-genie-multi-ip-addresses-per-pod">将多个 IP 地址分配给 Pod</a>， 每个都来自不同的 CNI 插件。</p>
<p>
  <img src="https://github.com/huawei-cloudnative/CNI-Genie/raw/master/docs/multiple-cni-plugins/what-cni-genie.png" alt="image">

</p>
<p><a href="https://github.com/huawei-cloudnative/CNI-Genie">https://github.com/huawei-cloudnative/CNI-Genie</a></p>
<h4 id="3314-galaxy多cni">3.3.14 galaxy(多cni)</h4>
<p>Galaxy 是一个 Kubernetes 网络项目，旨在为 Pod 提供覆盖和高性能的底层网络。并且它还实现了浮动IP（或弹性IP），即pod的IP即使由于节点崩溃而浮动到另一个节点上也不会改变，这有利于运行有状态的集合应用程序。</p>
<p>目前，它由三个组件组成 - Galaxy、CNI 插件和 Galaxy IPAM。 Galaxy 是一个运行在每个 kubelet 节点上的守护进程，它调用不同类型的 CNI 插件来为 pod 设置所需的网络。 Galaxy IPAM 是一个 Kubernetes 调度程序插件，可用作浮动 IP 配置和分配管理器。</p>
<p>Galaxy 与 CNI 规范兼容，可以通过安装 CNI 二进制文件和更新将任何 CNI 插件与它集成.</p>
<p>
  <img src="https://github.com/tkestack/galaxy/raw/master/doc/image/galaxy-ipam.png" alt="How galaxy-ipam works">

</p>
<p>
  <img src="https://github.com/tkestack/galaxy/raw/master/doc/image/galaxy-ipam-scheduling-process.png" alt="How galaxy ipam allocates IP according to network typology">

</p>
<p><a href="https://github.com/tkestack/galaxy">https://github.com/tkestack/galaxy</a></p>
<h3 id="34-network-policy">3.4 network policy</h3>
<p>随着微服务的流行，越来越多的云服务平台需要大量模块之间的网络调用。Kubernetes 在 1.3 引入了 Network Policy，Network Policy 提供了基于策略的网络控制，用于隔离应用并减少攻击面。它使用标签选择器模拟传统的分段网络，并通过策略控制它们之间的流量以及来自外部的流量。</p>
<p>在使用 Network Policy 时，需要注意</p>
<ul>
<li>v1.6 以及以前的版本需要在 kube-apiserver 中开启 <code>extensions/v1beta1/networkpolicies</code></li>
<li>v1.7 版本 Network Policy 已经 GA，API 版本为 <code>networking.k8s.io/v1</code></li>
<li>v1.8 版本新增 <strong>Egress</strong> 和 <strong>IPBlock</strong> 的支持</li>
<li>网络插件要支持 Network Policy，如 Calico、Romana、Weave Net 和 trireme 等</li>
</ul>
<h3 id="35-性能对比">3.5 性能对比</h3>
<p>
  <img src="http://team.jiunile.com/images/k8s/cni_18.png" alt="Kubernetes 网络插件在超过10Gbit/s 下的基准测试结果| CloudNative 架构">

</p>
<p><a href="https://zhuanlan.zhihu.com/p/230774496">https://zhuanlan.zhihu.com/p/230774496</a></p>
<h2 id="4-容器网络的本质">4. 容器网络的本质</h2>
<p>network namespace + 网络设备 + 网络协议的组合</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>node1 192.168.104.111
</span></span><span style="display:flex;"><span>node2 192.168.104.128
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>        +        -+               +        -+
</span></span><span style="display:flex;"><span>        |                         |               |                         |
</span></span><span style="display:flex;"><span>        |      +    +     |               |      +    +     |
</span></span><span style="display:flex;"><span>        |      |            |     |               |      |            |     |
</span></span><span style="display:flex;"><span>        |      |  3.3.3.4   |     |               |      |   3.3.3.3  |     |
</span></span><span style="display:flex;"><span>        |      +    +     |               |      +    +     |
</span></span><span style="display:flex;"><span>        |            |eth0        |               |            |eth0        |
</span></span><span style="display:flex;"><span>        |            |            |               |            |            |
</span></span><span style="display:flex;"><span>        |            +veth1       |               |            +veth1       |
</span></span><span style="display:flex;"><span>        |      +    +     |               |      +    +     |
</span></span><span style="display:flex;"><span>        |      |            |     |               |      |            |     |
</span></span><span style="display:flex;"><span>        |      |    br1     |     |               |      |    br1     |     |
</span></span><span style="display:flex;"><span>        |      + --+  +     |               |      + --+  +     |
</span></span><span style="display:flex;"><span>        |            |            |               |            |            |
</span></span><span style="display:flex;"><span>        |            |            |               |            |            |
</span></span><span style="display:flex;"><span>        |      + --+  +     |               |      + --+  +     |
</span></span><span style="display:flex;"><span>        |      |   vxlan100 |     |               |      |   vxlan100 |     |
</span></span><span style="display:flex;"><span>        |      |            |     |               |      |            |     |
</span></span><span style="display:flex;"><span>        |      + --+  +     |               |      + --+  +     |
</span></span><span style="display:flex;"><span>        |            |            |               |            |            |
</span></span><span style="display:flex;"><span>        |            |            |               |            |            |
</span></span><span style="display:flex;"><span>node2   |            | eth0       |               |            | eth0       | node1
</span></span><span style="display:flex;"><span>        +        -+               +        -+
</span></span><span style="display:flex;"><span>                     | 192.168.104.128          192.168.104.111|
</span></span><span style="display:flex;"><span>                     |                                         |
</span></span><span style="display:flex;"><span>                     |                                         |
</span></span><span style="display:flex;"><span>         +   --+             --+     +
</span></span></code></pre></div><p>node1</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sysctl -w net.ipv4.ip_forward<span style="color:#ff79c6">=</span><span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#创建命名空间</span>
</span></span><span style="display:flex;"><span>ip netns add test1
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#创建veth设备</span>
</span></span><span style="display:flex;"><span>ip link add veth1 <span style="color:#8be9fd;font-style:italic">type</span> veth peer name eth0 netns test1
</span></span><span style="display:flex;"><span>ip netns <span style="color:#8be9fd;font-style:italic">exec</span> test1 ip link <span style="color:#8be9fd;font-style:italic">set</span> eth0 up
</span></span><span style="display:flex;"><span>ip netns <span style="color:#8be9fd;font-style:italic">exec</span> test1 ip link <span style="color:#8be9fd;font-style:italic">set</span> lo up
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#命名空间里的eth0配置ip</span>
</span></span><span style="display:flex;"><span>ip netns <span style="color:#8be9fd;font-style:italic">exec</span> test1 ip addr add 3.3.3.3/24 dev eth0
</span></span><span style="display:flex;"><span>ip link <span style="color:#8be9fd;font-style:italic">set</span> up dev veth1
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#创建br1 bridge</span>
</span></span><span style="display:flex;"><span>ip link add br1 <span style="color:#8be9fd;font-style:italic">type</span> bridge
</span></span><span style="display:flex;"><span>ip link <span style="color:#8be9fd;font-style:italic">set</span> br1 up
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#veth1加入br1 bridge</span>
</span></span><span style="display:flex;"><span>ip link <span style="color:#8be9fd;font-style:italic">set</span> veth1 master br1
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#指定了nolearning来禁用源地址学习, 通过ip -d a可以看到设备属性</span>
</span></span><span style="display:flex;"><span>ip link add vxlan100 <span style="color:#8be9fd;font-style:italic">type</span> vxlan id <span style="color:#bd93f9">100</span> dstport <span style="color:#bd93f9">4789</span> <span style="color:#8be9fd;font-style:italic">local</span> 192.168.104.111 nolearning
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#vxlan100加入br1 bridge</span>
</span></span><span style="display:flex;"><span>ip link <span style="color:#8be9fd;font-style:italic">set</span> vxlan100 master br1
</span></span><span style="display:flex;"><span>ip link <span style="color:#8be9fd;font-style:italic">set</span> up vxlan100
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#添加的是对端的mac地址和ip</span>
</span></span><span style="display:flex;"><span>bridge fdb append 86:a7:37:e5:4f:e0 dev vxlan100 dst 192.168.104.128
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#添加vxlan设备arp代答</span>
</span></span><span style="display:flex;"><span>ip neighbor add 3.3.3.4 lladdr 86:a7:37:e5:4f:e0 dev vxlan100
</span></span></code></pre></div><p>node2</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sysctl -w net.ipv4.ip_forward<span style="color:#ff79c6">=</span><span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#创建命名空间</span>
</span></span><span style="display:flex;"><span>ip netns add test1
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#创建veth设备</span>
</span></span><span style="display:flex;"><span>ip link add veth1 <span style="color:#8be9fd;font-style:italic">type</span> veth peer name eth0 netns test1
</span></span><span style="display:flex;"><span>ip netns <span style="color:#8be9fd;font-style:italic">exec</span> test1 ip link <span style="color:#8be9fd;font-style:italic">set</span> eth0 up
</span></span><span style="display:flex;"><span>ip netns <span style="color:#8be9fd;font-style:italic">exec</span> test1 ip link <span style="color:#8be9fd;font-style:italic">set</span> lo up
</span></span><span style="display:flex;"><span>ip netns <span style="color:#8be9fd;font-style:italic">exec</span> test1 ip addr add 3.3.3.4/24 dev eth0
</span></span><span style="display:flex;"><span>ip link <span style="color:#8be9fd;font-style:italic">set</span> up dev veth1
</span></span><span style="display:flex;"><span>ip link add br1 <span style="color:#8be9fd;font-style:italic">type</span> bridge
</span></span><span style="display:flex;"><span>ip link <span style="color:#8be9fd;font-style:italic">set</span> br1 up
</span></span><span style="display:flex;"><span>ip link <span style="color:#8be9fd;font-style:italic">set</span> veth1 master br1 
</span></span><span style="display:flex;"><span>ip link add vxlan100 <span style="color:#8be9fd;font-style:italic">type</span> vxlan id <span style="color:#bd93f9">100</span> dstport <span style="color:#bd93f9">4789</span> <span style="color:#8be9fd;font-style:italic">local</span> 192.168.104.128 nolearning
</span></span><span style="display:flex;"><span>ip link <span style="color:#8be9fd;font-style:italic">set</span> vxlan100 master br1
</span></span><span style="display:flex;"><span>ip link <span style="color:#8be9fd;font-style:italic">set</span> up vxlan100
</span></span><span style="display:flex;"><span>bridge fdb append ea:da:ea:f7:13:be dev vxlan100 dst 192.168.104.111
</span></span><span style="display:flex;"><span><span style="color:#6272a4">#添加vxlan设备arp代答</span>
</span></span><span style="display:flex;"><span>ip neighbor add 3.3.3.3 lladdr ea:da:ea:f7:13:be dev vxlan100
</span></span></code></pre></div><h2 id="5-当前现状">5. 当前现状</h2>
<h3 id="51-内部">5.1 内部</h3>
<p>![](<a href="https://i.ibb.co/0KVnLzt/9b535e06-3ee6-4819-9ba2-a19a45840f1e.png%22">https://i.ibb.co/0KVnLzt/9b535e06-3ee6-4819-9ba2-a19a45840f1e.png&quot;</a> alt=&ldquo;9b535e06-3ee6-4819-9ba2-a19a45840f1e)border=&ldquo;0&rdquo;&gt;</p>
<h2 id="6-我们的选择会是什么">6. 我们的选择会是什么?</h2>
<p>考虑的维度？</p>
<ul>
<li>ToB变化的场景 - 多插件模式</li>
<li>网络链路加密 - (pod-pod、node-node、pod-service)</li>
<li>可控</li>
</ul>
<h2 id="7-容器网络未来展望">7. 容器网络未来展望</h2>
<ol>
<li><strong>容器网络方案方面</strong>，考虑将SDN、微服务与容器网络相结合，实现更加高效便捷的一体化管理</li>
<li>**容器网络安全方面，**考虑研究容器网络的安全管理模式</li>
<li><strong>容器网络可观测性方面</strong></li>
</ol>
<blockquote>
<p>从谷歌分享的网络排错案例中可以看到，即便是作为全球三大公有云平台之一，也需要执行大量的工具和命令来逐步定位网络问题的根源。并且在很多时候，还需要客户自己来重现问题，才能拿到第一手的调试数据。这一方面说明了网络问题的复杂性，另一方面也说明在网络排错、调试、监控等方面还有很多可以改进的空间。如果这些问题解决的出色，相应的网络方案很可能就会一跃而起，成为新的流行技术。</p>
<p>在这方面，Cilium 可以说是一个典型代表。Cilium 不仅需要较新的内核，还会通过 eBPF 机制在内核中注入包括观测、安全、过滤等在内的一系列网络机制。但这并没有阻止 Cilium 的流行。很多其他的网络方案也在借鉴 Cilium 的原理，借助 eBPF 加速网络性能，并实现更透明的网络观测机制。</p>
</blockquote>
<h2 id="8-定位问题小工具">8. 定位问题小工具</h2>
<h3 id="81-nsenter">8.1 nsenter</h3>
<p>nsenter命令是一个可以在指定进程的命令空间下运行指定程序的命令, 可以进入该容器的网络命名空间</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#ff79c6">function</span> e<span style="color:#ff79c6">()</span> <span style="color:#ff79c6">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">set</span> -eu
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">ns</span><span style="color:#ff79c6">=</span><span style="color:#f1fa8c">${</span><span style="color:#8be9fd;font-style:italic">2</span>-<span style="color:#f1fa8c">&#34;default&#34;</span><span style="color:#f1fa8c">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">pod</span><span style="color:#ff79c6">=</span><span style="color:#f1fa8c">`</span>kubectl -n <span style="color:#8be9fd;font-style:italic">$ns</span> describe pod <span style="color:#8be9fd;font-style:italic">$1</span> | grep -Eo <span style="color:#f1fa8c">&#39;docker://.*$&#39;</span> | head -n <span style="color:#bd93f9">1</span> | sed <span style="color:#f1fa8c">&#39;s/docker:\/\/\(.*\)$/\1/&#39;</span><span style="color:#f1fa8c">`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">pid</span><span style="color:#ff79c6">=</span><span style="color:#f1fa8c">`</span>docker inspect -f <span style="color:#ff79c6">{{</span>.State.Pid<span style="color:#ff79c6">}}</span> <span style="color:#8be9fd;font-style:italic">$pod</span><span style="color:#f1fa8c">`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">echo</span> <span style="color:#f1fa8c">&#34;enter pod netns successfully for </span><span style="color:#8be9fd;font-style:italic">$ns</span><span style="color:#f1fa8c">/</span><span style="color:#8be9fd;font-style:italic">$1</span><span style="color:#f1fa8c">&#34;</span>
</span></span><span style="display:flex;"><span>    nsenter -n --target <span style="color:#8be9fd;font-style:italic">$pid</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#6272a4"># e pv-local-pod</span>
</span></span><span style="display:flex;"><span>entering pod netns <span style="color:#ff79c6">for</span> default/pv-local-pod
</span></span><span style="display:flex;"><span>nsenter -n --target <span style="color:#bd93f9">1991</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>root@lianbang-xuexi-server24 ~<span style="color:#ff79c6">]</span><span style="color:#6272a4">#</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>root@lianbang-xuexi-server24 ~<span style="color:#ff79c6">]</span><span style="color:#6272a4"># ip a</span>
</span></span><span style="display:flex;"><span>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span style="color:#bd93f9">65536</span> qdisc noqueue state UNKNOWN qlen <span style="color:#bd93f9">1000</span>
</span></span><span style="display:flex;"><span>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span style="display:flex;"><span>    inet 127.0.0.1/8 scope host lo
</span></span><span style="display:flex;"><span>       valid_lft forever preferred_lft forever
</span></span><span style="display:flex;"><span>103: eth0@if104: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span style="color:#bd93f9">1450</span> qdisc noqueue state UP
</span></span><span style="display:flex;"><span>    link/ether 8e:c7:e3:77:20:ce brd ff:ff:ff:ff:ff:ff link-netnsid <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>    inet 10.12.0.49/32 brd 10.12.0.49 scope global eth0
</span></span><span style="display:flex;"><span>       valid_lft forever preferred_lft forever
</span></span></code></pre></div><h3 id="82-tcpdump">8.2 tcpdump</h3>
<p><strong>tcpdump</strong> 是一个Unix下一个功能强大的网络抓包工具，它允许用户拦截和显示发送或收到过网络连接到该计算机的TCP/IP和其他数据包，可用于大多数的类Unix系统：包括Linux、Solaris、BSD、Mac OS X、HP-UX和AIX 等等。一般使用tcpdump+wireshark组合的方式，tcpdump是命令行方式，wireshark是gui方式</p>
<p>
  <img src="https://www.wireshark.org/docs/wsug_html_chunked/wsug_graphics/ws-time-reference.png" alt="6.12. Time Display Formats And Time References">

</p>
<p>
  <img src="http://www.iceyao.com.cn/img/posts/2020-12-12/tcp-ip.png" alt="img">

</p>
<p>
  <img src="http://www.iceyao.com.cn/img/posts/2020-12-12/tcp-ip-status.png" alt="img">

</p>
<h3 id="83-ping">8.3 ping</h3>
<p>Ping是工作在[ TCP/IP](<a href="https://baike.baidu.com/item/">https://baike.baidu.com/item/</a> TCP%2FIP/214077)网络体系结构中<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E5%B1%82/16412033">应用层</a>的一个服务命令， 主要是向特定的目的主机发送[ ICMP](<a href="https://baike.baidu.com/item/">https://baike.baidu.com/item/</a> ICMP/572452)（Internet Control Message Protocol 因特网报文控制协议）<a href="https://baike.baidu.com/item/Echo/35157">Echo</a> 请求报文，测试目的站是否可达及了解其有关状态</p>
<h3 id="84-telnet">8.4 telnet</h3>
<p>telnet是远程连接服务，它工作于在tcp/ip协议的应用层。检测tcp服务</p>
<h3 id="85-nc">8.5 nc</h3>
<p>netcat是网络工具中的瑞士军刀，它能通过TCP和UDP在网络中读写数据。不仅可以检测tcp/udp服务，而且还可以变成tcp/udp的server</p>
<h2 id="9-qa">9. Q&amp;A</h2>


                
                
<div class="entry-shang text-center">
    
	    <p>「真诚赞赏，手留余香」</p>
	
	<button class="zs show-zs btn btn-bred">赞赏支持</button>
</div>
<div class="zs-modal-bg"></div>
<div class="zs-modal-box">
	<div class="zs-modal-head">
		<button type="button" class="close">×</button>
		<span class="author"><a href="https://www.iceyao.com.cn/"><img src="/img/favicon.png" />爱折腾的工程师</a></span>
        
	        <p class="tip"><i></i><span>真诚赞赏，手留余香</span></p>
		
 
	</div>
	<div class="zs-modal-body">
		<div class="zs-modal-btns">
			<button class="btn btn-blink" data-num="2">2元</button>
			<button class="btn btn-blink" data-num="5">5元</button>
			<button class="btn btn-blink" data-num="10">10元</button>
			<button class="btn btn-blink" data-num="50">50元</button>
			<button class="btn btn-blink" data-num="100">100元</button>
			<button class="btn btn-blink" data-num="1">任意金额</button>
		</div>
		<div class="zs-modal-pay">
			<button class="btn btn-bred" id="pay-text">2元</button>
			<p>使用<span id="pay-type">微信</span>扫描二维码完成支付</p>
			<img src="/img/reward/wechat-2.png"  id="pay-image"/>
		</div>
	</div>
	<div class="zs-modal-footer">
		<label><input type="radio" name="zs-type" value="wechat" class="zs-type" checked="checked"><span ><span class="zs-wechat"><img src="/img/reward/wechat-btn.png"/></span></label>
		<label><input type="radio" name="zs-type" value="alipay" class="zs-type" class="zs-alipay"><img src="/img/reward/alipay-btn.png"/></span></label>
	</div>
</div>
<script type="text/javascript" src="/js/reward.js"></script>

                

                
                <hr>
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/post/2021-05-11-openstack_train_note/" data-toggle="tooltip" data-placement="top" title="OpenStack Train实践（纯操作）">&larr;
                            Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/post/2021-08-31-prototype_learing_note/" data-toggle="tooltip" data-placement="top" title="画产品原型图学习笔记">Next
                            Post &rarr;</a>
                    </li>
                    
                </ul>
                

                


<script src="https://giscus.app/client.js"
        data-repo="yaoice/yaoice.github.io"
        data-repo-id="R_kgDOJnxqVg"
        data-category="General"
        data-category-id="DIC_kwDOJnxqVs4CWwUs"
        data-mapping="pathname"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-theme="light"
        data-lang="en"
        crossorigin="anonymous"
        async>
</script>


            </div>

            
            
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
            

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                        
                        
                        
                        
                        
                        <a href="/tags/devops" title="devops">
                            devops
                        </a>
                        
                        
                        
                        <a href="/tags/go" title="go">
                            go
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/k8s" title="k8s">
                            k8s
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/llm" title="llm">
                            llm
                        </a>
                        
                        
                        
                        <a href="/tags/openstack" title="openstack">
                            openstack
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/tkestack" title="tkestack">
                            tkestack
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/%E7%BB%83%E8%BD%A6" title="练车">
                            练车
                        </a>
                        
                        
                    </div>
                </section>
                

                
                
            </div>
        </div>
    </div>
</article>









<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">                  
                    
                    <li>
                        <a href="mailto:yao3690093@gmail.com">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		           
                    
                    
                    
                    

		            
                    
                    <li>
                        <a target="_blank" href="/img/wechat.jpeg">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-weixin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		            
                    
                    <li>
                        <a target="_blank" href="https://github.com/yaoice">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		            
                    
                    
                    
                    
                    
                    
                    
                    
                    
            
            
            
           
                   <li>
                       <a href="/index.xml" rel="alternate" type="application/rss+xml" title="爱折腾的工程师" >
                           <span class="fa-stack fa-lg">
                               <i class="fas fa-circle fa-stack-2x"></i>
                               <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                           </span>
                       </a>
                   </li>
            
             </ul>
		<p class="copyright text-muted">
                    Copyright &copy; 爱折腾的工程师 2024
                </p>
            </div>
        </div>
    </div>
</footer>




<script>
    function loadAsync(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>






<script>
    
    if($('#tag_cloud').length !== 0){
        loadAsync("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>


<script>
    loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>



<script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https'){
       bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else{
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>


<script>
    
    var _baId = '92c175994ded75a3cd2074bc1123e2be';

    
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>




<script type="text/javascript">
    function generateCatalog(selector) {

        
        
        
        
            _containerSelector = 'div.post-container'
        

        
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        
        $(selector).html('')

        
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    
    $(".catalog-toggle").click((function (e) {
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    


    loadAsync("\/js\/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>







</body>
</html>
