<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    

    
    <meta property="og:site_name" content="爱折腾的工程师">
    <meta property="og:type" content="article">

    
    <meta property="og:image" content="https://www.iceyao.com.cn//img/post-bg-unix-linux.jpg">
    <meta property="twitter:image" content="https://www.iceyao.com.cn//img/post-bg-unix-linux.jpg" />
    

    
    <meta name="title" content="Golang知识点大杂烩" />
    <meta property="og:title" content="Golang知识点大杂烩" />
    <meta property="twitter:title" content="Golang知识点大杂烩" />
    

    
    <meta name="description" content="Golang知识点大杂烩">
    <meta property="og:description" content="Golang知识点大杂烩" />
    <meta property="twitter:description" content="Golang知识点大杂烩" />
    

    
    <meta property="twitter:card" content="summary" />
    
    

    <meta name="keyword"  content="iceyao, IceYao&#39;s Blog, 博客, 个人网站, 互联网, Web, 云原生, PaaS, Istio, Kubernetes, 微服务, Microservice">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>Golang知识点大杂烩 | 爱折腾的工程师 | IceYao&#39;s Blog</title>

    <link rel="canonical" href="/2024/08/09/golang-knowledge/">

    

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css">

    
    <link rel="stylesheet" href="/css/hugo-theme-cleanwhite.min.css">

    
    <link rel="stylesheet" href="/css/zanshang.css">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css">

    
    

    
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script>

    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js"></script>

    
    <script src="/js/hux-blog.min.js"></script>

    
    <script src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script>

    
    

</head>



  
    
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-9J7CKFVPPM"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-9J7CKFVPPM');
        }
      </script>
    
  







<nav class="navbar navbar-default navbar-custom navbar-fixed-top">

    <div class="container-fluid">
        
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">爱折腾的工程师</a>
        </div>

        
        
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">All Posts</a>
                    </li>
                    
                        
                    
                    
		    
                        <li><a href="/archive//">ARCHIVE</a></li>
                    
                        <li><a href="/notes//">NOTES</a></li>
                    
                        <li><a href="/about//">ABOUT</a></li>
                    
		            <li>
                        <a href="/search"><i class="fa fa-search"></i></a>
		           </li>
                </ul>
            </div>
        </div>
        
    </div>
    
</nav>
<script>
    
    
    
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        
            $navbar.className = " ";
            
            setTimeout(function(){
                
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>




<style type="text/css">
    header.intro-header {
        background-image: url('/img/post-bg-unix-linux.jpg')
    }
</style>

<header class="intro-header" >

    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/go" title="Go">
                            Go
                        </a>
                        
                    </div>
                    <h1>Golang知识点大杂烩</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        
                            Posted by 
                            
                                iceyao
                             
                            on 
                            Sunday, August 9, 2020
                            
                            
                            
                            
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>




<article>
    <div class="container">
        <div class="row">

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                
                <h1 id="defer-7个知识点">defer 7个知识点</h1>
<ol>
<li>defer的执行顺序：有多个defer的时候，是按照栈的关系来执行</li>
<li>defer与return谁先谁后：return之后的语句先执行，defer后的语句后执行</li>
<li>函数的返回值初始化与defer间接影响：只要声明函数的返回值变量名称，就会在函数初始化时候为之赋值为0，而且在函数体作用域可见</li>
<li>有名函数返回值遇见defer情况：通过知识点2得知，先return，再defer，所以在执行完return之后，还要再执行defer里的语句，依然可以修改本应该返回的结果</li>
<li>defer遇见panic：遇到panic时，遍历本协程的defer链表，并执行defer。在执行defer过程中:遇到recover则停止panic，返回recover处继续往下执行。如果没有遇到recover，遍历完本协程的defer链表后，向stderr抛出panic信息</li>
<li>defer中包含panic：panic仅有最后一个可以被revover捕获</li>
<li>defer下的函数参数包含子函数
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">function</span>(index <span style="color:#8be9fd">int</span>, value <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">int</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(index)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> index
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">defer</span> <span style="color:#50fa7b">function</span>(<span style="color:#bd93f9">1</span>, <span style="color:#50fa7b">function</span>(<span style="color:#bd93f9">3</span>, <span style="color:#bd93f9">0</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">defer</span> <span style="color:#50fa7b">function</span>(<span style="color:#bd93f9">2</span>, <span style="color:#50fa7b">function</span>(<span style="color:#bd93f9">4</span>, <span style="color:#bd93f9">0</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>执行顺序：function(3) -&gt; function(4) -&gt; function(2) -&gt; function(1)</li>
</ol>
<h1 id="atomicvalue-vs-syncmutex">atomic.Value vs sync.Mutex</h1>
<p>原子操作由底层硬件支持，而锁则由操作系统的调度器实现。锁应当用来保护一段逻辑，对于一个变量更新的保护，原子操作通常会更有效率，并且更能利用计算机多核的优势，
如果要更新的是一个复合对象，则应当使用atomic.Value封装好的实现。</p>
<h1 id="进程-vs-线程-vs-协程">进程 vs 线程 vs 协程</h1>
<h2 id="进程">进程</h2>
<blockquote>
<p>进程是系统资源分配的最小单位, 进程包括文本段text region、数据段data region和堆栈段stack region等。
进程的创建和销毁都是系统资源级别的，因此是一种比较昂贵的操作，
进程是抢占式调度其有三个状态:等待态、就绪态、运行态。进程之间是相互隔离的，
它们各自拥有自己的系统资源, 更加安全但是也存在进程间通信不便的问题。</p>
</blockquote>
<h2 id="线程">线程</h2>
<blockquote>
<p>进程是线程的载体容器，多个线程除了共享进程的资源还拥有自己的一少部分独立的资源，
因此相比进程而言更加轻量，进程内的多个线程间的通信比进程容易，但是也同样带来了同步和互斥的问题和线程安全问题，
尽管如此多线程编程仍然是当前服务端编程的主流，线程也是CPU调度的最小单位，多线程运行时就存在线程切换问题</p>
</blockquote>
<h2 id="协程">协程</h2>
<blockquote>
<p>协程在有的资料中称为微线程或者用户态轻量级线程，协程调度不需要内核参与而是完全由用户态程序来决定，
因此协程对于系统而言是无感知的。协程由用户态控制就不存在抢占式调度那样强制的CPU控制权切换到其他进线程，
多个协程进行协作式调度，协程自己主动把控制权转让出去之后，其他协程才能被执行到，
这样就避免了系统切换开销提高了CPU的使用效率。</p>
</blockquote>
<h2 id="小结">小结</h2>
<ul>
<li>进程/线程抢占式调度由系统内核调度，成本大效率低</li>
<li>协程协作式调度由用户态调度，成本低效率高</li>
</ul>
<h2 id="gpm调度">GPM调度</h2>
<p>如果有大量的协程，何时让出控制权，何时恢复执行？忽然明白了抢占式调度的优势了，在抢占式调度中都是由系统内核来完成的。
我们需要一个&quot;用户态协程调度器&quot;. Golang Goroutine是如何解决的呢？</p>
<p>Golang GPM模型使用一种M:N的调度器来调度任意数量的协程运行于任意数量的系统线程中，
从而保证了上下文切换的速度并且利用多核，但是增加了调度器的复杂度。</p>
<p>引用网络上的一张图

  <img src="/img/posts/2020-08-09/golang_gpm.png" alt="">

</p>
<p>GPM调度过程简述：</p>
<blockquote>
<p>新创建的Goroutine会先存放在Global全局队列中，等待Go调度器进行调度，
随后Goroutine被分配给其中的一个逻辑处理器P，并放到这个逻辑处理器对应的Local本地运行队列中，
最终等待被逻辑处理器P执行即可。
在M与P绑定后，M会不断从P的Local队列中无锁地取出G，并切换到G的堆栈执行，
当P的Local队列中没有G时，再从Global队列中获取一个G，当Global队列中也没有待运行的G时，
则尝试从其它的P窃取部分G来执行相当于P之间的负载均衡。</p>
</blockquote>
<h1 id="读写锁-vs-互斥锁-vs-死锁">读写锁 vs 互斥锁 vs 死锁</h1>
<h2 id="死锁">死锁</h2>
<blockquote>
<p>两个或两个以上进程竞争资源造成的一种阻塞现象</p>
</blockquote>
<p>golang 中的 sync 包实现了两种锁：</p>
<ul>
<li>Mutex：互斥锁</li>
<li>RWMutex：读写锁，RWMutex 基于 Mutex 实现</li>
</ul>
<h2 id="mutex互斥锁">Mutex(互斥锁)</h2>
<blockquote>
</blockquote>
<ul>
<li>Mutex 为互斥锁，Lock() 加锁，Unlock() 解锁</li>
<li>在一个 goroutine 获得 Mutex 后，其他 goroutine 只能等到这个 goroutine 释放该 Mutex</li>
<li>使用 Lock() 加锁后，不能再继续对其加锁，直到利用 Unlock() 解锁后才能再加锁</li>
<li>在 Lock() 之前使用 Unlock() 会导致 panic 异常</li>
<li>已经锁定的 Mutex 并不与特定的 goroutine 相关联，这样可以利用一个 goroutine 对其加锁，再利用其他 goroutine 对其解锁</li>
<li>在同一个 goroutine 中的 Mutex 解锁之前再次进行加锁，会导致死锁</li>
<li>适用于读写不确定，并且只有一个读或者写的场景</li>
</ul>
<h2 id="rwmutex读写锁">RWMutex(读写锁)</h2>
<blockquote>
</blockquote>
<ul>
<li>RWMutex 是单写多读锁，该锁可以加多个读锁或者一个写锁</li>
<li>读锁占用的情况下会阻止写，不会阻止读，多个 goroutine 可以同时获取读锁</li>
<li>写锁会阻止其他 goroutine（无论读和写）进来，整个锁由该 goroutine 独占</li>
<li>适用于读多写少的场景</li>
<li>Lock() 加写锁，Unlock() 解写锁</li>
<li>如果在加写锁之前已经有其他的读锁和写锁，则 Lock() 会阻塞直到该锁可用，为确保该锁可用，已经阻塞的 Lock() 调用会从获得的锁中排除新的读取器，即写锁权限高于读锁，有写锁时优先进行写锁定</li>
<li>在 Lock() 之前使用 Unlock() 会导致 panic 异常</li>
<li>RLock() 加读锁，RUnlock() 解读锁</li>
<li>RLock() 加读锁时，如果存在写锁，则无法加读锁；当只有读锁或者没有锁时，可以加读锁，读锁可以加载多个</li>
<li>RUnlock() 解读锁，RUnlock() 撤销单词 RLock() 调用，对于其他同时存在的读锁则没有效果</li>
<li>在没有读锁的情况下调用 RUnlock() 会导致 panic 错误</li>
<li>RUnlock() 的个数不得多余 RLock()，否则会导致 panic 错误</li>
</ul>
<h1 id="slice扩容机制">slice扩容机制</h1>
<h2 id="slice扩容范例">slice扩容范例</h2>
<p>例子1</p>
<pre tabindex="0"><code>func main() {
    a := make([]int, 2, 2)
    fmt.Printf(&#34;原始容量：%d\n&#34;, cap(a))

    a = append(a, 1,2,3)
    fmt.Printf(&#34;扩容后的容量：%d\n&#34;, cap(a))
}
</code></pre><p>例子2</p>
<pre tabindex="0"><code>func main() {
    a := make([]int, 4, 4)
    fmt.Printf(&#34;原始容量：%d\n&#34;, cap(a))

    a = append(a, 1,2,3)
    fmt.Printf(&#34;扩容后的容量：%d\n&#34;, cap(a))
}
</code></pre><h2 id="预估扩容容量">预估扩容容量</h2>
<p>slice预估扩容容量的源码实现<code>go1.16.5/src/runtime/slice.go</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#6272a4">// growslice handles slice growth during append.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// It is passed the slice element type, the old slice, and the desired new minimum capacity,
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// and it returns a new slice with at least that capacity, with the old data
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// copied into it.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// The new slice&#39;s length is set to the old slice&#39;s length,
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// NOT to the new requested capacity.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// This is for codegen convenience. The old slice&#39;s length is used immediately
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// to calculate where to write new values during an append.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// TODO: When the old backend is gone, reconsider this decision.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// The SSA backend might prefer the new length or to return only ptr/cap and save stack space.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">growslice</span>(et <span style="color:#ff79c6">*</span>_type, old slice, cap <span style="color:#8be9fd">int</span>) slice {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">......</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    newcap <span style="color:#ff79c6">:=</span> old.cap
</span></span><span style="display:flex;"><span>    doublecap <span style="color:#ff79c6">:=</span> newcap <span style="color:#ff79c6">+</span> newcap
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> cap &gt; doublecap {
</span></span><span style="display:flex;"><span>        newcap = cap
</span></span><span style="display:flex;"><span>    } <span style="color:#ff79c6">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> old.cap &lt; <span style="color:#bd93f9">1024</span> {
</span></span><span style="display:flex;"><span>            newcap = doublecap
</span></span><span style="display:flex;"><span>        } <span style="color:#ff79c6">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// Check 0 &lt; newcap to detect overflow
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#6272a4">// and prevent an infinite loop.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">for</span> <span style="color:#bd93f9">0</span> &lt; newcap <span style="color:#ff79c6">&amp;&amp;</span> newcap &lt; cap {
</span></span><span style="display:flex;"><span>                newcap <span style="color:#ff79c6">+=</span> newcap <span style="color:#ff79c6">/</span> <span style="color:#bd93f9">4</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// Set newcap to the requested cap when
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#6272a4">// the newcap calculation overflowed.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">if</span> newcap <span style="color:#ff79c6">&lt;=</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>                newcap = cap
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">......</span>
</span></span></code></pre></div><p>根据源码总结出来的预估扩容容量的原理是：</p>
<ol>
<li>如果需要的总容量 &gt; 原始容量 * 2，新扩容后的容量 = 需要的总容量</li>
<li>需要的总容量 &lt;= 原始容量 * 2，且原始容量小于1024，新扩容后的容量 = 原始容量 * 2</li>
<li>需要的总容量 &lt;= 原始容量 * 2，且原始容量大于等于1024，新扩容后的容量 = 原始容量 * 1.25^n，直到新扩容后的容量&gt;=需要的总容量</li>
</ol>
<p>例子1实际运行结果：</p>
<pre tabindex="0"><code>原始容量：2
扩容后的容量：6
</code></pre><p>为什么扩容后的容量不是5，而是6？</p>
<p>例子2实际运行结果：</p>
<pre tabindex="0"><code>原始容量：4
扩容后的容量：8
</code></pre><p>预估扩容容量的原理跟实际运行结果不相匹配，问题出在哪里？最终是分配一段内存大小空间出来，这个内存空间不是随意分配的，而是由golang内存管理模块决定的，
内存块大小都是固定的。</p>
<h2 id="所需内存大小">所需内存大小</h2>
<p>golang内存管理模块，划分的内存块大小：<code>go1.16.5/src/runtime/sizeclasses.go</code></p>
<pre tabindex="0"><code>// class  bytes/obj  bytes/span  objects  tail waste  max waste
//     1          8        8192     1024           0     87.50%
//     2         16        8192      512           0     43.75%
//     3         24        8192      341           8     29.24%
//     4         32        8192      256           0     21.88%
//     5         48        8192      170          32     31.52%
//     6         64        8192      128           0     23.44%
//     7         80        8192      102          32     19.07%
//     8         96        8192       85          32     15.95%
//     9        112        8192       73          16     13.56%
//    10        128        8192       64           0     11.72%
//    11        144        8192       56         128     11.82%
//    12        160        8192       51          32      9.73%
//    13        176        8192       46          96      9.59%
//    14        192        8192       42         128      9.25%
//    15        208        8192       39          80      8.12%
//    16        224        8192       36         128      8.15%
//    17        240        8192       34          32      6.62%
//    18        256        8192       32           0      5.86%
//    19        288        8192       28         128     12.16%
//    20        320        8192       25         192     11.80%
//    21        352        8192       23          96      9.88%
//    22        384        8192       21         128      9.51%
//    23        416        8192       19         288     10.71%
//    24        448        8192       18         128      8.37%
//    25        480        8192       17          32      6.82%
//    26        512        8192       16           0      6.05%
//    27        576        8192       14         128     12.33%
//    28        640        8192       12         512     15.48%
//    29        704        8192       11         448     13.93%
//    30        768        8192       10         512     13.94%
//    31        896        8192        9         128     15.52%
//    32       1024        8192        8           0     12.40%
//    33       1152        8192        7         128     12.41%
//    34       1280        8192        6         512     15.55%
//    35       1408       16384       11         896     14.00%
//    36       1536        8192        5         512     14.00%
//    37       1792       16384        9         256     15.57%
//    38       2048        8192        4           0     12.45%
//    39       2304       16384        7         256     12.46%
//    40       2688        8192        3         128     15.59%
//    41       3072       24576        8           0     12.47%
//    42       3200       16384        5         384      6.22%
//    43       3456       24576        7         384      8.83%
//    44       4096        8192        2           0     15.60%
//    45       4864       24576        5         256     16.65%
//    46       5376       16384        3         256     10.92%
//    47       6144       24576        4           0     12.48%
//    48       6528       32768        5         128      6.23%
//    49       6784       40960        6         256      4.36%
//    50       6912       49152        7         768      3.37%
//    51       8192        8192        1           0     15.61%
//    52       9472       57344        6         512     14.28%
//    53       9728       49152        5         512      3.64%
//    54      10240       40960        4           0      4.99%
//    55      10880       32768        3         128      6.24%
//    56      12288       24576        2           0     11.45%
//    57      13568       40960        3         256      9.99%
//    58      14336       57344        4           0      5.35%
//    59      16384       16384        1           0     12.49%
//    60      18432       73728        4           0     11.11%
//    61      19072       57344        3         128      3.57%
//    62      20480       40960        2           0      6.87%
//    63      21760       65536        3         256      6.25%
//    64      24576       24576        1           0     11.45%
//    65      27264       81920        3         128     10.00%
//    66      28672       57344        2           0      4.91%
//    67      32768       32768        1           0     12.50%
</code></pre><p>从上图看出，内存块增长并不是规律的</p>
<h2 id="匹配最合适的内存大小">匹配最合适的内存大小</h2>
<p><code>所需内存大小 = 预估容量 * 元素类型大小</code>，套用上述例子1，所需内存大小 = 5 * 8字节(一个int在64位操作系统里是64位，也就是8字节) = 40字节，
查看上图最匹配的内存空间大小是48字节，48/8=6个int的容量</p>
<h1 id="goroutine-id">Goroutine id</h1>
<p>利用runtime.Stack可以获取全部Goroutine的栈信息，官方net/http2库中curGoroutineID函数也采用这种方式获取Goroutine id，
<a href="https://github.com/golang/net/blob/master/http2/gotrack.go#L51">net/http2获取Goroutine id</a></p>
<p>获取到Goroutine id，可以方便debug，这个id可以作为唯一标识，将Goroutine中调用的函数层级串联起来；
比较典型的例子：在web框架中，在日志中打印这个id，可以很方便对整个请求过程进行跟踪和分析。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;bytes&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;runtime&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;strconv&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;sync&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">GetGoid</span>() <span style="color:#8be9fd">uint64</span> {
</span></span><span style="display:flex;"><span>    b <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>([]<span style="color:#8be9fd">byte</span>, <span style="color:#bd93f9">64</span>)
</span></span><span style="display:flex;"><span>    b = b[:runtime.<span style="color:#50fa7b">Stack</span>(b, <span style="color:#ff79c6">false</span>)]
</span></span><span style="display:flex;"><span>    b = bytes.<span style="color:#50fa7b">TrimPrefix</span>(b, []<span style="color:#8be9fd;font-style:italic">byte</span>(<span style="color:#f1fa8c">&#34;goroutine &#34;</span>))
</span></span><span style="display:flex;"><span>    b = b[:bytes.<span style="color:#50fa7b">IndexByte</span>(b, <span style="color:#f1fa8c">&#39; &#39;</span>)]
</span></span><span style="display:flex;"><span>    n, _ <span style="color:#ff79c6">:=</span> strconv.<span style="color:#50fa7b">ParseUint</span>(<span style="color:#8be9fd;font-style:italic">string</span>(b), <span style="color:#bd93f9">10</span>, <span style="color:#bd93f9">64</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> n
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;main&#34;</span>, <span style="color:#50fa7b">GetGoid</span>())
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">var</span> wg sync.WaitGroup
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; i &lt; <span style="color:#bd93f9">20</span>; i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>        i <span style="color:#ff79c6">:=</span> i
</span></span><span style="display:flex;"><span>        wg.<span style="color:#50fa7b">Add</span>(<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">defer</span> wg.<span style="color:#50fa7b">Done</span>()
</span></span><span style="display:flex;"><span>            fmt.<span style="color:#50fa7b">Println</span>(i, <span style="color:#50fa7b">GetGoid</span>())
</span></span><span style="display:flex;"><span>        }()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    wg.<span style="color:#50fa7b">Wait</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="rpc">RPC</h1>
<h2 id="grpc">grpc</h2>
<h3 id="grpc入门">grpc入门</h3>
<pre tabindex="0"><code>入门/
├── main.go
├── protobuf
│├── hello.pb.go
│└── hello.proto
└── server
    └── server.go
2 directories, 4 files
</code></pre><p><code>protobuf/hello.proto</code></p>
<pre tabindex="0"><code>syntax = &#34;proto3&#34;;

package protobuf;

// message关键字定义一个叫String的类型
message String {
    string value = 1;
}

// 定义rpc方法
service HelloService {
    rpc Hello (String) returns (String);
</code></pre><p>通过<code>protoc -I protobuf protobuf/*.proto --go_out=plugins=grpc:protobuf</code>生成hello.pb.go</p>
<p><code>main.go</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;context&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;google.golang.org/grpc&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>    . <span style="color:#f1fa8c">&#34;test/protobuf&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    conn, err <span style="color:#ff79c6">:=</span> grpc.<span style="color:#50fa7b">Dial</span>(<span style="color:#f1fa8c">&#34;localhost:1234&#34;</span>, grpc.<span style="color:#50fa7b">WithInsecure</span>())
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        log.<span style="color:#50fa7b">Fatal</span>(err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">defer</span> conn.<span style="color:#50fa7b">Close</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// protobuf生成Client
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    client <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">NewHelloServiceClient</span>(conn)
</span></span><span style="display:flex;"><span>    reply, err <span style="color:#ff79c6">:=</span> client.<span style="color:#50fa7b">Hello</span>(context.<span style="color:#50fa7b">Background</span>(), <span style="color:#ff79c6">&amp;</span>String{Value: <span style="color:#f1fa8c">&#34;hello&#34;</span>})
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        log.<span style="color:#50fa7b">Fatal</span>(err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(reply.<span style="color:#50fa7b">GetValue</span>())
</span></span></code></pre></div><p><code>server/server.go</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;context&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;google.golang.org/grpc&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;net&#34;</span>
</span></span><span style="display:flex;"><span>    . <span style="color:#f1fa8c">&#34;test/protobuf&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> HelloServiceImpl <span style="color:#8be9fd;font-style:italic">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (p <span style="color:#ff79c6">*</span>HelloServiceImpl) <span style="color:#50fa7b">Hello</span>(ctx context.Context, args <span style="color:#ff79c6">*</span>String) (<span style="color:#ff79c6">*</span>String, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>    reply <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&amp;</span>String{Value: <span style="color:#f1fa8c">&#34;hello:&#34;</span> <span style="color:#ff79c6">+</span> args.<span style="color:#50fa7b">GetValue</span>()}
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> reply, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    grpcServer <span style="color:#ff79c6">:=</span> grpc.<span style="color:#50fa7b">NewServer</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// protobuf生成注册函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">RegisterHelloServiceServer</span>(grpcServer, <span style="color:#8be9fd;font-style:italic">new</span>(HelloServiceImpl))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    lis, err <span style="color:#ff79c6">:=</span> net.<span style="color:#50fa7b">Listen</span>(<span style="color:#f1fa8c">&#34;tcp&#34;</span>, <span style="color:#f1fa8c">&#34;:1234&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        log.<span style="color:#50fa7b">Fatal</span>(err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    grpcServer.<span style="color:#50fa7b">Serve</span>(lis)
</span></span></code></pre></div><h3 id="grpc-stream">grpc stream</h3>
<p>传统rpc不适合上传/下载数据量大的场景，grpc提供了stream特性</p>
<pre tabindex="0"><code>stream/
├── main.go
├── protobuf
│ ├── hello.pb.go
│ └── hello.proto
└── server
    └── server.go

2 directories, 4 files
</code></pre><p><code>protobuf/hello.proto</code></p>
<pre tabindex="0"><code>syntax = &#34;proto3&#34;;

package protobuf;

message String {
    string value = 1;
}

service HelloService {
    rpc Hello (String) returns (String);
    // 关键字stream启用流特性, 添加一个双向流的方法
    rpc Channel (stream String) returns (stream String);
</code></pre><p><code>main.go</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;context&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;google.golang.org/grpc&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;io&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>    . <span style="color:#f1fa8c">&#34;test/protobuf&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    conn, err <span style="color:#ff79c6">:=</span> grpc.<span style="color:#50fa7b">Dial</span>(<span style="color:#f1fa8c">&#34;localhost:1234&#34;</span>, grpc.<span style="color:#50fa7b">WithInsecure</span>())
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        log.<span style="color:#50fa7b">Fatal</span>(err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">defer</span> conn.<span style="color:#50fa7b">Close</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    client <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">NewHelloServiceClient</span>(conn)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 先获取stream对象
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    stream, err <span style="color:#ff79c6">:=</span> client.<span style="color:#50fa7b">Channel</span>(context.<span style="color:#50fa7b">Background</span>())
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        log.<span style="color:#50fa7b">Fatal</span>(err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 模拟客户端发送数据
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> stream.<span style="color:#50fa7b">Send</span>(<span style="color:#ff79c6">&amp;</span>String{Value: <span style="color:#f1fa8c">&#34;hi&#34;</span>}); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>                log.<span style="color:#50fa7b">Fatal</span>(err)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            time.<span style="color:#50fa7b">Sleep</span>(time.Second)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 循环接收数据
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>        reply, err <span style="color:#ff79c6">:=</span> stream.<span style="color:#50fa7b">Recv</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">==</span> io.EOF {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">break</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            log.<span style="color:#50fa7b">Fatal</span>(err)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        fmt.<span style="color:#50fa7b">Println</span>(reply.<span style="color:#50fa7b">GetValue</span>())
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>server/server.go</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;context&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;google.golang.org/grpc&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;io&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;net&#34;</span>
</span></span><span style="display:flex;"><span>    . <span style="color:#f1fa8c">&#34;test/protobuf&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> HelloServiceImpl <span style="color:#8be9fd;font-style:italic">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (p <span style="color:#ff79c6">*</span>HelloServiceImpl) <span style="color:#50fa7b">Hello</span>(ctx context.Context, args <span style="color:#ff79c6">*</span>String) (<span style="color:#ff79c6">*</span>String, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>    reply <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&amp;</span>String{Value: <span style="color:#f1fa8c">&#34;hello:&#34;</span> <span style="color:#ff79c6">+</span> args.<span style="color:#50fa7b">GetValue</span>()}
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> reply, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// 循环接收客户端的数据，数据重新组装后，通过stream又发给客户端；双向流数据的发送和接收是独立的
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (p <span style="color:#ff79c6">*</span>HelloServiceImpl) <span style="color:#50fa7b">Channel</span>(stream HelloService_ChannelServer) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>        args, err <span style="color:#ff79c6">:=</span> stream.<span style="color:#50fa7b">Recv</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">==</span> io.EOF {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        reply <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&amp;</span>String{Value: <span style="color:#f1fa8c">&#34;hello:&#34;</span> <span style="color:#ff79c6">+</span> args.<span style="color:#50fa7b">GetValue</span>()}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        err = stream.<span style="color:#50fa7b">Send</span>(reply)
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    grpcServer <span style="color:#ff79c6">:=</span> grpc.<span style="color:#50fa7b">NewServer</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">RegisterHelloServiceServer</span>(grpcServer, <span style="color:#8be9fd;font-style:italic">new</span>(HelloServiceImpl))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    lis, err <span style="color:#ff79c6">:=</span> net.<span style="color:#50fa7b">Listen</span>(<span style="color:#f1fa8c">&#34;tcp&#34;</span>, <span style="color:#f1fa8c">&#34;:1234&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        log.<span style="color:#50fa7b">Fatal</span>(err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    grpcServer.<span style="color:#50fa7b">Serve</span>(lis)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="http-rpc">http-rpc</h3>
<p>在http协议上提供jsonrpc服务</p>
<p><code>http-rpc/server.go</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;io&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;net/http&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;net/rpc&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;net/rpc/jsonrpc&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> HelloService <span style="color:#8be9fd;font-style:italic">struct</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (p <span style="color:#ff79c6">*</span>HelloService) <span style="color:#50fa7b">Hello</span>(request <span style="color:#8be9fd">string</span>, reply <span style="color:#ff79c6">*</span><span style="color:#8be9fd">string</span>) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">*</span>reply = <span style="color:#f1fa8c">&#34;hello:&#34;</span> <span style="color:#ff79c6">+</span> request
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    rpc.<span style="color:#50fa7b">RegisterName</span>(<span style="color:#f1fa8c">&#34;HelloService&#34;</span>, <span style="color:#8be9fd;font-style:italic">new</span>(HelloService))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 在处理函数中基于http.ResponseWriter和http.Request类型的参数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 构造一个io.ReadWriteCloser类型的conn通道
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    http.<span style="color:#50fa7b">HandleFunc</span>(<span style="color:#f1fa8c">&#34;/hello&#34;</span>, <span style="color:#8be9fd;font-style:italic">func</span>(w http.ResponseWriter, r <span style="color:#ff79c6">*</span>http.Request) {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">var</span> conn io.ReadWriteCloser = <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>            io.Writer
</span></span><span style="display:flex;"><span>            io.ReadCloser
</span></span><span style="display:flex;"><span>        }{
</span></span><span style="display:flex;"><span>            ReadCloser: r.Body,
</span></span><span style="display:flex;"><span>            Writer:     w,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        rpc.<span style="color:#50fa7b">ServeRequest</span>(jsonrpc.<span style="color:#50fa7b">NewServerCodec</span>(conn))
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    http.<span style="color:#50fa7b">ListenAndServe</span>(<span style="color:#f1fa8c">&#34;:1234&#34;</span>, <span style="color:#ff79c6">nil</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用curl调用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>curl localhost:1234/hello -X POST <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>    --data <span style="color:#f1fa8c">&#39;{&#34;method&#34;:&#34;HelloService.Hello&#34;,&#34;params&#34;:[&#34;hello&#34;],&#34;id&#34;:0}&#39;</span>
</span></span></code></pre></div><h3 id="json-rpc">json-rpc</h3>
<p>采用官方net/rpc/jsonrpc扩展，只要是同样的json结构，就可以进行跨语言rpc</p>
<pre tabindex="0"><code>json-rpc/
├── client
│ └── test.go
├── main.go
└── server
    └── server.go

2 directories, 3 files
</code></pre><p><code>main.go</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    . <span style="color:#f1fa8c">&#34;./server&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;net&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;net/rpc&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;net/rpc/jsonrpc&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">RegisterHelloService</span>(<span style="color:#8be9fd;font-style:italic">new</span>(HelloService))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    listener, err <span style="color:#ff79c6">:=</span> net.<span style="color:#50fa7b">Listen</span>(<span style="color:#f1fa8c">&#34;tcp&#34;</span>, <span style="color:#f1fa8c">&#34;:1234&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        log.<span style="color:#50fa7b">Fatal</span>(<span style="color:#f1fa8c">&#34;ListenTCP error:&#34;</span>, err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>        conn, err <span style="color:#ff79c6">:=</span> listener.<span style="color:#50fa7b">Accept</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>            log.<span style="color:#50fa7b">Fatal</span>(<span style="color:#f1fa8c">&#34;Accept error:&#34;</span>, err)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// json编解码器包装
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">go</span> rpc.<span style="color:#50fa7b">ServeCodec</span>(jsonrpc.<span style="color:#50fa7b">NewServerCodec</span>(conn))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>server/server.go</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> server
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;net/rpc&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">const</span> HelloServiceName = <span style="color:#f1fa8c">&#34;path/to/pkg.HelloService&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> HelloServiceInterface <span style="color:#8be9fd;font-style:italic">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">Hello</span>(request <span style="color:#8be9fd">string</span>, reply <span style="color:#ff79c6">*</span><span style="color:#8be9fd">string</span>) <span style="color:#8be9fd">error</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">RegisterHelloService</span>(svc HelloServiceInterface) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> rpc.<span style="color:#50fa7b">RegisterName</span>(HelloServiceName, svc)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> HelloService <span style="color:#8be9fd;font-style:italic">struct</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (p <span style="color:#ff79c6">*</span>HelloService) <span style="color:#50fa7b">Hello</span>(request <span style="color:#8be9fd">string</span>, reply <span style="color:#ff79c6">*</span><span style="color:#8be9fd">string</span>) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">*</span>reply = <span style="color:#f1fa8c">&#34;hello:&#34;</span> <span style="color:#ff79c6">+</span> request
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>client/test.go</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    . <span style="color:#f1fa8c">&#34;../server&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;net&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;net/rpc&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;net/rpc/jsonrpc&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> HelloServiceClient <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">*</span>rpc.Client
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//var _ HelloServiceInterface = (*HelloServiceClient)(nil)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">DialHelloService</span>(network, address <span style="color:#8be9fd">string</span>) (<span style="color:#ff79c6">*</span>HelloServiceClient, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// rpc连接建立在io.ReadWriteCloser接口之上
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    conn, err <span style="color:#ff79c6">:=</span> net.<span style="color:#50fa7b">Dial</span>(network, address)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// json编解码器包装
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    client <span style="color:#ff79c6">:=</span> rpc.<span style="color:#50fa7b">NewClientWithCodec</span>(jsonrpc.<span style="color:#50fa7b">NewClientCodec</span>(conn))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>HelloServiceClient{Client: client}, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (p <span style="color:#ff79c6">*</span>HelloServiceClient) <span style="color:#50fa7b">Hello</span>(request <span style="color:#8be9fd">string</span>, reply <span style="color:#ff79c6">*</span><span style="color:#8be9fd">string</span>) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> p.Client.<span style="color:#50fa7b">Call</span>(HelloServiceName<span style="color:#ff79c6">+</span><span style="color:#f1fa8c">&#34;.Hello&#34;</span>, request, reply)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    client, err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">DialHelloService</span>(<span style="color:#f1fa8c">&#34;tcp&#34;</span>, <span style="color:#f1fa8c">&#34;localhost:1234&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        log.<span style="color:#50fa7b">Fatal</span>(<span style="color:#f1fa8c">&#34;dialing:&#34;</span>, err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">var</span> reply <span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>    err = client.<span style="color:#50fa7b">Hello</span>(<span style="color:#f1fa8c">&#34;world&#34;</span>, <span style="color:#ff79c6">&amp;</span>reply)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        log.<span style="color:#50fa7b">Fatal</span>(err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(reply)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="golang官方rpc">Golang官方rpc</h3>
<p>Go官方rpc包是net/rpc, rpc方法必须满足Go rpc规则:
1.公开方法
2.只有两个序列化参数，第二个参数是指针类型
3.返回值是error类型</p>
<pre tabindex="0"><code>Golang官方rpc/
├── client
│└── test.go
├── main.go
└── server
    └── server.go

2 directories, 3 files
</code></pre><p><code>main.go</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    . <span style="color:#f1fa8c">&#34;./server&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;net&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;net/rpc&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">RegisterHelloService</span>(<span style="color:#8be9fd;font-style:italic">new</span>(HelloService))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    listener, err <span style="color:#ff79c6">:=</span> net.<span style="color:#50fa7b">Listen</span>(<span style="color:#f1fa8c">&#34;tcp&#34;</span>, <span style="color:#f1fa8c">&#34;:1234&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        log.<span style="color:#50fa7b">Fatal</span>(<span style="color:#f1fa8c">&#34;ListenTCP error:&#34;</span>, err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>        conn, err <span style="color:#ff79c6">:=</span> listener.<span style="color:#50fa7b">Accept</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>            log.<span style="color:#50fa7b">Fatal</span>(<span style="color:#f1fa8c">&#34;Accept error:&#34;</span>, err)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">go</span> rpc.<span style="color:#50fa7b">ServeConn</span>(conn)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>client/test.go</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    . <span style="color:#f1fa8c">&#34;../server&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;net/rpc&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> HelloServiceClient <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">*</span>rpc.Client
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">var</span> _ HelloServiceInterface = (<span style="color:#ff79c6">*</span>HelloServiceClient)(<span style="color:#ff79c6">nil</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">DialHelloService</span>(network, address <span style="color:#8be9fd">string</span>) (<span style="color:#ff79c6">*</span>HelloServiceClient, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 与rpc server建立rpc连接
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    c, err <span style="color:#ff79c6">:=</span> rpc.<span style="color:#50fa7b">Dial</span>(network, address)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>HelloServiceClient{Client: c}, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (p <span style="color:#ff79c6">*</span>HelloServiceClient) <span style="color:#50fa7b">Hello</span>(request <span style="color:#8be9fd">string</span>, reply <span style="color:#ff79c6">*</span><span style="color:#8be9fd">string</span>) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 调用rpc方法
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">return</span> p.Client.<span style="color:#50fa7b">Call</span>(HelloServiceName<span style="color:#ff79c6">+</span><span style="color:#f1fa8c">&#34;.Hello&#34;</span>, request, reply)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    client, err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">DialHelloService</span>(<span style="color:#f1fa8c">&#34;tcp&#34;</span>, <span style="color:#f1fa8c">&#34;localhost:1234&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        log.<span style="color:#50fa7b">Fatal</span>(<span style="color:#f1fa8c">&#34;dialing:&#34;</span>, err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">var</span> reply <span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>    err = client.<span style="color:#50fa7b">Hello</span>(<span style="color:#f1fa8c">&#34;world&#34;</span>, <span style="color:#ff79c6">&amp;</span>reply)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        log.<span style="color:#50fa7b">Fatal</span>(err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(reply)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>server/server.go</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> server
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;net/rpc&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">const</span> HelloServiceName = <span style="color:#f1fa8c">&#34;path/to/pkg.HelloService&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> HelloServiceInterface <span style="color:#8be9fd;font-style:italic">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">Hello</span>(request <span style="color:#8be9fd">string</span>, reply <span style="color:#ff79c6">*</span><span style="color:#8be9fd">string</span>) <span style="color:#8be9fd">error</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// rpc.Register将对象类型下所有符合Go rpc规则的方法都注册为rpc方法，
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// rpc方法托管在HelloServiceName命名空间下
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">RegisterHelloService</span>(svc HelloServiceInterface) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> rpc.<span style="color:#50fa7b">RegisterName</span>(HelloServiceName, svc)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> HelloService <span style="color:#8be9fd;font-style:italic">struct</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (p <span style="color:#ff79c6">*</span>HelloService) <span style="color:#50fa7b">Hello</span>(request <span style="color:#8be9fd">string</span>, reply <span style="color:#ff79c6">*</span><span style="color:#8be9fd">string</span>) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">*</span>reply = <span style="color:#f1fa8c">&#34;hello:&#34;</span> <span style="color:#ff79c6">+</span> request
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="set集合">Set集合</h1>
<p>引用来自：k8s.io/apimachinery/pkg/util/sets</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> sets
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;reflect&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;sort&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Empty is public since it is used by some pkg API objects for conversions between external
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// string arrays and pkg sets, and conversion logic requires public types today.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> Empty <span style="color:#8be9fd;font-style:italic">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// sets.String is a set of strings, implemented via map[string]struct{} for minimal memory consumption.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> String <span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">string</span>]Empty
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// NewString creates a String from a list of values.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">NewString</span>(items <span style="color:#ff79c6">...</span><span style="color:#8be9fd">string</span>) String {
</span></span><span style="display:flex;"><span>    ss <span style="color:#ff79c6">:=</span> String{}
</span></span><span style="display:flex;"><span>    ss.<span style="color:#50fa7b">Insert</span>(items<span style="color:#ff79c6">...</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> ss
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// StringKeySet creates a String from a keys of a map[string](? extends interface{}).
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// If the value passed in is not actually a map, this will panic.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">StringKeySet</span>(theMap <span style="color:#8be9fd;font-style:italic">interface</span>{}) String {
</span></span><span style="display:flex;"><span>    v <span style="color:#ff79c6">:=</span> reflect.<span style="color:#50fa7b">ValueOf</span>(theMap)
</span></span><span style="display:flex;"><span>    ret <span style="color:#ff79c6">:=</span> String{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> _, keyValue <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> v.<span style="color:#50fa7b">MapKeys</span>() {
</span></span><span style="display:flex;"><span>        ret.<span style="color:#50fa7b">Insert</span>(keyValue.<span style="color:#50fa7b">Interface</span>().(<span style="color:#8be9fd">string</span>))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> ret
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Insert adds items to the set.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (s String) <span style="color:#50fa7b">Insert</span>(items <span style="color:#ff79c6">...</span><span style="color:#8be9fd">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> _, item <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> items {
</span></span><span style="display:flex;"><span>        s[item] = Empty{}
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Delete removes all items from the set.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (s String) <span style="color:#50fa7b">Delete</span>(items <span style="color:#ff79c6">...</span><span style="color:#8be9fd">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> _, item <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> items {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">delete</span>(s, item)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Has returns true if and only if item is contained in the set.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (s String) <span style="color:#50fa7b">Has</span>(item <span style="color:#8be9fd">string</span>) <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>    _, contained <span style="color:#ff79c6">:=</span> s[item]
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> contained
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// HasAll returns true if and only if all items are contained in the set.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (s String) <span style="color:#50fa7b">HasAll</span>(items <span style="color:#ff79c6">...</span><span style="color:#8be9fd">string</span>) <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> _, item <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> items {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> !s.<span style="color:#50fa7b">Has</span>(item) {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">false</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">true</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// HasAny returns true if any items are contained in the set.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (s String) <span style="color:#50fa7b">HasAny</span>(items <span style="color:#ff79c6">...</span><span style="color:#8be9fd">string</span>) <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> _, item <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> items {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> s.<span style="color:#50fa7b">Has</span>(item) {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">true</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">false</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Difference returns a set of objects that are not in s2
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// For example:
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// s1 = {a1, a2, a3}
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// s2 = {a1, a2, a4, a5}
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// s1.Difference(s2) = {a3}
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// s2.Difference(s1) = {a4, a5}
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (s String) <span style="color:#50fa7b">Difference</span>(s2 String) String {
</span></span><span style="display:flex;"><span>    result <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">NewString</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> key <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> s {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> !s2.<span style="color:#50fa7b">Has</span>(key) {
</span></span><span style="display:flex;"><span>            result.<span style="color:#50fa7b">Insert</span>(key)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> result
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Union returns a new set which includes items in either s1 or s2.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// For example:
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// s1 = {a1, a2}
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// s2 = {a3, a4}
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// s1.Union(s2) = {a1, a2, a3, a4}
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// s2.Union(s1) = {a1, a2, a3, a4}
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (s1 String) <span style="color:#50fa7b">Union</span>(s2 String) String {
</span></span><span style="display:flex;"><span>    result <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">NewString</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> key <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> s1 {
</span></span><span style="display:flex;"><span>        result.<span style="color:#50fa7b">Insert</span>(key)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> key <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> s2 {
</span></span><span style="display:flex;"><span>        result.<span style="color:#50fa7b">Insert</span>(key)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> result
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Intersection returns a new set which includes the item in BOTH s1 and s2
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// For example:
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// s1 = {a1, a2}
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// s2 = {a2, a3}
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// s1.Intersection(s2) = {a2}
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (s1 String) <span style="color:#50fa7b">Intersection</span>(s2 String) String {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">var</span> walk, other String
</span></span><span style="display:flex;"><span>    result <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">NewString</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> s1.<span style="color:#50fa7b">Len</span>() &lt; s2.<span style="color:#50fa7b">Len</span>() {
</span></span><span style="display:flex;"><span>        walk = s1
</span></span><span style="display:flex;"><span>        other = s2
</span></span><span style="display:flex;"><span>    } <span style="color:#ff79c6">else</span> {
</span></span><span style="display:flex;"><span>        walk = s2
</span></span><span style="display:flex;"><span>        other = s1
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> key <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> walk {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> other.<span style="color:#50fa7b">Has</span>(key) {
</span></span><span style="display:flex;"><span>            result.<span style="color:#50fa7b">Insert</span>(key)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> result
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// IsSuperset returns true if and only if s1 is a superset of s2.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (s1 String) <span style="color:#50fa7b">IsSuperset</span>(s2 String) <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> item <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> s2 {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> !s1.<span style="color:#50fa7b">Has</span>(item) {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">false</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">true</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Equal returns true if and only if s1 is equal (as a set) to s2.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// Two sets are equal if their membership is identical.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// (In practice, this means same elements, order doesn&#39;t matter)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (s1 String) <span style="color:#50fa7b">Equal</span>(s2 String) <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">len</span>(s1) <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">len</span>(s2) <span style="color:#ff79c6">&amp;&amp;</span> s1.<span style="color:#50fa7b">IsSuperset</span>(s2)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> sortableSliceOfString []<span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (s sortableSliceOfString) <span style="color:#50fa7b">Len</span>() <span style="color:#8be9fd">int</span>           { <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">len</span>(s) }
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (s sortableSliceOfString) <span style="color:#50fa7b">Less</span>(i, j <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">bool</span> { <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">lessString</span>(s[i], s[j]) }
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (s sortableSliceOfString) <span style="color:#50fa7b">Swap</span>(i, j <span style="color:#8be9fd">int</span>)      { s[i], s[j] = s[j], s[i] }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// List returns the contents as a sorted string slice.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (s String) <span style="color:#50fa7b">List</span>() []<span style="color:#8be9fd">string</span> {
</span></span><span style="display:flex;"><span>    res <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(sortableSliceOfString, <span style="color:#bd93f9">0</span>, <span style="color:#8be9fd;font-style:italic">len</span>(s))
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> key <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> s {
</span></span><span style="display:flex;"><span>        res = <span style="color:#8be9fd;font-style:italic">append</span>(res, key)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    sort.<span style="color:#50fa7b">Sort</span>(res)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> []<span style="color:#8be9fd;font-style:italic">string</span>(res)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// UnsortedList returns the slice with contents in random order.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (s String) <span style="color:#50fa7b">UnsortedList</span>() []<span style="color:#8be9fd">string</span> {
</span></span><span style="display:flex;"><span>    res <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>([]<span style="color:#8be9fd">string</span>, <span style="color:#bd93f9">0</span>, <span style="color:#8be9fd;font-style:italic">len</span>(s))
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> key <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> s {
</span></span><span style="display:flex;"><span>        res = <span style="color:#8be9fd;font-style:italic">append</span>(res, key)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> res
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Returns a single element from the set.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (s String) <span style="color:#50fa7b">PopAny</span>() (<span style="color:#8be9fd">string</span>, <span style="color:#8be9fd">bool</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> key <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> s {
</span></span><span style="display:flex;"><span>        s.<span style="color:#50fa7b">Delete</span>(key)
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> key, <span style="color:#ff79c6">true</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">var</span> zeroValue <span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> zeroValue, <span style="color:#ff79c6">false</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Len returns the size of the set.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (s String) <span style="color:#50fa7b">Len</span>() <span style="color:#8be9fd">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">len</span>(s)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">lessString</span>(lhs, rhs <span style="color:#8be9fd">string</span>) <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> lhs &lt; rhs
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="网络开发">网络开发</h1>
<h2 id="netlink库操作">netlink库操作</h2>
<p>引用来自：github.com/coreos/flannel/pkg/ip/iface.go</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> ip
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;errors&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;net&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;syscall&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;github.com/vishvananda/netlink&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">getIfaceAddrs</span>(iface <span style="color:#ff79c6">*</span>net.Interface) ([]netlink.Addr, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>    link <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&amp;</span>netlink.Device{
</span></span><span style="display:flex;"><span>        netlink.LinkAttrs{
</span></span><span style="display:flex;"><span>            Index: iface.Index,
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> netlink.<span style="color:#50fa7b">AddrList</span>(link, syscall.AF_INET)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">GetIfaceIP4Addr</span>(iface <span style="color:#ff79c6">*</span>net.Interface) (net.IP, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>    addrs, err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">getIfaceAddrs</span>(iface)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// prefer non link-local addr
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd;font-style:italic">var</span> ll net.IP
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> _, addr <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> addrs {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> addr.IP.<span style="color:#50fa7b">To4</span>() <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">continue</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> addr.IP.<span style="color:#50fa7b">IsGlobalUnicast</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> addr.IP, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> addr.IP.<span style="color:#50fa7b">IsLinkLocalUnicast</span>() {
</span></span><span style="display:flex;"><span>            ll = addr.IP
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> ll <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// didn&#39;t find global but found link-local. it&#39;ll do.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">return</span> ll, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, errors.<span style="color:#50fa7b">New</span>(<span style="color:#f1fa8c">&#34;No IPv4 address found for given interface&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">GetIfaceIP4AddrMatch</span>(iface <span style="color:#ff79c6">*</span>net.Interface, matchAddr net.IP) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    addrs, err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">getIfaceAddrs</span>(iface)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> _, addr <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> addrs {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// Attempt to parse the address in CIDR notation
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// and assert it is IPv4
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">if</span> addr.IP.<span style="color:#50fa7b">To4</span>() <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> addr.IP.<span style="color:#50fa7b">To4</span>().<span style="color:#50fa7b">Equal</span>(matchAddr) {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> errors.<span style="color:#50fa7b">New</span>(<span style="color:#f1fa8c">&#34;No IPv4 address found for given interface&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">GetDefaultGatewayIface</span>() (<span style="color:#ff79c6">*</span>net.Interface, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>    routes, err <span style="color:#ff79c6">:=</span> netlink.<span style="color:#50fa7b">RouteList</span>(<span style="color:#ff79c6">nil</span>, syscall.AF_INET)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> _, route <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> routes {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> route.Dst <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span> <span style="color:#ff79c6">||</span> route.Dst.<span style="color:#50fa7b">String</span>() <span style="color:#ff79c6">==</span> <span style="color:#f1fa8c">&#34;0.0.0.0/0&#34;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> route.LinkIndex <span style="color:#ff79c6">&lt;=</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, errors.<span style="color:#50fa7b">New</span>(<span style="color:#f1fa8c">&#34;Found default route but could not determine interface&#34;</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> net.<span style="color:#50fa7b">InterfaceByIndex</span>(route.LinkIndex)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, errors.<span style="color:#50fa7b">New</span>(<span style="color:#f1fa8c">&#34;Unable to find default route&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">GetInterfaceByIP</span>(ip net.IP) (<span style="color:#ff79c6">*</span>net.Interface, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>    ifaces, err <span style="color:#ff79c6">:=</span> net.<span style="color:#50fa7b">Interfaces</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> _, iface <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> ifaces {
</span></span><span style="display:flex;"><span>        err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">GetIfaceIP4AddrMatch</span>(<span style="color:#ff79c6">&amp;</span>iface, ip)
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>iface, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, errors.<span style="color:#50fa7b">New</span>(<span style="color:#f1fa8c">&#34;No interface with given IP found&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">DirectRouting</span>(ip net.IP) (<span style="color:#8be9fd">bool</span>, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>    routes, err <span style="color:#ff79c6">:=</span> netlink.<span style="color:#50fa7b">RouteGet</span>(ip)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">false</span>, fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;couldn&#39;t lookup route to %v: %v&#34;</span>, ip, err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">len</span>(routes) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">1</span> <span style="color:#ff79c6">&amp;&amp;</span> routes[<span style="color:#bd93f9">0</span>].Gw <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// There is only a single route and there&#39;s no gateway (i.e. it&#39;s directly connected)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">true</span>, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">false</span>, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// EnsureV4AddressOnLink ensures that there is only one v4 Addr on `link` and it equals `ipn`.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// If there exist multiple addresses on link, it returns an error message to tell callers to remove additional address.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">EnsureV4AddressOnLink</span>(ipn IP4Net, link netlink.Link) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    addr <span style="color:#ff79c6">:=</span> netlink.Addr{IPNet: ipn.<span style="color:#50fa7b">ToIPNet</span>()}
</span></span><span style="display:flex;"><span>    existingAddrs, err <span style="color:#ff79c6">:=</span> netlink.<span style="color:#50fa7b">AddrList</span>(link, netlink.FAMILY_V4)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// flannel will never make this happen. This situation can only be caused by a user, so get them to sort it out.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">len</span>(existingAddrs) &gt; <span style="color:#bd93f9">1</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;link has incompatible addresses. Remove additional addresses and try again. %#v&#34;</span>, link)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// If the device has an incompatible address then delete it. This can happen if the lease changes for example.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">len</span>(existingAddrs) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">1</span> <span style="color:#ff79c6">&amp;&amp;</span> !existingAddrs[<span style="color:#bd93f9">0</span>].<span style="color:#50fa7b">Equal</span>(addr) {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> netlink.<span style="color:#50fa7b">AddrDel</span>(link, <span style="color:#ff79c6">&amp;</span>existingAddrs[<span style="color:#bd93f9">0</span>]); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;failed to remove IP address %s from %s: %s&#34;</span>, ipn.<span style="color:#50fa7b">String</span>(), link.<span style="color:#50fa7b">Attrs</span>().Name, err)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        existingAddrs = []netlink.Addr{}
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// Actually add the desired address to the interface if needed.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">len</span>(existingAddrs) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> netlink.<span style="color:#50fa7b">AddrAdd</span>(link, <span style="color:#ff79c6">&amp;</span>addr); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;failed to add IP address %s to %s: %s&#34;</span>, ipn.<span style="color:#50fa7b">String</span>(), link.<span style="color:#50fa7b">Attrs</span>().Name, err)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="三元表达式">三元表达式</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">If</span>(condition <span style="color:#8be9fd">bool</span>, trueVal, falseVal <span style="color:#8be9fd;font-style:italic">interface</span>{}) <span style="color:#8be9fd;font-style:italic">interface</span>{} {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> condition {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> trueVal
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> falseVal
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    a, b <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">2</span>, <span style="color:#bd93f9">3</span>
</span></span><span style="display:flex;"><span>    max <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">If</span>(a &gt; b, a, b).(<span style="color:#8be9fd">int</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">println</span>(max)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="结构体优雅赋值">结构体优雅赋值</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//参数定义在结构体内部
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> Op <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    userInfo <span style="color:#ff79c6">*</span>models.UserInfo
</span></span><span style="display:flex;"><span>    pagination <span style="color:#ff79c6">*</span>models.Pagination
</span></span><span style="display:flex;"><span>    state <span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> OpOption <span style="color:#8be9fd;font-style:italic">func</span>(<span style="color:#ff79c6">*</span>Op)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//变量赋值給实例
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (op <span style="color:#ff79c6">*</span>Op) <span style="color:#50fa7b">applyOpts</span>(opts []OpOption) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> _, opt <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> opts {
</span></span><span style="display:flex;"><span>        <span style="color:#50fa7b">opt</span>(op)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">WithUserInfo</span>(userInfo <span style="color:#ff79c6">*</span>models.UserInfo) OpOption {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">func</span>(op <span style="color:#ff79c6">*</span>Op) { op.userInfo = userInfo }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">WithPagination</span>(pagination <span style="color:#ff79c6">*</span>models.Pagination) OpOption {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">func</span>(op <span style="color:#ff79c6">*</span>Op) { op.pagination = pagination }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">WithState</span>(state <span style="color:#8be9fd">string</span>) OpOption {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">func</span>(op <span style="color:#ff79c6">*</span>Op) { op.state = state }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">OpGet</span>(opts <span style="color:#ff79c6">...</span>OpOption) Op {
</span></span><span style="display:flex;"><span>    ret <span style="color:#ff79c6">:=</span> Op{}
</span></span><span style="display:flex;"><span>    ret.<span style="color:#50fa7b">applyOpts</span>(opts)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> ret
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="函数">函数</h1>
<h2 id="回调函数">回调函数</h2>
<p>回调函数：本质是通过函数指针调用的函数，如函数1作为参数传递给函数2，函数1叫做回调函数，函数2叫做中间函数，调用2的函数叫做起始函数.</p>
<p>回调示例（来自知乎）：</p>
<blockquote>
<p>有一家旅馆提供叫醒服务，但是要求旅客自己决定叫醒的方法。可以是打客房电话，也可以是派服务员去敲门，睡得死怕耽误事的，还可以要求往自己头上浇盆水。
这里，“叫醒”这个行为是旅馆提供的，相当于中间函数，但是叫醒的方式是由旅客决定并告诉旅馆的，也就是回调函数。而旅客告诉旅馆怎么叫醒自己的动作，
也就是把回调函数传入中间函数的动作，称为登记回调函数（to register a callback function）</p>
</blockquote>
<blockquote>
<p>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。
在这个例子里， 你的电话号码就叫回调函数 ，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件 ，店员给你打电话叫做调用回调函数 ，
你到店里去取货叫做响应回调事件 。</p>
</blockquote>
<p>回调函数类型：</p>
<ol>
<li>阻塞式回调（同步回调）(下面这个例子就是阻塞式回调)</li>
<li>延迟式回调（异步回调）</li>
</ol>
<p>知乎上关于回调的理解不错的帖子: <a href="https://www.zhihu.com/question/19801131">https://www.zhihu.com/question/19801131</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//回调函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">XX</span>(x <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> x <span style="color:#ff79c6">*</span> x
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//中间函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//接受一个生成平方数的函数作为参数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">returnXXNumber</span>(x <span style="color:#8be9fd">int</span>, getXXNumber <span style="color:#8be9fd;font-style:italic">func</span>(<span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">getXXNumber</span>(x)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//起始函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    x <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">2</span>
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#50fa7b">returnXXNumber</span>(x, XX))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="闭包函数">闭包函数</h2>
<p>闭包：官方解释（译文）Go函数可以是一个闭包。闭包是一个函数值，它引用了函数体之外的变量。
这个函数可以对这个引用的变量进行访问和赋值；换句话说这个函数被&quot;绑定&quot;在这个变量上。</p>
<p>作用：是缩小变量作用域，降低对全局变量污染的概率</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">add</span>() <span style="color:#8be9fd;font-style:italic">func</span>(<span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">int</span> {
</span></span><span style="display:flex;"><span>    sum <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">func</span>(x <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">int</span> {
</span></span><span style="display:flex;"><span>        sum <span style="color:#ff79c6">+=</span> x
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> sum
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//add()就是一个闭包，并赋值给pos和neg，pos的闭包函数和neg的闭包函数被绑定在各自的sum变量上；
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">//两个闭包函数的sum变量之间没有任何关系
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    pos, neg <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">add</span>(), <span style="color:#50fa7b">add</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; i &lt; <span style="color:#bd93f9">5</span>; i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>        fmt.<span style="color:#50fa7b">Println</span>(
</span></span><span style="display:flex;"><span>            <span style="color:#50fa7b">pos</span>(i),
</span></span><span style="display:flex;"><span>            <span style="color:#50fa7b">neg</span>(<span style="color:#ff79c6">-</span>i),
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>闭包实现的斐波那契数列</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//fibonacci函数完成核心算法、核心数据存储, 不负责for循环
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">fibonacci</span>() <span style="color:#8be9fd;font-style:italic">func</span>() <span style="color:#8be9fd">int</span> {
</span></span><span style="display:flex;"><span>    b1 <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span>    b2 <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>    bc <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">func</span>() <span style="color:#8be9fd">int</span> {
</span></span><span style="display:flex;"><span>        bc = b1 <span style="color:#ff79c6">+</span> b2
</span></span><span style="display:flex;"><span>        b1 = b2
</span></span><span style="display:flex;"><span>        b2 = bc
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> bc
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    f <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">fibonacci</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; i &lt; <span style="color:#bd93f9">10</span>; i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>        fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#50fa7b">f</span>())
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="分布式锁">分布式锁</h1>
<h2 id="etcd分布式锁">etcd分布式锁</h2>
<p>etcd client v3版本中的concurrency包实现了分布式锁，
大致思路是：</p>
<ol>
<li>createReVision最小的客户端获得锁</li>
<li>createReVision越小越早获得锁，部分关键代码如下</li>
</ol>
<p>等待比当前客户端创建的key的revision小的key的客户端释放锁
// wait for deletion revisions prior to myKey
hdr, werr := waitDeletes(ctx, client, m.pfx, m.myRev-1)</p>
<p>引用来自: <a href="https://github.com/etcd-io/etcd/blob/master/clientv3/example_kv_test.go">https://github.com/etcd-io/etcd/blob/master/clientv3/example_kv_test.go</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;context&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;strings&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;github.com/coreos/etcd/clientv3&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;github.com/coreos/etcd/clientv3/concurrency&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">var</span> (
</span></span><span style="display:flex;"><span>    endpoints = <span style="color:#f1fa8c">&#34;http://10.10.10.10:52379&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    cli, err <span style="color:#ff79c6">:=</span> clientv3.<span style="color:#50fa7b">New</span>(clientv3.Config{
</span></span><span style="display:flex;"><span>        Endpoints:   strings.<span style="color:#50fa7b">Split</span>(endpoints, <span style="color:#f1fa8c">&#34;,&#34;</span>),
</span></span><span style="display:flex;"><span>        DialTimeout: <span style="color:#bd93f9">3</span> <span style="color:#ff79c6">*</span> time.Second,
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">panic</span>(err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">defer</span> cli.<span style="color:#50fa7b">Close</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// create two separate sessions for lock competition
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    s1, err <span style="color:#ff79c6">:=</span> concurrency.<span style="color:#50fa7b">NewSession</span>(cli)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        log.<span style="color:#50fa7b">Fatal</span>(err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">defer</span> s1.<span style="color:#50fa7b">Close</span>()
</span></span><span style="display:flex;"><span>    m1 <span style="color:#ff79c6">:=</span> concurrency.<span style="color:#50fa7b">NewMutex</span>(s1, <span style="color:#f1fa8c">&#34;/my-lock/&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    s2, err <span style="color:#ff79c6">:=</span> concurrency.<span style="color:#50fa7b">NewSession</span>(cli)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        log.<span style="color:#50fa7b">Fatal</span>(err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">defer</span> s2.<span style="color:#50fa7b">Close</span>()
</span></span><span style="display:flex;"><span>    m2 <span style="color:#ff79c6">:=</span> concurrency.<span style="color:#50fa7b">NewMutex</span>(s2, <span style="color:#f1fa8c">&#34;/my-lock/&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// acquire lock for s1
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> m1.<span style="color:#50fa7b">Lock</span>(context.<span style="color:#50fa7b">TODO</span>()); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        log.<span style="color:#50fa7b">Fatal</span>(err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;acquired lock for s1&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    m2Locked <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{})
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">defer</span> <span style="color:#8be9fd;font-style:italic">close</span>(m2Locked)
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// wait until s1 is locks /my-lock/
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> m2.<span style="color:#50fa7b">Lock</span>(context.<span style="color:#50fa7b">TODO</span>()); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>            log.<span style="color:#50fa7b">Fatal</span>(err)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> m1.<span style="color:#50fa7b">Unlock</span>(context.<span style="color:#50fa7b">TODO</span>()); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        log.<span style="color:#50fa7b">Fatal</span>(err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;released lock for s1&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">&lt;-</span>m2Locked
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;acquired lock for s2&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// Output:
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// acquired lock for s1
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// released lock for s1
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// acquired lock for s2
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><h1 id="分页">分页</h1>
<p>分页逻辑：</p>
<pre tabindex="0"><code>if page &gt; 0 &amp;&amp; pageSize &gt; 0 {
    Db = Db.Limit(pageSize).Offset((page - 1) * pageSize)
}
</code></pre><h2 id="接口层分页">接口层分页</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">CommonPaginate</span>(x <span style="color:#8be9fd;font-style:italic">interface</span>{}, offset <span style="color:#8be9fd">int</span>, limit <span style="color:#8be9fd">int</span>) (<span style="color:#8be9fd">int</span>, <span style="color:#8be9fd">int</span>) {
</span></span><span style="display:flex;"><span>    xLen <span style="color:#ff79c6">:=</span> reflect.<span style="color:#50fa7b">ValueOf</span>(x).<span style="color:#50fa7b">Len</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> offset<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span> &gt; xLen {
</span></span><span style="display:flex;"><span>        offset = xLen <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> offset &lt; <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>            offset = <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    end <span style="color:#ff79c6">:=</span> offset <span style="color:#ff79c6">+</span> limit
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> end &gt; xLen {
</span></span><span style="display:flex;"><span>        end = xLen
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> offset, end
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="发布-订阅模式">发布-订阅模式</h1>
<p>引用来自：moby项目提供pubsub简单实现</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;github.com/moby/moby/pkg/pubsub&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;strings&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;sync&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    p <span style="color:#ff79c6">:=</span> pubsub.<span style="color:#50fa7b">NewPublisher</span>(<span style="color:#bd93f9">100</span><span style="color:#ff79c6">*</span>time.Millisecond, <span style="color:#bd93f9">10</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    golang <span style="color:#ff79c6">:=</span> p.<span style="color:#50fa7b">SubscribeTopic</span>(<span style="color:#8be9fd;font-style:italic">func</span>(v <span style="color:#8be9fd;font-style:italic">interface</span>{}) <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> key, ok <span style="color:#ff79c6">:=</span> v.(<span style="color:#8be9fd">string</span>); ok {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> strings.<span style="color:#50fa7b">HasPrefix</span>(key, <span style="color:#f1fa8c">&#34;golang:&#34;</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">true</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">false</span>
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    docker <span style="color:#ff79c6">:=</span> p.<span style="color:#50fa7b">SubscribeTopic</span>(<span style="color:#8be9fd;font-style:italic">func</span>(v <span style="color:#8be9fd;font-style:italic">interface</span>{}) <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> key, ok <span style="color:#ff79c6">:=</span> v.(<span style="color:#8be9fd">string</span>); ok {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> strings.<span style="color:#50fa7b">HasPrefix</span>(key, <span style="color:#f1fa8c">&#34;docker:&#34;</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">true</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">false</span>
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">go</span> p.<span style="color:#50fa7b">Publish</span>(<span style="color:#f1fa8c">&#34;hi&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">go</span> p.<span style="color:#50fa7b">Publish</span>(<span style="color:#f1fa8c">&#34;golang: https://golang.org&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">go</span> p.<span style="color:#50fa7b">Publish</span>(<span style="color:#f1fa8c">&#34;docker: https://www.docker.com/&#34;</span>)
</span></span><span style="display:flex;"><span>    time.<span style="color:#50fa7b">Sleep</span>(<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    wg <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&amp;</span>sync.WaitGroup{}
</span></span><span style="display:flex;"><span>    wg.<span style="color:#50fa7b">Add</span>(<span style="color:#bd93f9">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">defer</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>            wg.<span style="color:#50fa7b">Done</span>()
</span></span><span style="display:flex;"><span>        }()
</span></span><span style="display:flex;"><span>        fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;golang topic:&#34;</span>, <span style="color:#ff79c6">&lt;-</span>golang)
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">defer</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>            wg.<span style="color:#50fa7b">Done</span>()
</span></span><span style="display:flex;"><span>        }()
</span></span><span style="display:flex;"><span>        fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;docker topic:&#34;</span>, <span style="color:#ff79c6">&lt;-</span>docker)
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>    wg.<span style="color:#50fa7b">Wait</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="定时器">定时器</h1>
<h2 id="自定义定时器">自定义定时器</h2>
<p>自定义一种定时器执行任务的job机制，在time Ticker基础上的升级版，大体思路是：</p>
<ol>
<li>定义一个Periodic接口类型</li>
<li>定义一个refreshData结构体，实现Periodic接口</li>
<li>定义一个DoPeriodic函数，遍历Periodic类型列表</li>
</ol>
<p>引用来自：https://github.com/helm/monocular</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> Periodic <span style="color:#8be9fd;font-style:italic">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">Do</span>() <span style="color:#8be9fd">error</span>
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">Frequency</span>() time.Duration
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">Name</span>() <span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">FirstRun</span>() <span style="color:#8be9fd">bool</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> PeriodicCanceller <span style="color:#8be9fd;font-style:italic">func</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">DoPeriodic</span>(pSlice []Periodic) PeriodicCanceller {
</span></span><span style="display:flex;"><span>    doneCh <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{})
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> _, p <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> pSlice {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>(p Periodic) {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> p.<span style="color:#50fa7b">FirstRun</span>() {
</span></span><span style="display:flex;"><span>                err <span style="color:#ff79c6">:=</span> p.<span style="color:#50fa7b">Do</span>()
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>                    fmt.<span style="color:#50fa7b">Printf</span>(<span style="color:#f1fa8c">&#34;periodic job ran and returned error (%s)\n&#34;</span>, err)
</span></span><span style="display:flex;"><span>                } <span style="color:#ff79c6">else</span> {
</span></span><span style="display:flex;"><span>                    fmt.<span style="color:#50fa7b">Printf</span>(<span style="color:#f1fa8c">&#34;periodic job %s ran\n&#34;</span>, p.<span style="color:#50fa7b">Name</span>())
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            ticker <span style="color:#ff79c6">:=</span> time.<span style="color:#50fa7b">NewTicker</span>(p.<span style="color:#50fa7b">Frequency</span>())
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">select</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span>ticker.C:
</span></span><span style="display:flex;"><span>                    err <span style="color:#ff79c6">:=</span> p.<span style="color:#50fa7b">Do</span>()
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>                        fmt.<span style="color:#50fa7b">Printf</span>(<span style="color:#f1fa8c">&#34;periodic job ran and returned error (%s)\n&#34;</span>, err)
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span>doneCh:
</span></span><span style="display:flex;"><span>                    ticker.<span style="color:#50fa7b">Stop</span>()
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">return</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }(p)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">close</span>(doneCh)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">NewRefreshData</span>(frequency time.Duration, name <span style="color:#8be9fd">string</span>, firstRun <span style="color:#8be9fd">bool</span>) Periodic {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>refreshData{
</span></span><span style="display:flex;"><span>        frequency: frequency,
</span></span><span style="display:flex;"><span>        name:      name,
</span></span><span style="display:flex;"><span>        firstRun:  firstRun,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> refreshData <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    frequency time.Duration
</span></span><span style="display:flex;"><span>    name      <span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>    firstRun  <span style="color:#8be9fd">bool</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (r <span style="color:#ff79c6">*</span>refreshData) <span style="color:#50fa7b">Do</span>() <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Printf</span>(<span style="color:#f1fa8c">&#34;time: %s, %s Do xxx\n&#34;</span>, time.<span style="color:#50fa7b">Now</span>(), r.name)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (r <span style="color:#ff79c6">*</span>refreshData) <span style="color:#50fa7b">Frequency</span>() time.Duration {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> r.frequency
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (r <span style="color:#ff79c6">*</span>refreshData) <span style="color:#50fa7b">FirstRun</span>() <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> r.firstRun
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (r <span style="color:#ff79c6">*</span>refreshData) <span style="color:#50fa7b">Name</span>() <span style="color:#8be9fd">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> r.name
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">var</span> refreshInterval = <span style="color:#bd93f9">3</span>
</span></span><span style="display:flex;"><span>    freshness <span style="color:#ff79c6">:=</span> time.<span style="color:#50fa7b">Duration</span>(refreshInterval) <span style="color:#ff79c6">*</span> time.Second
</span></span><span style="display:flex;"><span>    periodicRefresh <span style="color:#ff79c6">:=</span>  <span style="color:#50fa7b">NewRefreshData</span>(freshness, <span style="color:#f1fa8c">&#34;refresh&#34;</span>, <span style="color:#ff79c6">false</span>)
</span></span><span style="display:flex;"><span>    newPeriodicRefresh <span style="color:#ff79c6">:=</span>  <span style="color:#50fa7b">NewRefreshData</span>(<span style="color:#bd93f9">5</span><span style="color:#ff79c6">*</span>time.Second, <span style="color:#f1fa8c">&#34;test&#34;</span>, <span style="color:#ff79c6">true</span>)
</span></span><span style="display:flex;"><span>    toDo <span style="color:#ff79c6">:=</span> []Periodic{periodicRefresh, newPeriodicRefresh}
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">DoPeriodic</span>(toDo)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">select</span> {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="time-ticker实现">time Ticker实现</h2>
<p>比较通用的做法：通过time Ticker获取一个time的channel</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">var</span> (
</span></span><span style="display:flex;"><span>        DefaultInterval = <span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    done <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd">bool</span>)
</span></span><span style="display:flex;"><span>    ticker <span style="color:#ff79c6">:=</span> time.<span style="color:#50fa7b">NewTicker</span>(time.<span style="color:#50fa7b">Duration</span>(DefaultInterval) <span style="color:#ff79c6">*</span> time.Second)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;begin!&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">select</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span> done:
</span></span><span style="display:flex;"><span>                fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;stop!&#34;</span>)
</span></span><span style="display:flex;"><span>                ticker.<span style="color:#50fa7b">Stop</span>()
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">return</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span> ticker.C:
</span></span><span style="display:flex;"><span>                fmt.<span style="color:#50fa7b">Printf</span>(<span style="color:#f1fa8c">&#34;time: %s, msg: trigger the periodic timer.\n&#34;</span>, time.<span style="color:#50fa7b">Now</span>())
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>    time.<span style="color:#50fa7b">Sleep</span>(<span style="color:#bd93f9">5</span><span style="color:#ff79c6">*</span>time.Second)
</span></span><span style="display:flex;"><span>    done <span style="color:#ff79c6">&lt;-</span> <span style="color:#ff79c6">true</span>
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;end!&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="k8s定时器实现">k8s定时器实现</h2>
<p>引用来自: k8s.io/apimachinery/pkg/util/wait/wait.go</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#6272a4">/*
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">Copyright 2014 The Kubernetes Authors.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">you may not use this file except in compliance with the License.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">You may obtain a copy of the License at
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">    http://www.apache.org/licenses/LICENSE-2.0
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">Unless required by applicable law or agreed to in writing, software
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">See the License for the specific language governing permissions and
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">limitations under the License.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">package</span> wait
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;context&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;errors&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;math&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;math/rand&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;sync&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;k8s.io/apimachinery/pkg/util/runtime&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;k8s.io/utils/clock&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// For any test of the style:
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//   ...
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//   &lt;- time.After(timeout):
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//      t.Errorf(&#34;Timed out&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// The value for timeout should effectively be &#34;forever.&#34; Obviously we don&#39;t want our tests to truly lock up forever, but 30s
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// is long enough that it is effectively forever for the things that can slow down a run on a heavily contended machine
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// (GC, seeks, etc), but not so long as to make a developer ctrl-c a test run if they do happen to break that test.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">var</span> ForeverTestTimeout = time.Second <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">30</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// NeverStop may be passed to Until to make it never stop.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">var</span> NeverStop <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{} = <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Group allows to start a group of goroutines and wait for their completion.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> Group <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    wg sync.WaitGroup
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (g <span style="color:#ff79c6">*</span>Group) <span style="color:#50fa7b">Wait</span>() {
</span></span><span style="display:flex;"><span>    g.wg.<span style="color:#50fa7b">Wait</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// StartWithChannel starts f in a new goroutine in the group.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// stopCh is passed to f as an argument. f should stop when stopCh is available.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (g <span style="color:#ff79c6">*</span>Group) <span style="color:#50fa7b">StartWithChannel</span>(stopCh <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}, f <span style="color:#8be9fd;font-style:italic">func</span>(stopCh <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{})) {
</span></span><span style="display:flex;"><span>    g.<span style="color:#50fa7b">Start</span>(<span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#50fa7b">f</span>(stopCh)
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// StartWithContext starts f in a new goroutine in the group.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// ctx is passed to f as an argument. f should stop when ctx.Done() is available.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (g <span style="color:#ff79c6">*</span>Group) <span style="color:#50fa7b">StartWithContext</span>(ctx context.Context, f <span style="color:#8be9fd;font-style:italic">func</span>(context.Context)) {
</span></span><span style="display:flex;"><span>    g.<span style="color:#50fa7b">Start</span>(<span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#50fa7b">f</span>(ctx)
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Start starts f in a new goroutine in the group.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (g <span style="color:#ff79c6">*</span>Group) <span style="color:#50fa7b">Start</span>(f <span style="color:#8be9fd;font-style:italic">func</span>()) {
</span></span><span style="display:flex;"><span>    g.wg.<span style="color:#50fa7b">Add</span>(<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">defer</span> g.wg.<span style="color:#50fa7b">Done</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#50fa7b">f</span>()
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Forever calls f every period for ever.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// Forever is syntactic sugar on top of Until.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">Forever</span>(f <span style="color:#8be9fd;font-style:italic">func</span>(), period time.Duration) {
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">Until</span>(f, period, NeverStop)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Until loops until stop channel is closed, running f every period.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// Until is syntactic sugar on top of JitterUntil with zero jitter factor and
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// with sliding = true (which means the timer for period starts after the f
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// completes).
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">Until</span>(f <span style="color:#8be9fd;font-style:italic">func</span>(), period time.Duration, stopCh <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}) {
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">JitterUntil</span>(f, period, <span style="color:#bd93f9">0.0</span>, <span style="color:#ff79c6">true</span>, stopCh)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// UntilWithContext loops until context is done, running f every period.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// UntilWithContext is syntactic sugar on top of JitterUntilWithContext
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// with zero jitter factor and with sliding = true (which means the timer
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// for period starts after the f completes).
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">UntilWithContext</span>(ctx context.Context, f <span style="color:#8be9fd;font-style:italic">func</span>(context.Context), period time.Duration) {
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">JitterUntilWithContext</span>(ctx, f, period, <span style="color:#bd93f9">0.0</span>, <span style="color:#ff79c6">true</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// NonSlidingUntil loops until stop channel is closed, running f every
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// period.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// NonSlidingUntil is syntactic sugar on top of JitterUntil with zero jitter
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// factor, with sliding = false (meaning the timer for period starts at the same
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// time as the function starts).
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">NonSlidingUntil</span>(f <span style="color:#8be9fd;font-style:italic">func</span>(), period time.Duration, stopCh <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}) {
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">JitterUntil</span>(f, period, <span style="color:#bd93f9">0.0</span>, <span style="color:#ff79c6">false</span>, stopCh)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// NonSlidingUntilWithContext loops until context is done, running f every
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// period.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// NonSlidingUntilWithContext is syntactic sugar on top of JitterUntilWithContext
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// with zero jitter factor, with sliding = false (meaning the timer for period
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// starts at the same time as the function starts).
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">NonSlidingUntilWithContext</span>(ctx context.Context, f <span style="color:#8be9fd;font-style:italic">func</span>(context.Context), period time.Duration) {
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">JitterUntilWithContext</span>(ctx, f, period, <span style="color:#bd93f9">0.0</span>, <span style="color:#ff79c6">false</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// JitterUntil loops until stop channel is closed, running f every period.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// If jitterFactor is positive, the period is jittered before every run of f.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// If jitterFactor is not positive, the period is unchanged and not jittered.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// If sliding is true, the period is computed after f runs. If it is false then
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// period includes the runtime for f.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// Close stopCh to stop. f may not be invoked if stop channel is already
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// closed. Pass NeverStop to if you don&#39;t want it stop.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">JitterUntil</span>(f <span style="color:#8be9fd;font-style:italic">func</span>(), period time.Duration, jitterFactor <span style="color:#8be9fd">float64</span>, sliding <span style="color:#8be9fd">bool</span>, stopCh <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}) {
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">BackoffUntil</span>(f, <span style="color:#50fa7b">NewJitteredBackoffManager</span>(period, jitterFactor, <span style="color:#ff79c6">&amp;</span>clock.RealClock{}), sliding, stopCh)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// BackoffUntil loops until stop channel is closed, run f every duration given by BackoffManager.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// If sliding is true, the period is computed after f runs. If it is false then
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// period includes the runtime for f.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">BackoffUntil</span>(f <span style="color:#8be9fd;font-style:italic">func</span>(), backoff BackoffManager, sliding <span style="color:#8be9fd">bool</span>, stopCh <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}) {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">var</span> t clock.Timer
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">select</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span>stopCh:
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">default</span>:
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> !sliding {
</span></span><span style="display:flex;"><span>            t = backoff.<span style="color:#50fa7b">Backoff</span>()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">defer</span> runtime.<span style="color:#50fa7b">HandleCrash</span>()
</span></span><span style="display:flex;"><span>            <span style="color:#50fa7b">f</span>()
</span></span><span style="display:flex;"><span>        }()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> sliding {
</span></span><span style="display:flex;"><span>            t = backoff.<span style="color:#50fa7b">Backoff</span>()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// NOTE: b/c there is no priority selection in golang
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// it is possible for this to race, meaning we could
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// trigger t.C and stopCh, and t.C select falls through.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// In order to mitigate we re-check stopCh at the beginning
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// of every loop to prevent extra executions of f().
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">select</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span>stopCh:
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> !t.<span style="color:#50fa7b">Stop</span>() {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">&lt;-</span>t.<span style="color:#50fa7b">C</span>()
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span>t.<span style="color:#50fa7b">C</span>():
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// JitterUntilWithContext loops until context is done, running f every period.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// If jitterFactor is positive, the period is jittered before every run of f.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// If jitterFactor is not positive, the period is unchanged and not jittered.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// If sliding is true, the period is computed after f runs. If it is false then
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// period includes the runtime for f.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// Cancel context to stop. f may not be invoked if context is already expired.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">JitterUntilWithContext</span>(ctx context.Context, f <span style="color:#8be9fd;font-style:italic">func</span>(context.Context), period time.Duration, jitterFactor <span style="color:#8be9fd">float64</span>, sliding <span style="color:#8be9fd">bool</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">JitterUntil</span>(<span style="color:#8be9fd;font-style:italic">func</span>() { <span style="color:#50fa7b">f</span>(ctx) }, period, jitterFactor, sliding, ctx.<span style="color:#50fa7b">Done</span>())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Jitter returns a time.Duration between duration and duration + maxFactor *
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// duration.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// This allows clients to avoid converging on periodic behavior. If maxFactor
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// is 0.0, a suggested default value will be chosen.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">Jitter</span>(duration time.Duration, maxFactor <span style="color:#8be9fd">float64</span>) time.Duration {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> maxFactor <span style="color:#ff79c6">&lt;=</span> <span style="color:#bd93f9">0.0</span> {
</span></span><span style="display:flex;"><span>        maxFactor = <span style="color:#bd93f9">1.0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    wait <span style="color:#ff79c6">:=</span> duration <span style="color:#ff79c6">+</span> time.<span style="color:#50fa7b">Duration</span>(rand.<span style="color:#50fa7b">Float64</span>()<span style="color:#ff79c6">*</span>maxFactor<span style="color:#ff79c6">*</span><span style="color:#8be9fd;font-style:italic">float64</span>(duration))
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> wait
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// ErrWaitTimeout is returned when the condition exited without success.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">var</span> ErrWaitTimeout = errors.<span style="color:#50fa7b">New</span>(<span style="color:#f1fa8c">&#34;timed out waiting for the condition&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// ConditionFunc returns true if the condition is satisfied, or an error
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// if the loop should be aborted.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> ConditionFunc <span style="color:#8be9fd;font-style:italic">func</span>() (done <span style="color:#8be9fd">bool</span>, err <span style="color:#8be9fd">error</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// ConditionWithContextFunc returns true if the condition is satisfied, or an error
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// if the loop should be aborted.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// The caller passes along a context that can be used by the condition function.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> ConditionWithContextFunc <span style="color:#8be9fd;font-style:italic">func</span>(context.Context) (done <span style="color:#8be9fd">bool</span>, err <span style="color:#8be9fd">error</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// WithContext converts a ConditionFunc into a ConditionWithContextFunc
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (cf ConditionFunc) <span style="color:#50fa7b">WithContext</span>() ConditionWithContextFunc {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">func</span>(context.Context) (done <span style="color:#8be9fd">bool</span>, err <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">cf</span>()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// runConditionWithCrashProtection runs a ConditionFunc with crash protection
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">runConditionWithCrashProtection</span>(condition ConditionFunc) (<span style="color:#8be9fd">bool</span>, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">runConditionWithCrashProtectionWithContext</span>(context.<span style="color:#50fa7b">TODO</span>(), condition.<span style="color:#50fa7b">WithContext</span>())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// runConditionWithCrashProtectionWithContext runs a
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// ConditionWithContextFunc with crash protection.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">runConditionWithCrashProtectionWithContext</span>(ctx context.Context, condition ConditionWithContextFunc) (<span style="color:#8be9fd">bool</span>, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">defer</span> runtime.<span style="color:#50fa7b">HandleCrash</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">condition</span>(ctx)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Backoff holds parameters applied to a Backoff function.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> Backoff <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// The initial duration.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    Duration time.Duration
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// Duration is multiplied by factor each iteration, if factor is not zero
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// and the limits imposed by Steps and Cap have not been reached.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// Should not be negative.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// The jitter does not contribute to the updates to the duration parameter.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    Factor <span style="color:#8be9fd">float64</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// The sleep at each iteration is the duration plus an additional
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// amount chosen uniformly at random from the interval between
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// zero and `jitter*duration`.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    Jitter <span style="color:#8be9fd">float64</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// The remaining number of iterations in which the duration
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// parameter may change (but progress can be stopped earlier by
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// hitting the cap). If not positive, the duration is not
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// changed. Used for exponential backoff in combination with
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// Factor and Cap.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    Steps <span style="color:#8be9fd">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// A limit on revised values of the duration parameter. If a
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// multiplication by the factor parameter would make the duration
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// exceed the cap then the duration is set to the cap and the
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// steps parameter is set to zero.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    Cap time.Duration
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Step (1) returns an amount of time to sleep determined by the
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// original Duration and Jitter and (2) mutates the provided Backoff
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// to update its Steps and Duration.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (b <span style="color:#ff79c6">*</span>Backoff) <span style="color:#50fa7b">Step</span>() time.Duration {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> b.Steps &lt; <span style="color:#bd93f9">1</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> b.Jitter &gt; <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">Jitter</span>(b.Duration, b.Jitter)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> b.Duration
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    b.Steps<span style="color:#ff79c6">--</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    duration <span style="color:#ff79c6">:=</span> b.Duration
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// calculate the next step
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> b.Factor <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>        b.Duration = time.<span style="color:#50fa7b">Duration</span>(<span style="color:#8be9fd;font-style:italic">float64</span>(b.Duration) <span style="color:#ff79c6">*</span> b.Factor)
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> b.Cap &gt; <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">&amp;&amp;</span> b.Duration &gt; b.Cap {
</span></span><span style="display:flex;"><span>            b.Duration = b.Cap
</span></span><span style="display:flex;"><span>            b.Steps = <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> b.Jitter &gt; <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>        duration = <span style="color:#50fa7b">Jitter</span>(duration, b.Jitter)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> duration
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// contextForChannel derives a child context from a parent channel.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// The derived context&#39;s Done channel is closed when the returned cancel function
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// is called or when the parent channel is closed, whichever happens first.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// Note the caller must *always* call the CancelFunc, otherwise resources may be leaked.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">contextForChannel</span>(parentCh <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}) (context.Context, context.CancelFunc) {
</span></span><span style="display:flex;"><span>    ctx, cancel <span style="color:#ff79c6">:=</span> context.<span style="color:#50fa7b">WithCancel</span>(context.<span style="color:#50fa7b">Background</span>())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">select</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span>parentCh:
</span></span><span style="display:flex;"><span>            <span style="color:#50fa7b">cancel</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span>ctx.<span style="color:#50fa7b">Done</span>():
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> ctx, cancel
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// BackoffManager manages backoff with a particular scheme based on its underlying implementation. It provides
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// an interface to return a timer for backoff, and caller shall backoff until Timer.C() drains. If the second Backoff()
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// is called before the timer from the first Backoff() call finishes, the first timer will NOT be drained and result in
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// undetermined behavior.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// The BackoffManager is supposed to be called in a single-threaded environment.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> BackoffManager <span style="color:#8be9fd;font-style:italic">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">Backoff</span>() clock.Timer
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> exponentialBackoffManagerImpl <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    backoff              <span style="color:#ff79c6">*</span>Backoff
</span></span><span style="display:flex;"><span>    backoffTimer         clock.Timer
</span></span><span style="display:flex;"><span>    lastBackoffStart     time.Time
</span></span><span style="display:flex;"><span>    initialBackoff       time.Duration
</span></span><span style="display:flex;"><span>    backoffResetDuration time.Duration
</span></span><span style="display:flex;"><span>    clock                clock.Clock
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// NewExponentialBackoffManager returns a manager for managing exponential backoff. Each backoff is jittered and
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// backoff will not exceed the given max. If the backoff is not called within resetDuration, the backoff is reset.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// This backoff manager is used to reduce load during upstream unhealthiness.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">NewExponentialBackoffManager</span>(initBackoff, maxBackoff, resetDuration time.Duration, backoffFactor, jitter <span style="color:#8be9fd">float64</span>, c clock.Clock) BackoffManager {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>exponentialBackoffManagerImpl{
</span></span><span style="display:flex;"><span>        backoff: <span style="color:#ff79c6">&amp;</span>Backoff{
</span></span><span style="display:flex;"><span>            Duration: initBackoff,
</span></span><span style="display:flex;"><span>            Factor:   backoffFactor,
</span></span><span style="display:flex;"><span>            Jitter:   jitter,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// the current impl of wait.Backoff returns Backoff.Duration once steps are used up, which is not
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#6272a4">// what we ideally need here, we set it to max int and assume we will never use up the steps
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            Steps: math.MaxInt32,
</span></span><span style="display:flex;"><span>            Cap:   maxBackoff,
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        backoffTimer:         <span style="color:#ff79c6">nil</span>,
</span></span><span style="display:flex;"><span>        initialBackoff:       initBackoff,
</span></span><span style="display:flex;"><span>        lastBackoffStart:     c.<span style="color:#50fa7b">Now</span>(),
</span></span><span style="display:flex;"><span>        backoffResetDuration: resetDuration,
</span></span><span style="display:flex;"><span>        clock:                c,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (b <span style="color:#ff79c6">*</span>exponentialBackoffManagerImpl) <span style="color:#50fa7b">getNextBackoff</span>() time.Duration {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> b.clock.<span style="color:#50fa7b">Now</span>().<span style="color:#50fa7b">Sub</span>(b.lastBackoffStart) &gt; b.backoffResetDuration {
</span></span><span style="display:flex;"><span>        b.backoff.Steps = math.MaxInt32
</span></span><span style="display:flex;"><span>        b.backoff.Duration = b.initialBackoff
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    b.lastBackoffStart = b.clock.<span style="color:#50fa7b">Now</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> b.backoff.<span style="color:#50fa7b">Step</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Backoff implements BackoffManager.Backoff, it returns a timer so caller can block on the timer for exponential backoff.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// The returned timer must be drained before calling Backoff() the second time
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (b <span style="color:#ff79c6">*</span>exponentialBackoffManagerImpl) <span style="color:#50fa7b">Backoff</span>() clock.Timer {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> b.backoffTimer <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        b.backoffTimer = b.clock.<span style="color:#50fa7b">NewTimer</span>(b.<span style="color:#50fa7b">getNextBackoff</span>())
</span></span><span style="display:flex;"><span>    } <span style="color:#ff79c6">else</span> {
</span></span><span style="display:flex;"><span>        b.backoffTimer.<span style="color:#50fa7b">Reset</span>(b.<span style="color:#50fa7b">getNextBackoff</span>())
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> b.backoffTimer
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> jitteredBackoffManagerImpl <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    clock        clock.Clock
</span></span><span style="display:flex;"><span>    duration     time.Duration
</span></span><span style="display:flex;"><span>    jitter       <span style="color:#8be9fd">float64</span>
</span></span><span style="display:flex;"><span>    backoffTimer clock.Timer
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// NewJitteredBackoffManager returns a BackoffManager that backoffs with given duration plus given jitter. If the jitter
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// is negative, backoff will not be jittered.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">NewJitteredBackoffManager</span>(duration time.Duration, jitter <span style="color:#8be9fd">float64</span>, c clock.Clock) BackoffManager {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>jitteredBackoffManagerImpl{
</span></span><span style="display:flex;"><span>        clock:        c,
</span></span><span style="display:flex;"><span>        duration:     duration,
</span></span><span style="display:flex;"><span>        jitter:       jitter,
</span></span><span style="display:flex;"><span>        backoffTimer: <span style="color:#ff79c6">nil</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (j <span style="color:#ff79c6">*</span>jitteredBackoffManagerImpl) <span style="color:#50fa7b">getNextBackoff</span>() time.Duration {
</span></span><span style="display:flex;"><span>    jitteredPeriod <span style="color:#ff79c6">:=</span> j.duration
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> j.jitter &gt; <span style="color:#bd93f9">0.0</span> {
</span></span><span style="display:flex;"><span>        jitteredPeriod = <span style="color:#50fa7b">Jitter</span>(j.duration, j.jitter)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> jitteredPeriod
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Backoff implements BackoffManager.Backoff, it returns a timer so caller can block on the timer for jittered backoff.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// The returned timer must be drained before calling Backoff() the second time
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (j <span style="color:#ff79c6">*</span>jitteredBackoffManagerImpl) <span style="color:#50fa7b">Backoff</span>() clock.Timer {
</span></span><span style="display:flex;"><span>    backoff <span style="color:#ff79c6">:=</span> j.<span style="color:#50fa7b">getNextBackoff</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> j.backoffTimer <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        j.backoffTimer = j.clock.<span style="color:#50fa7b">NewTimer</span>(backoff)
</span></span><span style="display:flex;"><span>    } <span style="color:#ff79c6">else</span> {
</span></span><span style="display:flex;"><span>        j.backoffTimer.<span style="color:#50fa7b">Reset</span>(backoff)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> j.backoffTimer
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// ExponentialBackoff repeats a condition check with exponential backoff.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// It repeatedly checks the condition and then sleeps, using `backoff.Step()`
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// to determine the length of the sleep and adjust Duration and Steps.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// Stops and returns as soon as:
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// 1. the condition check returns true or an error,
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// 2. `backoff.Steps` checks of the condition have been done, or
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// 3. a sleep truncated by the cap on duration has been completed.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// In case (1) the returned error is what the condition function returned.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// In all other cases, ErrWaitTimeout is returned.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">ExponentialBackoff</span>(backoff Backoff, condition ConditionFunc) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> backoff.Steps &gt; <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> ok, err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">runConditionWithCrashProtection</span>(condition); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> <span style="color:#ff79c6">||</span> ok {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> backoff.Steps <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">1</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">break</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        time.<span style="color:#50fa7b">Sleep</span>(backoff.<span style="color:#50fa7b">Step</span>())
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> ErrWaitTimeout
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Poll tries a condition func until it returns true, an error, or the timeout
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// is reached.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// Poll always waits the interval before the run of &#39;condition&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// &#39;condition&#39; will always be invoked at least once.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// Some intervals may be missed if the condition takes too long or the time
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// window is too short.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// If you want to Poll something forever, see PollInfinite.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">Poll</span>(interval, timeout time.Duration, condition ConditionFunc) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">PollWithContext</span>(context.<span style="color:#50fa7b">Background</span>(), interval, timeout, condition.<span style="color:#50fa7b">WithContext</span>())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// PollWithContext tries a condition func until it returns true, an error,
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// or when the context expires or the timeout is reached, whichever
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// happens first.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// PollWithContext always waits the interval before the run of &#39;condition&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// &#39;condition&#39; will always be invoked at least once.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// Some intervals may be missed if the condition takes too long or the time
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// window is too short.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// If you want to Poll something forever, see PollInfinite.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">PollWithContext</span>(ctx context.Context, interval, timeout time.Duration, condition ConditionWithContextFunc) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">poll</span>(ctx, <span style="color:#ff79c6">false</span>, <span style="color:#50fa7b">poller</span>(interval, timeout), condition)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// PollUntil tries a condition func until it returns true, an error or stopCh is
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// closed.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// PollUntil always waits interval before the first run of &#39;condition&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// &#39;condition&#39; will always be invoked at least once.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">PollUntil</span>(interval time.Duration, condition ConditionFunc, stopCh <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    ctx, cancel <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">contextForChannel</span>(stopCh)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">defer</span> <span style="color:#50fa7b">cancel</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">PollUntilWithContext</span>(ctx, interval, condition.<span style="color:#50fa7b">WithContext</span>())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// PollUntilWithContext tries a condition func until it returns true,
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// an error or the specified context is cancelled or expired.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// PollUntilWithContext always waits interval before the first run of &#39;condition&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// &#39;condition&#39; will always be invoked at least once.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">PollUntilWithContext</span>(ctx context.Context, interval time.Duration, condition ConditionWithContextFunc) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">poll</span>(ctx, <span style="color:#ff79c6">false</span>, <span style="color:#50fa7b">poller</span>(interval, <span style="color:#bd93f9">0</span>), condition)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// PollInfinite tries a condition func until it returns true or an error
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// PollInfinite always waits the interval before the run of &#39;condition&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// Some intervals may be missed if the condition takes too long or the time
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// window is too short.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">PollInfinite</span>(interval time.Duration, condition ConditionFunc) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">PollInfiniteWithContext</span>(context.<span style="color:#50fa7b">Background</span>(), interval, condition.<span style="color:#50fa7b">WithContext</span>())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// PollInfiniteWithContext tries a condition func until it returns true or an error
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// PollInfiniteWithContext always waits the interval before the run of &#39;condition&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// Some intervals may be missed if the condition takes too long or the time
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// window is too short.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">PollInfiniteWithContext</span>(ctx context.Context, interval time.Duration, condition ConditionWithContextFunc) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">poll</span>(ctx, <span style="color:#ff79c6">false</span>, <span style="color:#50fa7b">poller</span>(interval, <span style="color:#bd93f9">0</span>), condition)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// PollImmediate tries a condition func until it returns true, an error, or the timeout
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// is reached.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// PollImmediate always checks &#39;condition&#39; before waiting for the interval. &#39;condition&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// will always be invoked at least once.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// Some intervals may be missed if the condition takes too long or the time
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// window is too short.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// If you want to immediately Poll something forever, see PollImmediateInfinite.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">PollImmediate</span>(interval, timeout time.Duration, condition ConditionFunc) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">PollImmediateWithContext</span>(context.<span style="color:#50fa7b">Background</span>(), interval, timeout, condition.<span style="color:#50fa7b">WithContext</span>())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// PollImmediateWithContext tries a condition func until it returns true, an error,
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// or the timeout is reached or the specified context expires, whichever happens first.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// PollImmediateWithContext always checks &#39;condition&#39; before waiting for the interval.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// &#39;condition&#39; will always be invoked at least once.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// Some intervals may be missed if the condition takes too long or the time
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// window is too short.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// If you want to immediately Poll something forever, see PollImmediateInfinite.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">PollImmediateWithContext</span>(ctx context.Context, interval, timeout time.Duration, condition ConditionWithContextFunc) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">poll</span>(ctx, <span style="color:#ff79c6">true</span>, <span style="color:#50fa7b">poller</span>(interval, timeout), condition)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// PollImmediateUntil tries a condition func until it returns true, an error or stopCh is closed.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// PollImmediateUntil runs the &#39;condition&#39; before waiting for the interval.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// &#39;condition&#39; will always be invoked at least once.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">PollImmediateUntil</span>(interval time.Duration, condition ConditionFunc, stopCh <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    ctx, cancel <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">contextForChannel</span>(stopCh)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">defer</span> <span style="color:#50fa7b">cancel</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">PollImmediateUntilWithContext</span>(ctx, interval, condition.<span style="color:#50fa7b">WithContext</span>())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// PollImmediateUntilWithContext tries a condition func until it returns true,
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// an error or the specified context is cancelled or expired.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// PollImmediateUntilWithContext runs the &#39;condition&#39; before waiting for the interval.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// &#39;condition&#39; will always be invoked at least once.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">PollImmediateUntilWithContext</span>(ctx context.Context, interval time.Duration, condition ConditionWithContextFunc) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">poll</span>(ctx, <span style="color:#ff79c6">true</span>, <span style="color:#50fa7b">poller</span>(interval, <span style="color:#bd93f9">0</span>), condition)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// PollImmediateInfinite tries a condition func until it returns true or an error
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// PollImmediateInfinite runs the &#39;condition&#39; before waiting for the interval.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// Some intervals may be missed if the condition takes too long or the time
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// window is too short.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">PollImmediateInfinite</span>(interval time.Duration, condition ConditionFunc) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">PollImmediateInfiniteWithContext</span>(context.<span style="color:#50fa7b">Background</span>(), interval, condition.<span style="color:#50fa7b">WithContext</span>())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// PollImmediateInfiniteWithContext tries a condition func until it returns true
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// or an error or the specified context gets cancelled or expired.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// PollImmediateInfiniteWithContext runs the &#39;condition&#39; before waiting for the interval.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// Some intervals may be missed if the condition takes too long or the time
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// window is too short.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">PollImmediateInfiniteWithContext</span>(ctx context.Context, interval time.Duration, condition ConditionWithContextFunc) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">poll</span>(ctx, <span style="color:#ff79c6">true</span>, <span style="color:#50fa7b">poller</span>(interval, <span style="color:#bd93f9">0</span>), condition)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Internally used, each of the the public &#39;Poll*&#39; function defined in this
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// package should invoke this internal function with appropriate parameters.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// ctx: the context specified by the caller, for infinite polling pass
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// a context that never gets cancelled or expired.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// immediate: if true, the &#39;condition&#39; will be invoked before waiting for the interval,
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// in this case &#39;condition&#39; will always be invoked at least once.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// wait: user specified WaitFunc function that controls at what interval the condition
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// function should be invoked periodically and whether it is bound by a timeout.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// condition: user specified ConditionWithContextFunc function.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">poll</span>(ctx context.Context, immediate <span style="color:#8be9fd">bool</span>, wait WaitWithContextFunc, condition ConditionWithContextFunc) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> immediate {
</span></span><span style="display:flex;"><span>        done, err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">runConditionWithCrashProtectionWithContext</span>(ctx, condition)
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> done {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">select</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span>ctx.<span style="color:#50fa7b">Done</span>():
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// returning ctx.Err() will break backward compatibility
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">return</span> ErrWaitTimeout
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">default</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">WaitForWithContext</span>(ctx, wait, condition)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// WaitFunc creates a channel that receives an item every time a test
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// should be executed and is closed when the last test should be invoked.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> WaitFunc <span style="color:#8be9fd;font-style:italic">func</span>(done <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}) <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// WithContext converts the WaitFunc to an equivalent WaitWithContextFunc
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (w WaitFunc) <span style="color:#50fa7b">WithContext</span>() WaitWithContextFunc {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">func</span>(ctx context.Context) <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{} {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">w</span>(ctx.<span style="color:#50fa7b">Done</span>())
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// WaitWithContextFunc creates a channel that receives an item every time a test
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// should be executed and is closed when the last test should be invoked.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// When the specified context gets cancelled or expires the function
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// stops sending item and returns immediately.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> WaitWithContextFunc <span style="color:#8be9fd;font-style:italic">func</span>(ctx context.Context) <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// WaitFor continually checks &#39;fn&#39; as driven by &#39;wait&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// WaitFor gets a channel from &#39;wait()&#39;&#39;, and then invokes &#39;fn&#39; once for every value
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// placed on the channel and once more when the channel is closed. If the channel is closed
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// and &#39;fn&#39; returns false without error, WaitFor returns ErrWaitTimeout.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// If &#39;fn&#39; returns an error the loop ends and that error is returned. If
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// &#39;fn&#39; returns true the loop ends and nil is returned.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// ErrWaitTimeout will be returned if the &#39;done&#39; channel is closed without fn ever
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// returning true.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// When the done channel is closed, because the golang `select` statement is
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// &#34;uniform pseudo-random&#34;, the `fn` might still run one or multiple time,
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// though eventually `WaitFor` will return.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">WaitFor</span>(wait WaitFunc, fn ConditionFunc, done <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    ctx, cancel <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">contextForChannel</span>(done)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">defer</span> <span style="color:#50fa7b">cancel</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">WaitForWithContext</span>(ctx, wait.<span style="color:#50fa7b">WithContext</span>(), fn.<span style="color:#50fa7b">WithContext</span>())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// WaitForWithContext continually checks &#39;fn&#39; as driven by &#39;wait&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// WaitForWithContext gets a channel from &#39;wait()&#39;&#39;, and then invokes &#39;fn&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// once for every value placed on the channel and once more when the
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// channel is closed. If the channel is closed and &#39;fn&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// returns false without error, WaitForWithContext returns ErrWaitTimeout.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// If &#39;fn&#39; returns an error the loop ends and that error is returned. If
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// &#39;fn&#39; returns true the loop ends and nil is returned.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// context.Canceled will be returned if the ctx.Done() channel is closed
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// without fn ever returning true.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// When the ctx.Done() channel is closed, because the golang `select` statement is
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// &#34;uniform pseudo-random&#34;, the `fn` might still run one or multiple times,
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// though eventually `WaitForWithContext` will return.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">WaitForWithContext</span>(ctx context.Context, wait WaitWithContextFunc, fn ConditionWithContextFunc) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    waitCtx, cancel <span style="color:#ff79c6">:=</span> context.<span style="color:#50fa7b">WithCancel</span>(context.<span style="color:#50fa7b">Background</span>())
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">defer</span> <span style="color:#50fa7b">cancel</span>()
</span></span><span style="display:flex;"><span>    c <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">wait</span>(waitCtx)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">select</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">case</span> _, open <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&lt;-</span>c:
</span></span><span style="display:flex;"><span>            ok, err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">runConditionWithCrashProtectionWithContext</span>(ctx, fn)
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> ok {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> !open {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">return</span> ErrWaitTimeout
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span>ctx.<span style="color:#50fa7b">Done</span>():
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// returning ctx.Err() will break backward compatibility
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">return</span> ErrWaitTimeout
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// poller returns a WaitFunc that will send to the channel every interval until
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// timeout has elapsed and then closes the channel.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// Over very short intervals you may receive no ticks before the channel is
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// closed. A timeout of 0 is interpreted as an infinity, and in such a case
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// it would be the caller&#39;s responsibility to close the done channel.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// Failure to do so would result in a leaked goroutine.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">//
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// Output ticks are not buffered. If the channel is not ready to receive an
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// item, the tick is skipped.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">poller</span>(interval, timeout time.Duration) WaitWithContextFunc {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">WaitWithContextFunc</span>(<span style="color:#8be9fd;font-style:italic">func</span>(ctx context.Context) <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{} {
</span></span><span style="display:flex;"><span>        ch <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">defer</span> <span style="color:#8be9fd;font-style:italic">close</span>(ch)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            tick <span style="color:#ff79c6">:=</span> time.<span style="color:#50fa7b">NewTicker</span>(interval)
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">defer</span> tick.<span style="color:#50fa7b">Stop</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">var</span> after <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> time.Time
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> timeout <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// time.After is more convenient, but it
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#6272a4">// potentially leaves timers around much longer
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#6272a4">// than necessary if we exit early.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                timer <span style="color:#ff79c6">:=</span> time.<span style="color:#50fa7b">NewTimer</span>(timeout)
</span></span><span style="display:flex;"><span>                after = timer.C
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">defer</span> timer.<span style="color:#50fa7b">Stop</span>()
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">select</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span>tick.C:
</span></span><span style="display:flex;"><span>                    <span style="color:#6272a4">// If the consumer isn&#39;t ready for this signal drop it and
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                    <span style="color:#6272a4">// check the other channels.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                    <span style="color:#ff79c6">select</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">case</span> ch <span style="color:#ff79c6">&lt;-</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}{}:
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">default</span>:
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span>after:
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">return</span>
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span>ctx.<span style="color:#50fa7b">Done</span>():
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">return</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> ch
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// ExponentialBackoffWithContext works with a request context and a Backoff. It ensures that the retry wait never
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// exceeds the deadline specified by the request context.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">ExponentialBackoffWithContext</span>(ctx context.Context, backoff Backoff, condition ConditionFunc) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> backoff.Steps &gt; <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">select</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span>ctx.<span style="color:#50fa7b">Done</span>():
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> ctx.<span style="color:#50fa7b">Err</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">default</span>:
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> ok, err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">runConditionWithCrashProtection</span>(condition); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> <span style="color:#ff79c6">||</span> ok {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> backoff.Steps <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">1</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">break</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        waitBeforeRetry <span style="color:#ff79c6">:=</span> backoff.<span style="color:#50fa7b">Step</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">select</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span>ctx.<span style="color:#50fa7b">Done</span>():
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> ctx.<span style="color:#50fa7b">Err</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span>time.<span style="color:#50fa7b">After</span>(waitBeforeRetry):
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> ErrWaitTimeout
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="捕获goroutine异常">捕获Goroutine异常</h1>
<h2 id="无缓冲channel实现">无缓冲channel实现</h2>
<p>定义一个包含Error的struct，再定义一个无缓冲的channel实现同步传递</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> Result <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    Error <span style="color:#8be9fd">error</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">updateNode</span>(node <span style="color:#8be9fd">string</span>) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    nodeList <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>([]<span style="color:#8be9fd">string</span>, <span style="color:#bd93f9">10</span>)
</span></span><span style="display:flex;"><span>    checkStatus <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">func</span>(done <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">interface</span>{}, nodeList <span style="color:#ff79c6">...</span><span style="color:#8be9fd">string</span>) <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> Result {
</span></span><span style="display:flex;"><span>        results <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> Result)
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">defer</span> <span style="color:#8be9fd;font-style:italic">close</span>(results)
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">for</span> _, node <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> nodeList {
</span></span><span style="display:flex;"><span>                <span style="color:#8be9fd;font-style:italic">var</span> result Result
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// update node
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">updateNode</span>(node)
</span></span><span style="display:flex;"><span>                result = Result{Error: err}
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">select</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span> done:
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">return</span>
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">case</span> results <span style="color:#ff79c6">&lt;-</span> result:
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }()
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> results
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    done <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">interface</span>{})
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">defer</span> <span style="color:#8be9fd;font-style:italic">close</span>(done)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> result <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> <span style="color:#50fa7b">checkStatus</span>(done, nodeList<span style="color:#ff79c6">...</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> result.Error <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">panic</span>(result.Error)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="sync-errgroup实现">sync errgroup实现</h2>
<p>使用sync包提供的errgroup, errgroup提供同步，error收集，可使用context取消正处于任务中运行的goroutines.
errgroup可直接看源码，源码比较简短</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    ctx, cancel <span style="color:#ff79c6">:=</span> context.<span style="color:#50fa7b">WithTimeout</span>(context.<span style="color:#50fa7b">Background</span>(), thresholdTime)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">defer</span> <span style="color:#50fa7b">cancel</span>()
</span></span><span style="display:flex;"><span>    g, ctx <span style="color:#ff79c6">:=</span> errgroup.<span style="color:#50fa7b">WithContext</span>(ctx)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> felixLive {
</span></span><span style="display:flex;"><span>        g.<span style="color:#50fa7b">Go</span>(<span style="color:#8be9fd;font-style:italic">func</span>() <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">checkFelixHealth</span>(ctx, felixLivenessEp, <span style="color:#f1fa8c">&#34;liveness&#34;</span>); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">return</span> fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;calico/node is not ready: Felix is not live: %+v&#34;</span>, err)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> birdLive {
</span></span><span style="display:flex;"><span>        g.<span style="color:#50fa7b">Go</span>(<span style="color:#8be9fd;font-style:italic">func</span>() <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">checkServiceIsLive</span>([]<span style="color:#8be9fd">string</span>{<span style="color:#f1fa8c">&#34;confd&#34;</span>, <span style="color:#f1fa8c">&#34;bird&#34;</span>}); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">return</span> fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;calico/node is not ready: bird/confd is not live: %+v&#34;</span>, err)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> bird6Live {
</span></span><span style="display:flex;"><span>        g.<span style="color:#50fa7b">Go</span>(<span style="color:#8be9fd;font-style:italic">func</span>() <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">checkServiceIsLive</span>([]<span style="color:#8be9fd">string</span>{<span style="color:#f1fa8c">&#34;confd&#34;</span>, <span style="color:#f1fa8c">&#34;bird6&#34;</span>}); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">return</span> fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;calico/node is not ready: bird6/confd is not live: %+v&#34;</span>, err)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> felixReady {
</span></span><span style="display:flex;"><span>        g.<span style="color:#50fa7b">Go</span>(<span style="color:#8be9fd;font-style:italic">func</span>() <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">checkFelixHealth</span>(ctx, felixReadinessEp, <span style="color:#f1fa8c">&#34;readiness&#34;</span>); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">return</span> fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;calico/node is not ready: felix is not ready: %+v&#34;</span>, err)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> bird {
</span></span><span style="display:flex;"><span>        g.<span style="color:#50fa7b">Go</span>(<span style="color:#8be9fd;font-style:italic">func</span>() <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">checkBIRDReady</span>(<span style="color:#f1fa8c">&#34;4&#34;</span>, thresholdTime); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">return</span> fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;calico/node is not ready: BIRD is not ready: %+v&#34;</span>, err)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> bird6 {
</span></span><span style="display:flex;"><span>        g.<span style="color:#50fa7b">Go</span>(<span style="color:#8be9fd;font-style:italic">func</span>() <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">checkBIRDReady</span>(<span style="color:#f1fa8c">&#34;6&#34;</span>, thresholdTime); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">return</span> fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;calico/node is not ready: BIRD6 is not ready: %+v&#34;</span>, err)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> g.<span style="color:#50fa7b">Wait</span>(); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        fmt.<span style="color:#50fa7b">Printf</span>(<span style="color:#f1fa8c">&#34;%s&#34;</span>, err)
</span></span><span style="display:flex;"><span>        os.<span style="color:#50fa7b">Exit</span>(<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="加锁slice实现">加锁Slice实现</h2>
<p>定义一个error类型的Slice, 通过加读写锁对它进行操作</p>
<p>引用来自：kubernetes/pkg/scheduler/core/generic_scheduler.go的代码片段</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">var</span> (
</span></span><span style="display:flex;"><span>        mu   = sync.Mutex{}
</span></span><span style="display:flex;"><span>        wg   = sync.WaitGroup{}
</span></span><span style="display:flex;"><span>        errs []<span style="color:#8be9fd">error</span>
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    appendError <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">func</span>(err <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>        mu.<span style="color:#50fa7b">Lock</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">defer</span> mu.<span style="color:#50fa7b">Unlock</span>()
</span></span><span style="display:flex;"><span>        errs = <span style="color:#8be9fd;font-style:italic">append</span>(errs, err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    results <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>([]schedulerapi.HostPriorityList, <span style="color:#8be9fd;font-style:italic">len</span>(priorityConfigs), <span style="color:#8be9fd;font-style:italic">len</span>(priorityConfigs))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// DEPRECATED: we can remove this when all priorityConfigs implement the
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// Map-Reduce pattern.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> priorityConfigs {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> priorityConfigs[i].Function <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>            wg.<span style="color:#50fa7b">Add</span>(<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>(index <span style="color:#8be9fd">int</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">defer</span> wg.<span style="color:#50fa7b">Done</span>()
</span></span><span style="display:flex;"><span>                <span style="color:#8be9fd;font-style:italic">var</span> err <span style="color:#8be9fd">error</span>
</span></span><span style="display:flex;"><span>                results[index], err = priorityConfigs[index].<span style="color:#50fa7b">Function</span>(pod, nodeNameToInfo, nodes)
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#50fa7b">appendError</span>(err)
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }(i)
</span></span><span style="display:flex;"><span>        } <span style="color:#ff79c6">else</span> {
</span></span><span style="display:flex;"><span>            results[i] = <span style="color:#8be9fd;font-style:italic">make</span>(schedulerapi.HostPriorityList, <span style="color:#8be9fd;font-style:italic">len</span>(nodes))
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// Wait for all computations to be finished.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    wg.<span style="color:#50fa7b">Wait</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">len</span>(errs) <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> schedulerapi.HostPriorityList{}, errors.<span style="color:#50fa7b">NewAggregate</span>(errs)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="goroutine池">goroutine池</h1>
<p>通过sync.WaitGroup + channel控制数量</p>
<p>引用来自：k8s.io/client-go/util/workqueue/parallelizer.go</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> workqueue
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;context&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;sync&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    utilruntime <span style="color:#f1fa8c">&#34;k8s.io/apimachinery/pkg/util/runtime&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> DoWorkPieceFunc <span style="color:#8be9fd;font-style:italic">func</span>(piece <span style="color:#8be9fd">int</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> options <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    chunkSize <span style="color:#8be9fd">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> Options <span style="color:#8be9fd;font-style:italic">func</span>(<span style="color:#ff79c6">*</span>options)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// WithChunkSize allows to set chunks of work items to the workers, rather than
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// processing one by one.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// It is recommended to use this option if the number of pieces significantly
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// higher than the number of workers and the work done for each item is small.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">WithChunkSize</span>(c <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd;font-style:italic">func</span>(<span style="color:#ff79c6">*</span>options) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">func</span>(o <span style="color:#ff79c6">*</span>options) {
</span></span><span style="display:flex;"><span>        o.chunkSize = c
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// ParallelizeUntil is a framework that allows for parallelizing N
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// independent pieces of work until done or the context is canceled.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">ParallelizeUntil</span>(ctx context.Context, workers, pieces <span style="color:#8be9fd">int</span>, doWorkPiece DoWorkPieceFunc, opts <span style="color:#ff79c6">...</span>Options) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> pieces <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    o <span style="color:#ff79c6">:=</span> options{}
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> _, opt <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> opts {
</span></span><span style="display:flex;"><span>        <span style="color:#50fa7b">opt</span>(<span style="color:#ff79c6">&amp;</span>o)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    chunkSize <span style="color:#ff79c6">:=</span> o.chunkSize
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> chunkSize &lt; <span style="color:#bd93f9">1</span> {
</span></span><span style="display:flex;"><span>        chunkSize = <span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    chunks <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">ceilDiv</span>(pieces, chunkSize)
</span></span><span style="display:flex;"><span>    toProcess <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd">int</span>, chunks)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; i &lt; chunks; i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>        toProcess <span style="color:#ff79c6">&lt;-</span> i
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//不影响读
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd;font-style:italic">close</span>(toProcess)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">var</span> stop <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> ctx <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        stop = ctx.<span style="color:#50fa7b">Done</span>()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> chunks &lt; workers {
</span></span><span style="display:flex;"><span>        workers = chunks
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    wg <span style="color:#ff79c6">:=</span> sync.WaitGroup{}
</span></span><span style="display:flex;"><span>    wg.<span style="color:#50fa7b">Add</span>(workers)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; i &lt; workers; i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">defer</span> utilruntime.<span style="color:#50fa7b">HandleCrash</span>()
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">defer</span> wg.<span style="color:#50fa7b">Done</span>()
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">//并发从channel中读取
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">for</span> chunk <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> toProcess {
</span></span><span style="display:flex;"><span>                start <span style="color:#ff79c6">:=</span> chunk <span style="color:#ff79c6">*</span> chunkSize
</span></span><span style="display:flex;"><span>                end <span style="color:#ff79c6">:=</span> start <span style="color:#ff79c6">+</span> chunkSize
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">if</span> end &gt; pieces {
</span></span><span style="display:flex;"><span>                    end = pieces
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">for</span> p <span style="color:#ff79c6">:=</span> start; p &lt; end; p<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">select</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span>stop:
</span></span><span style="display:flex;"><span>                        <span style="color:#ff79c6">return</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">default</span>:
</span></span><span style="display:flex;"><span>                        <span style="color:#50fa7b">doWorkPiece</span>(p)
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    wg.<span style="color:#50fa7b">Wait</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">ceilDiv</span>(a, b <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> (a <span style="color:#ff79c6">+</span> b <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">/</span> b
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="无锁栈">无锁栈</h1>
<h2 id="atomic实现">atomic实现</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;sync/atomic&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;unsafe&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// LFStack 无锁栈
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// 使用链表实现
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> LFStack <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    head unsafe.Pointer <span style="color:#6272a4">// 栈顶
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Node 节点
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> Node <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    val  <span style="color:#8be9fd">int32</span>
</span></span><span style="display:flex;"><span>    next unsafe.Pointer
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// NewLFStack NewLFStack
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">NewLFStack</span>() <span style="color:#ff79c6">*</span>LFStack {
</span></span><span style="display:flex;"><span>    n <span style="color:#ff79c6">:=</span> unsafe.<span style="color:#50fa7b">Pointer</span>(<span style="color:#ff79c6">&amp;</span>Node{})
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>LFStack{head: n}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Push 入栈
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (s <span style="color:#ff79c6">*</span>LFStack) <span style="color:#50fa7b">Push</span>(v <span style="color:#8be9fd">int32</span>) {
</span></span><span style="display:flex;"><span>    n <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&amp;</span>Node{val: v}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 先取出栈顶
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        old <span style="color:#ff79c6">:=</span> atomic.<span style="color:#50fa7b">LoadPointer</span>(<span style="color:#ff79c6">&amp;</span>s.head)
</span></span><span style="display:flex;"><span>        n.next = old
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> atomic.<span style="color:#50fa7b">CompareAndSwapPointer</span>(<span style="color:#ff79c6">&amp;</span>s.head, old, unsafe.<span style="color:#50fa7b">Pointer</span>(n)) {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Pop 出栈，没有数据时返回 nil
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (s <span style="color:#ff79c6">*</span>LFStack) <span style="color:#50fa7b">Pop</span>() <span style="color:#8be9fd">int32</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 先取出栈顶
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        old <span style="color:#ff79c6">:=</span> atomic.<span style="color:#50fa7b">LoadPointer</span>(<span style="color:#ff79c6">&amp;</span>s.head)
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> old <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        oldNode <span style="color:#ff79c6">:=</span> (<span style="color:#ff79c6">*</span>Node)(old)
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 取出下一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        next <span style="color:#ff79c6">:=</span> atomic.<span style="color:#50fa7b">LoadPointer</span>(<span style="color:#ff79c6">&amp;</span>oldNode.next)
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 重置栈顶
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">if</span> atomic.<span style="color:#50fa7b">CompareAndSwapPointer</span>(<span style="color:#ff79c6">&amp;</span>s.head, old, next) {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> oldNode.val
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="消费者-生产者-工作队列模式">消费者-生产者-工作队列模式</h1>
<h2 id="channel实现">channel实现</h2>
<p>一个任务的执行过程如下：</p>
<ul>
<li>JobQueue &lt;- work  新任务入队</li>
<li>job := &lt;-JobQueue: 调度中心收到任务</li>
<li>jobChannel := &lt;-d.WorkerPool 从工作者池取到一个工作者</li>
<li>jobChannel &lt;- job 任务给到工作者</li>
<li>job := &lt;-w.JobChannel 工作者取出任务</li>
<li>{{1}} 执行任务</li>
<li>w.WorkerPool &lt;- w.JobChannel 工作者在放回工作者池</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;reflect&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;runtime&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">var</span> (
</span></span><span style="display:flex;"><span>    MaxWorker = <span style="color:#bd93f9">10</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> Payload <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    Num <span style="color:#8be9fd">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//待执行的工作
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> Job <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    Payload Payload
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//任务channal
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">var</span> JobQueue <span style="color:#8be9fd;font-style:italic">chan</span> Job
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//执行任务的工作者单元
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> Worker <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    WorkerPool <span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">chan</span> Job <span style="color:#6272a4">//工作者池--每个元素是一个工作者的私有任务channal
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    JobChannel <span style="color:#8be9fd;font-style:italic">chan</span> Job      <span style="color:#6272a4">//每个工作者单元包含一个任务管道 用于获取任务
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    quit       <span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd">bool</span>     <span style="color:#6272a4">//退出信号
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    no         <span style="color:#8be9fd">int</span>           <span style="color:#6272a4">//编号
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//创建一个新工作者单元
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">NewWorker</span>(workerPool <span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">chan</span> Job, no <span style="color:#8be9fd">int</span>) Worker {
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;创建了工作者&#34;</span>, no)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> Worker{
</span></span><span style="display:flex;"><span>        WorkerPool: workerPool,
</span></span><span style="display:flex;"><span>        JobChannel: <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> Job),
</span></span><span style="display:flex;"><span>        quit:       <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd">bool</span>),
</span></span><span style="display:flex;"><span>        no:         no,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//循环监听任务和结束信号
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (w Worker) <span style="color:#50fa7b">Start</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// register the current worker into the worker queue.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            w.WorkerPool <span style="color:#ff79c6">&lt;-</span> w.JobChannel
</span></span><span style="display:flex;"><span>            fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;w.WorkerPool &lt;- w.JobChannel&#34;</span>, w)
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">select</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">case</span> job <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&lt;-</span>w.JobChannel:
</span></span><span style="display:flex;"><span>                fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;job := &lt;-w.JobChannel&#34;</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// 收到任务
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                fmt.<span style="color:#50fa7b">Println</span>(job)
</span></span><span style="display:flex;"><span>                time.<span style="color:#50fa7b">Sleep</span>(<span style="color:#bd93f9">100</span> <span style="color:#ff79c6">*</span> time.Second)
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span>w.quit:
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// 收到退出信号
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#ff79c6">return</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// 停止信号
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (w Worker) <span style="color:#50fa7b">Stop</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>        w.quit <span style="color:#ff79c6">&lt;-</span> <span style="color:#ff79c6">true</span>
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//调度中心
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> Dispatcher <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//工作者池
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    WorkerPool <span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">chan</span> Job
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//工作者数量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    MaxWorkers <span style="color:#8be9fd">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//创建调度中心
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">NewDispatcher</span>(maxWorkers <span style="color:#8be9fd">int</span>) <span style="color:#ff79c6">*</span>Dispatcher {
</span></span><span style="display:flex;"><span>    pool <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">chan</span> Job, maxWorkers)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>Dispatcher{WorkerPool: pool, MaxWorkers: maxWorkers}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//工作者池的初始化
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (d <span style="color:#ff79c6">*</span>Dispatcher) <span style="color:#50fa7b">Run</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// starting n number of workers
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">1</span>; i &lt; d.MaxWorkers<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>; i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>        worker <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">NewWorker</span>(d.WorkerPool, i)
</span></span><span style="display:flex;"><span>        worker.<span style="color:#50fa7b">Start</span>()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">go</span> d.<span style="color:#50fa7b">dispatch</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//调度
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (d <span style="color:#ff79c6">*</span>Dispatcher) <span style="color:#50fa7b">dispatch</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">select</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">case</span> job <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&lt;-</span>JobQueue:
</span></span><span style="display:flex;"><span>            fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;job := &lt;-JobQueue:&#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>(job Job) {
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">//等待空闲worker (任务多的时候会阻塞这里)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                jobChannel <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&lt;-</span>d.WorkerPool
</span></span><span style="display:flex;"><span>                fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;jobChannel := &lt;-d.WorkerPool&#34;</span>, reflect.<span style="color:#50fa7b">TypeOf</span>(jobChannel))
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// 将任务放到上述woker的私有任务channal中
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                jobChannel <span style="color:#ff79c6">&lt;-</span> job
</span></span><span style="display:flex;"><span>                fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;jobChannel &lt;- job&#34;</span>)
</span></span><span style="display:flex;"><span>            }(job)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    JobQueue = <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> Job, <span style="color:#bd93f9">10</span>)
</span></span><span style="display:flex;"><span>    dispatcher <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">NewDispatcher</span>(MaxWorker)
</span></span><span style="display:flex;"><span>    dispatcher.<span style="color:#50fa7b">Run</span>()
</span></span><span style="display:flex;"><span>    time.<span style="color:#50fa7b">Sleep</span>(<span style="color:#bd93f9">1</span> <span style="color:#ff79c6">*</span> time.Second)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">go</span> <span style="color:#50fa7b">addQueue</span>()
</span></span><span style="display:flex;"><span>    time.<span style="color:#50fa7b">Sleep</span>(<span style="color:#bd93f9">1000</span> <span style="color:#ff79c6">*</span> time.Second)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">addQueue</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; i &lt; <span style="color:#bd93f9">20</span>; i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 新建一个任务
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        payLoad <span style="color:#ff79c6">:=</span> Payload{Num: i}
</span></span><span style="display:flex;"><span>        work <span style="color:#ff79c6">:=</span> Job{Payload: payLoad}
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 任务放入任务队列channal
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        JobQueue <span style="color:#ff79c6">&lt;-</span> work
</span></span><span style="display:flex;"><span>        fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;JobQueue &lt;- work&#34;</span>, i)
</span></span><span style="display:flex;"><span>        fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;当前协程数:&#34;</span>, runtime.<span style="color:#50fa7b">NumGoroutine</span>())
</span></span><span style="display:flex;"><span>        time.<span style="color:#50fa7b">Sleep</span>(<span style="color:#bd93f9">100</span> <span style="color:#ff79c6">*</span> time.Millisecond)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="控制并发数的channel实现">控制并发数的channel实现</h2>
<p>在job_worker基础上扩展，增加DispatchNumControl分发控制数，activeAccount worker活跃数控制，
不过会丢部分job</p>
<p>引用来自：http://blog.cocosdever.com/2018/08/22/goroutine-channel-Job-Worker-mode</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;runtime&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// 定义一些全局常量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">var</span> (
</span></span><span style="display:flex;"><span>    MaxWorker             = <span style="color:#bd93f9">10</span>
</span></span><span style="display:flex;"><span>    MaxDispatchNumControl = <span style="color:#bd93f9">20</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Payload 任务里面的负载
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> Payload <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    Num <span style="color:#8be9fd">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Job 任务结构体
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> Job <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    Payload Payload
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// JobQueue 定义全局Job队列, 新增加的任务就丢进该任务队列即可
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">var</span> JobQueue <span style="color:#8be9fd;font-style:italic">chan</span> Job
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// WorkerList 工作单元切片
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">var</span> WorkerList []<span style="color:#ff79c6">*</span>Worker
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//用于控制并发处理的协程数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">var</span> DispatchNumControl <span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd">bool</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">Limit</span>(job Job) <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">select</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span>time.<span style="color:#50fa7b">After</span>(time.Millisecond <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">100</span>):
</span></span><span style="display:flex;"><span>        fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;我很忙&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">false</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">case</span> DispatchNumControl <span style="color:#ff79c6">&lt;-</span> <span style="color:#ff79c6">true</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 任务放入全局任务队列channal
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        JobQueue <span style="color:#ff79c6">&lt;-</span> job
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">true</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Worker 工作者单元, 用于执行Job的单元, 数量有限, 由调度中心分配
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> Worker <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    WorkerPool <span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">chan</span> Job <span style="color:#6272a4">//存放JobChan的池子
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    JobChan    <span style="color:#8be9fd;font-style:italic">chan</span> Job
</span></span><span style="display:flex;"><span>    quit       <span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd">bool</span>
</span></span><span style="display:flex;"><span>    No         <span style="color:#8be9fd">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// NewWorker 创建工作单元
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">NewWorker</span>(workerPool <span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">chan</span> Job, no <span style="color:#8be9fd">int</span>) <span style="color:#ff79c6">*</span>Worker {
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;创建了工作者&#34;</span>, no)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>Worker{
</span></span><span style="display:flex;"><span>        WorkerPool: workerPool,
</span></span><span style="display:flex;"><span>        JobChan:    <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> Job),
</span></span><span style="display:flex;"><span>        quit:       <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd">bool</span>),
</span></span><span style="display:flex;"><span>        No:         no,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Start 开始工作
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (w <span style="color:#ff79c6">*</span>Worker) <span style="color:#50fa7b">Start</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// 注册JobChan到工作池中,  然后开始工作循环
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            w.WorkerPool <span style="color:#ff79c6">&lt;-</span> w.JobChan
</span></span><span style="display:flex;"><span>            fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;w.WorkerPool &lt;- w.JobChan | w:&#34;</span>, w)
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">//如果有工作进来就执行工作, 收到退出信号就退出
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">select</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">case</span> job <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&lt;-</span>w.JobChan:
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">//收到job, 开始工作
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;job := &lt;-w.JobChan&#34;</span>)
</span></span><span style="display:flex;"><span>                fmt.<span style="color:#50fa7b">Println</span>(job)
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">//完成之后释放控制中心额度
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#ff79c6">&lt;-</span>DispatchNumControl
</span></span><span style="display:flex;"><span>                time.<span style="color:#50fa7b">Sleep</span>(<span style="color:#bd93f9">5</span> <span style="color:#ff79c6">*</span> time.Second)
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span>w.quit:
</span></span><span style="display:flex;"><span>                fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;&lt;-w.Quit | w:&#34;</span>, w)
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">return</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Stop 暂停工作
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (w <span style="color:#ff79c6">*</span>Worker) <span style="color:#50fa7b">Stop</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>        w.quit <span style="color:#ff79c6">&lt;-</span> <span style="color:#ff79c6">true</span>
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Dispatcher 调度中心, 用于创建工作单元Worker, 安排Worker执行Job
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> Dispatcher <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    WorkerPool  <span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">chan</span> Job
</span></span><span style="display:flex;"><span>    MaxWorkers  <span style="color:#8be9fd">int</span>
</span></span><span style="display:flex;"><span>    ActiveCount <span style="color:#8be9fd">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// NewDispatcher 创建调度中心
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">NewDispatcher</span>(max <span style="color:#8be9fd">int</span>) <span style="color:#ff79c6">*</span>Dispatcher {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>Dispatcher{
</span></span><span style="display:flex;"><span>        WorkerPool: <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">chan</span> Job, max),
</span></span><span style="display:flex;"><span>        MaxWorkers: max,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// Run 根据MaxWorkers, 创建工作者, 同时让工作者运行起来
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (d <span style="color:#ff79c6">*</span>Dispatcher) <span style="color:#50fa7b">Run</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; i &lt; d.MaxWorkers; i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>        worker <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">NewWorker</span>(d.WorkerPool, i)
</span></span><span style="display:flex;"><span>        worker.<span style="color:#50fa7b">Start</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 将工作单元存进切片中
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        WorkerList[i] = worker
</span></span><span style="display:flex;"><span>        d.ActiveCount<span style="color:#ff79c6">++</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">go</span> d.<span style="color:#50fa7b">dispatcher</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// dispatcher 读取全局job队列, 开始分配任务
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (d <span style="color:#ff79c6">*</span>Dispatcher) <span style="color:#50fa7b">dispatcher</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">select</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">case</span> job <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&lt;-</span>JobQueue:
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>(job Job) {
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// 从池中找到一个空闲的JobChan, 如果没有空闲的就会堵塞
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                jobChan <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&lt;-</span>d.WorkerPool
</span></span><span style="display:flex;"><span>                fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;jobChan := &lt;-d.WorkerPool&#34;</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">//把job丢给工作者
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                jobChan <span style="color:#ff79c6">&lt;-</span> job
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">//每次丢进一个job给工作者之后, 就删除一个工作者, 直到工作者数量维持在5个
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;d.ActiveCount: &#34;</span>, d.ActiveCount)
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">if</span> d.ActiveCount &gt; <span style="color:#bd93f9">5</span> {
</span></span><span style="display:flex;"><span>                    worker <span style="color:#ff79c6">:=</span> WorkerList[d.ActiveCount<span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>]
</span></span><span style="display:flex;"><span>                    fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;worker := WorkerList[d.ActiveCount-1] | worker: &#34;</span>, worker)
</span></span><span style="display:flex;"><span>                    worker.<span style="color:#50fa7b">Stop</span>()
</span></span><span style="display:flex;"><span>                    d.ActiveCount<span style="color:#ff79c6">--</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }(job)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// AddQueue 往全局队列中添加job
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">AddQueue</span>(n <span style="color:#8be9fd">int</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; i &lt; n; i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>        job <span style="color:#ff79c6">:=</span> Job{Payload{i}}
</span></span><span style="display:flex;"><span>        fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;JobQueue &lt;- job&#34;</span>, job)
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 只有在DispatchNumControl缓冲还未满的时候, 才能将job加入到JobQueue中
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 因为一旦加入到JobQueue之后, 系统立马会将job从队头取出, 分配一个协程去单独处理后续的工作
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 为了避免协程数量过多, 所以使用Lmit函数做总体控制
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">if</span> <span style="color:#50fa7b">Limit</span>(job) {
</span></span><span style="display:flex;"><span>            fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;任务成功加入全局队列&#34;</span>)
</span></span><span style="display:flex;"><span>        } <span style="color:#ff79c6">else</span> {
</span></span><span style="display:flex;"><span>            fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;全局队列已满, 暂不处理任务&#34;</span>)
</span></span><span style="display:flex;"><span>            i<span style="color:#ff79c6">--</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;当前协程数:&#34;</span>, runtime.<span style="color:#50fa7b">NumGoroutine</span>())
</span></span><span style="display:flex;"><span>        time.<span style="color:#50fa7b">Sleep</span>(<span style="color:#bd93f9">200</span> <span style="color:#ff79c6">*</span> time.Millisecond)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    DispatchNumControl = <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd">bool</span>, MaxDispatchNumControl)
</span></span><span style="display:flex;"><span>    JobQueue = <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> Job)
</span></span><span style="display:flex;"><span>    WorkerList = <span style="color:#8be9fd;font-style:italic">make</span>([]<span style="color:#ff79c6">*</span>Worker, <span style="color:#bd93f9">10</span>)
</span></span><span style="display:flex;"><span>    disp <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">NewDispatcher</span>(MaxWorker)
</span></span><span style="display:flex;"><span>    disp.<span style="color:#50fa7b">Run</span>()
</span></span><span style="display:flex;"><span>    time.<span style="color:#50fa7b">Sleep</span>(<span style="color:#bd93f9">1</span> <span style="color:#ff79c6">*</span> time.Second)
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">AddQueue</span>(<span style="color:#bd93f9">100</span>)
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>()
</span></span><span style="display:flex;"><span>    time.<span style="color:#50fa7b">Sleep</span>(<span style="color:#bd93f9">1000</span> <span style="color:#ff79c6">*</span> time.Second)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="泛型编程">泛型编程</h1>
<p>Go 1.17版本开始支持泛型，再也不需要使用反射来实现了</p>
<h2 id="初体验">初体验</h2>
<p>使用[T any]来声明一个泛型，一个通用函数可实现打印不同类型的变量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> print[T any](arr []T) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> _, v <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> arr {
</span></span><span style="display:flex;"><span>        fmt.<span style="color:#50fa7b">Println</span>(v)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    str <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">string</span>{<span style="color:#f1fa8c">&#34;a&#34;</span>, <span style="color:#f1fa8c">&#34;b&#34;</span>, <span style="color:#f1fa8c">&#34;c&#34;</span>}
</span></span><span style="display:flex;"><span>    flat <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">float64</span>{<span style="color:#bd93f9">1.1</span>, <span style="color:#bd93f9">1.2</span>, <span style="color:#bd93f9">1.3</span>}
</span></span><span style="display:flex;"><span>    nums <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">int</span>{<span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">2</span>, <span style="color:#bd93f9">3</span>}
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">print</span>(str)
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">print</span>(flat)
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">print</span>(nums)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>运行需要加上<code>-gcflags=-G=3</code>编译参数(golang 1.18版本会成为默认)</p>
<pre tabindex="0"><code>go run -gcflags=-G=3 ./main.go
</code></pre><p>一个泛型实现的通用查询函数，使用[T comparable]的格式，comparable是一个接口类型，要求我们的类型需要支持<code>==</code>的操作</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> find[T comparable](arr []T, target T) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> k, v <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> arr {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> v <span style="color:#ff79c6">==</span> target {
</span></span><span style="display:flex;"><span>            fmt.<span style="color:#50fa7b">Printf</span>(<span style="color:#f1fa8c">&#34;found %v at %d\n&#34;</span>, target, k)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">find</span>([]<span style="color:#8be9fd">int</span>{<span style="color:#bd93f9">1</span>,<span style="color:#bd93f9">2</span>,<span style="color:#bd93f9">3</span>}, <span style="color:#bd93f9">2</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">find</span>([]<span style="color:#8be9fd">string</span>{<span style="color:#f1fa8c">&#34;a&#34;</span>,<span style="color:#f1fa8c">&#34;bcd&#34;</span>,<span style="color:#f1fa8c">&#34;efg&#34;</span>}, <span style="color:#f1fa8c">&#34;a&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个find函数依赖于数组，对于其它数据结构，比如链表、栈等需要重写</p>
<h2 id="泛型栈">泛型栈</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> stack [T any] []T
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span>(s <span style="color:#ff79c6">*</span>stack[T]) <span style="color:#50fa7b">push</span>(elem T) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">*</span>s = <span style="color:#8be9fd;font-style:italic">append</span>(<span style="color:#ff79c6">*</span>s, elem)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span>(s <span style="color:#ff79c6">*</span>stack[T]) <span style="color:#50fa7b">pop</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">len</span>(<span style="color:#ff79c6">*</span>s) &gt; <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">*</span>s = (<span style="color:#ff79c6">*</span>s)[:<span style="color:#8be9fd;font-style:italic">len</span>(<span style="color:#ff79c6">*</span>s)<span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//判断栈是否为空
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span>(s <span style="color:#ff79c6">*</span>stack[T]) <span style="color:#50fa7b">top</span>() <span style="color:#ff79c6">*</span>T{
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">len</span>(<span style="color:#ff79c6">*</span>s) &gt; <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>(<span style="color:#ff79c6">*</span>s)[<span style="color:#8be9fd;font-style:italic">len</span>(<span style="color:#ff79c6">*</span>s)<span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span>(s <span style="color:#ff79c6">*</span>stack[T]) <span style="color:#8be9fd;font-style:italic">len</span>() <span style="color:#8be9fd">int</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">len</span>(<span style="color:#ff79c6">*</span>s)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span>(s <span style="color:#ff79c6">*</span>stack[T]) <span style="color:#8be9fd;font-style:italic">print</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> _, elem <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> <span style="color:#ff79c6">*</span>s {
</span></span><span style="display:flex;"><span>        fmt.<span style="color:#50fa7b">Println</span>(elem)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    ss <span style="color:#ff79c6">:=</span> stack[<span style="color:#8be9fd">string</span>]{}
</span></span><span style="display:flex;"><span>    ss.<span style="color:#50fa7b">push</span>(<span style="color:#f1fa8c">&#34;a&#34;</span>)
</span></span><span style="display:flex;"><span>    ss.<span style="color:#50fa7b">push</span>(<span style="color:#f1fa8c">&#34;b&#34;</span>)
</span></span><span style="display:flex;"><span>    ss.<span style="color:#50fa7b">push</span>(<span style="color:#f1fa8c">&#34;c&#34;</span>)
</span></span><span style="display:flex;"><span>    ss.<span style="color:#8be9fd;font-style:italic">print</span>()
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Printf</span>(<span style="color:#f1fa8c">&#34;stack top is - %v\n&#34;</span>, <span style="color:#ff79c6">*</span>ss.<span style="color:#50fa7b">top</span>())
</span></span><span style="display:flex;"><span>    ss.<span style="color:#50fa7b">pop</span>()
</span></span><span style="display:flex;"><span>    ss.<span style="color:#50fa7b">pop</span>()
</span></span><span style="display:flex;"><span>    ss.<span style="color:#8be9fd;font-style:italic">print</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>为什么函数名都是小写？当前Go泛型函数不支持被其它包引用</p>
<h2 id="泛型双向链表">泛型双向链表</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> node[T comparable] <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    data T
</span></span><span style="display:flex;"><span>    prev <span style="color:#ff79c6">*</span>node[T]
</span></span><span style="display:flex;"><span>    next <span style="color:#ff79c6">*</span>node[T]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> list[T comparable] <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    head, tail <span style="color:#ff79c6">*</span>node[T]
</span></span><span style="display:flex;"><span>    len <span style="color:#8be9fd">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span>(l <span style="color:#ff79c6">*</span>list[T]) <span style="color:#50fa7b">isEmpty</span>() <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> l.head <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span> <span style="color:#ff79c6">&amp;&amp;</span> l.tail <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//从头插入
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span>(l <span style="color:#ff79c6">*</span>list[T]) <span style="color:#50fa7b">add</span>(data T) {
</span></span><span style="display:flex;"><span>    n <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&amp;</span>node[T]{
</span></span><span style="display:flex;"><span>        data: data,
</span></span><span style="display:flex;"><span>        prev: <span style="color:#ff79c6">nil</span>,
</span></span><span style="display:flex;"><span>        next: l.head,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> l.<span style="color:#50fa7b">isEmpty</span>() {
</span></span><span style="display:flex;"><span>        l.head = n
</span></span><span style="display:flex;"><span>        l.tail = n
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    l.head.prev = n
</span></span><span style="display:flex;"><span>    l.head = n
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//从尾插入
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (l <span style="color:#ff79c6">*</span>list[T]) <span style="color:#50fa7b">push</span>(data T) {
</span></span><span style="display:flex;"><span>    n <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&amp;</span>node[T] {
</span></span><span style="display:flex;"><span>        data : data,
</span></span><span style="display:flex;"><span>        prev : l.tail,
</span></span><span style="display:flex;"><span>        next : <span style="color:#ff79c6">nil</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> l.<span style="color:#50fa7b">isEmpty</span>() {
</span></span><span style="display:flex;"><span>        l.head = n
</span></span><span style="display:flex;"><span>        l.tail = n
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    l.tail.next = n
</span></span><span style="display:flex;"><span>    l.tail = n
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//删除一个节点，注意边界处理
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (l <span style="color:#ff79c6">*</span>list[T]) <span style="color:#50fa7b">del</span>(data T) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> p <span style="color:#ff79c6">:=</span> l.head; p <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span>; p = p.next {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> data <span style="color:#ff79c6">==</span> p.data {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> p <span style="color:#ff79c6">==</span> l.head {
</span></span><span style="display:flex;"><span>                l.head = p.next
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> p <span style="color:#ff79c6">==</span> l.tail {
</span></span><span style="display:flex;"><span>                l.tail = p.prev
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> p.prev <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>                p.prev.next = p.next
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> p.next <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>                p.next.prev = p.prev
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (l <span style="color:#ff79c6">*</span>list[T]) <span style="color:#8be9fd;font-style:italic">print</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> l.<span style="color:#50fa7b">isEmpty</span>() {
</span></span><span style="display:flex;"><span>        fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;linklist is empty.&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> p <span style="color:#ff79c6">:=</span> l.head; p <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span>; p = p.next {
</span></span><span style="display:flex;"><span>        fmt.<span style="color:#50fa7b">Printf</span>(<span style="color:#f1fa8c">&#34;[%v]--&gt;&#34;</span>, p.data)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;end&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    l <span style="color:#ff79c6">:=</span> list[<span style="color:#8be9fd">int</span>]{}
</span></span><span style="display:flex;"><span>    l.<span style="color:#50fa7b">add</span>(<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>    l.<span style="color:#50fa7b">add</span>(<span style="color:#bd93f9">2</span>)
</span></span><span style="display:flex;"><span>    l.<span style="color:#50fa7b">push</span>(<span style="color:#bd93f9">3</span>)
</span></span><span style="display:flex;"><span>    l.<span style="color:#50fa7b">push</span>(<span style="color:#bd93f9">4</span>)
</span></span><span style="display:flex;"><span>    l.<span style="color:#50fa7b">add</span>(<span style="color:#bd93f9">5</span>)
</span></span><span style="display:flex;"><span>    l.<span style="color:#8be9fd;font-style:italic">print</span>()
</span></span><span style="display:flex;"><span>    l.<span style="color:#50fa7b">del</span>(<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>    l.<span style="color:#50fa7b">del</span>(<span style="color:#bd93f9">3</span>)
</span></span><span style="display:flex;"><span>    l.<span style="color:#8be9fd;font-style:italic">print</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="泛型map">泛型Map</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;strings&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> fMap[T1 any, T2 any](arr []T1, f <span style="color:#8be9fd;font-style:italic">func</span>(T1) T2) []T2 {
</span></span><span style="display:flex;"><span>    s <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>([]T2, <span style="color:#8be9fd;font-style:italic">len</span>(arr))
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> k,v <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> arr {
</span></span><span style="display:flex;"><span>        s[k] = <span style="color:#50fa7b">f</span>(v)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> s
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    strs <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">string</span>{<span style="color:#f1fa8c">&#34;I&#34;</span>, <span style="color:#f1fa8c">&#34;am&#34;</span>, <span style="color:#f1fa8c">&#34;yao&#34;</span>}
</span></span><span style="display:flex;"><span>    upstrs <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">fMap</span>(strs, <span style="color:#8be9fd;font-style:italic">func</span>(s <span style="color:#8be9fd">string</span>) <span style="color:#8be9fd">string</span>  {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> strings.<span style="color:#50fa7b">ToUpper</span>(s)
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(upstrs)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>T1: 需要处理的数据类型</li>
<li>T2: 处理后的数据类型</li>
<li>f func(T1) T2)：T1经过的函数然后转变为T2</li>
</ul>
<h2 id="泛型reduce">泛型Reduce</h2>
<p>数组求和</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> fReduce[T1 any, T2 any](arr []T1, init T2, f <span style="color:#8be9fd;font-style:italic">func</span>(T1, T2) T2) T2 {
</span></span><span style="display:flex;"><span>    s <span style="color:#ff79c6">:=</span> init
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> _, v <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> arr {
</span></span><span style="display:flex;"><span>        s = <span style="color:#50fa7b">f</span>(v, s)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> s
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    nums <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">int</span>{<span style="color:#bd93f9">0</span>,<span style="color:#bd93f9">1</span>,<span style="color:#bd93f9">2</span>,<span style="color:#bd93f9">3</span>,<span style="color:#bd93f9">4</span>}
</span></span><span style="display:flex;"><span>    sum <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">fReduce</span>(nums, <span style="color:#bd93f9">0</span>, <span style="color:#8be9fd;font-style:italic">func</span>(result, elem <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">int</span>  {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> result <span style="color:#ff79c6">+</span> elem
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Printf</span>(<span style="color:#f1fa8c">&#34;Sum = %d \n&#34;</span>, sum)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="泛型filter">泛型Filter</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> fFilter[T any](arr []T, in <span style="color:#8be9fd">bool</span>, f <span style="color:#8be9fd;font-style:italic">func</span>(T) <span style="color:#8be9fd">bool</span>) []T {
</span></span><span style="display:flex;"><span>    s <span style="color:#ff79c6">:=</span> []T{}
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> _, v <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> arr {
</span></span><span style="display:flex;"><span>        target <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">f</span>(v)
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> (in <span style="color:#ff79c6">&amp;&amp;</span> target) <span style="color:#ff79c6">||</span> (!in <span style="color:#ff79c6">&amp;&amp;</span> !target) {
</span></span><span style="display:flex;"><span>            s = <span style="color:#8be9fd;font-style:italic">append</span>(s, v)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> s
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> fFilterTrue[T any](arr []T, f <span style="color:#8be9fd;font-style:italic">func</span>(T) <span style="color:#8be9fd">bool</span>) []T {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">fFilter</span>(arr, <span style="color:#ff79c6">true</span>, f)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> fFilterFalse[T any](arr []T, f <span style="color:#8be9fd;font-style:italic">func</span>(T) <span style="color:#8be9fd">bool</span>) []T {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">fFilter</span>(arr, <span style="color:#ff79c6">false</span>, f)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    nums <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">int</span>{<span style="color:#bd93f9">0</span>,<span style="color:#bd93f9">1</span>,<span style="color:#bd93f9">2</span>,<span style="color:#bd93f9">3</span>,<span style="color:#bd93f9">4</span>,<span style="color:#bd93f9">5</span>}
</span></span><span style="display:flex;"><span>    result <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">fFilterTrue</span>(nums, <span style="color:#8be9fd;font-style:italic">func</span> (elem <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> elem <span style="color:#ff79c6">%</span> <span style="color:#bd93f9">2</span> <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(result)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    result = <span style="color:#50fa7b">fFilterFalse</span>(nums, <span style="color:#8be9fd;font-style:italic">func</span> (elem <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> elem <span style="color:#ff79c6">%</span> <span style="color:#bd93f9">2</span> <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(result)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="优雅关闭goroutine">优雅关闭Goroutine</h1>
<h2 id="返回ctx的signalhandler">返回ctx的SignalHandler</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">var</span> onlyOneSignalHandler = <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// SetupSignalHandler registers for SIGTERM and SIGINT. A stop channel is returned
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// which is closed on one of these signals. If a second signal is caught, the program
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// is terminated with exit code 1.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">SetupSignalHandler</span>() context.Context {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">close</span>(onlyOneSignalHandler) <span style="color:#6272a4">// panics when called twice
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>    ctx, cancel <span style="color:#ff79c6">:=</span> context.<span style="color:#50fa7b">WithCancel</span>(context.<span style="color:#50fa7b">Background</span>())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    c <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> os.Signal, <span style="color:#bd93f9">2</span>)
</span></span><span style="display:flex;"><span>    signal.<span style="color:#50fa7b">Notify</span>(c, shutdownSignals<span style="color:#ff79c6">...</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">&lt;-</span>c
</span></span><span style="display:flex;"><span>        <span style="color:#50fa7b">cancel</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">&lt;-</span>c
</span></span><span style="display:flex;"><span>        os.<span style="color:#50fa7b">Exit</span>(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4">// second signal. Exit directly.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    }()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> ctx
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="检测结构体是否有这个方法">检测结构体是否有这个方法</h1>
<p>不使用reflect检测结构体是否有这个方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> A <span style="color:#8be9fd">int</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> B <span style="color:#8be9fd">int</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (b B) <span style="color:#50fa7b">M</span>(x <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> fmt.<span style="color:#50fa7b">Sprint</span>(b, <span style="color:#f1fa8c">&#34;: &#34;</span>, x)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">check</span>(v <span style="color:#8be9fd;font-style:italic">interface</span>{}) <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>    _, has <span style="color:#ff79c6">:=</span> v.(<span style="color:#8be9fd;font-style:italic">interface</span>{<span style="color:#50fa7b">M</span>(<span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">string</span>})
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> has
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">var</span> a A = <span style="color:#bd93f9">123</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">var</span> b B = <span style="color:#bd93f9">789</span>
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#50fa7b">check</span>(a)) <span style="color:#6272a4">// false
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#50fa7b">check</span>(b)) <span style="color:#6272a4">// true
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><h1 id="jsondecoder-vs-jsonunmarshal">json.Decoder vs json.Unmarshal</h1>
<ul>
<li>Use json.Decoder if your data is coming from an io.Reader stream, or you need to decode multiple values from a stream of data.</li>
<li>Use json.Unmarshal if you already have the JSON data in memory.</li>
</ul>
<p>如果是从http请求的流中读取，使用<code>json.Decoder</code>; 如果json数据已在内存中，使用<code>json.Unmarshal</code></p>
<h1 id="interface判断为nil">interface判断为nil</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">var</span> a <span style="color:#8be9fd;font-style:italic">interface</span>{} = <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">var</span> b <span style="color:#8be9fd;font-style:italic">interface</span>{} = (<span style="color:#ff79c6">*</span><span style="color:#8be9fd">string</span>)(<span style="color:#ff79c6">nil</span>)
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(a<span style="color:#ff79c6">==</span><span style="color:#ff79c6">nil</span>)
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(b<span style="color:#ff79c6">==</span><span style="color:#ff79c6">nil</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出为</p>
<pre tabindex="0"><code>true
false
</code></pre><p>为什么会出现这样的结果呢？跟interface的底层结构有关，一个接口包括动态类型和动态值。通过<code>x!=nil</code>只是判断了动态类型，并没有判断动态值；
显式指明nil，动态类型和动态值都为nil，所以输出true；使用强制类型指明(*string)nil，动态类型不为nil，动态值为nil，所以输出为false.</p>
<p>interface底层实现：分为两种struct来表示，<code>iface</code>和<code>eface</code></p>
<p>eface表示不含method的interface结构(empty interface)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> eface <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    _type <span style="color:#ff79c6">*</span>_type
</span></span><span style="display:flex;"><span>    data  unsafe.Pointer
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> _type <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    size       <span style="color:#8be9fd">uintptr</span> <span style="color:#6272a4">// type size
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    ptrdata    <span style="color:#8be9fd">uintptr</span> <span style="color:#6272a4">// size of memory prefix holding all pointers
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    hash       <span style="color:#8be9fd">uint32</span>  <span style="color:#6272a4">// hash of type; avoids computation in hash tables
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    tflag      tflag   <span style="color:#6272a4">// extra type information flags
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    align      <span style="color:#8be9fd">uint8</span>   <span style="color:#6272a4">// alignment of variable with this type
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    fieldalign <span style="color:#8be9fd">uint8</span>   <span style="color:#6272a4">// alignment of struct field with this type
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    kind       <span style="color:#8be9fd">uint8</span>   <span style="color:#6272a4">// enumeration for C
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    alg        <span style="color:#ff79c6">*</span>typeAlg  <span style="color:#6272a4">// algorithm table
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    gcdata    <span style="color:#ff79c6">*</span><span style="color:#8be9fd">byte</span>    <span style="color:#6272a4">// garbage collection data
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    str       nameOff  <span style="color:#6272a4">// string form
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    ptrToThis typeOff  <span style="color:#6272a4">// type for pointer to this type, may be zero
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><p>iface表示non-empty interface的底层实现, non-empty要包含method</p>
<pre tabindex="0"><code>type iface struct {
    tab  *itab
    data unsafe.Pointer
}

// layout of Itab known to compilers
// allocated in non-garbage-collected memory
// Needs to be in sync with
// ../cmd/compile/internal/gc/reflect.go:/^func.dumptypestructs.
type itab struct {
    inter  *interfacetype
    _type  *_type
    link   *itab
    bad    int32
    inhash int32      // has this itab been added to hash?
    fun    [1]uintptr // variable sized
}
</code></pre><p>可以借助反射来判断</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">IsNil</span>(i <span style="color:#8be9fd;font-style:italic">interface</span>{}) <span style="color:#8be9fd">bool</span> {
</span></span><span style="display:flex;"><span>    vi <span style="color:#ff79c6">:=</span> reflect.<span style="color:#50fa7b">ValueOf</span>(i)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> vi.<span style="color:#50fa7b">Kind</span>() <span style="color:#ff79c6">==</span> reflect.Ptr {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> vi.<span style="color:#50fa7b">IsNil</span>()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">false</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="自动转化时间格式">自动转化时间格式</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (b <span style="color:#ff79c6">*</span>T) <span style="color:#50fa7b">MarshalJSON</span>() ([]<span style="color:#8be9fd">byte</span>, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">type</span> tmp T
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> json.<span style="color:#50fa7b">Marshal</span>(<span style="color:#ff79c6">&amp;</span><span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">*</span>tmp
</span></span><span style="display:flex;"><span>        CreatedAt  <span style="color:#8be9fd">string</span> <span style="color:#f1fa8c">`json:&#34;created_at&#34;`</span>
</span></span><span style="display:flex;"><span>        UpdatedAt  <span style="color:#8be9fd">string</span> <span style="color:#f1fa8c">`json:&#34;updated_at&#34;`</span>
</span></span><span style="display:flex;"><span>        ExpireTime <span style="color:#8be9fd">string</span> <span style="color:#f1fa8c">`json:&#34;expire_time&#34;`</span>
</span></span><span style="display:flex;"><span>    }{
</span></span><span style="display:flex;"><span>        tmp:        (<span style="color:#ff79c6">*</span>tmp)(b),
</span></span><span style="display:flex;"><span>        CreatedAt:  b.CreatedAt.<span style="color:#50fa7b">Local</span>().<span style="color:#50fa7b">Format</span>(DefaultTimeFormat),
</span></span><span style="display:flex;"><span>        UpdatedAt:  b.UpdatedAt.<span style="color:#50fa7b">Local</span>().<span style="color:#50fa7b">Format</span>(DefaultTimeFormat),
</span></span><span style="display:flex;"><span>        ExpireTime: b.ExpireTime.<span style="color:#50fa7b">Local</span>().<span style="color:#50fa7b">Format</span>(DefaultTimeFormat),
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (b <span style="color:#ff79c6">*</span>T) <span style="color:#50fa7b">UnmarshalJSON</span>(data []<span style="color:#8be9fd">byte</span>) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">type</span> tmp T
</span></span><span style="display:flex;"><span>    origin <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&amp;</span><span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">*</span>tmp
</span></span><span style="display:flex;"><span>        CreatedAt  <span style="color:#8be9fd">string</span> <span style="color:#f1fa8c">`json:&#34;created_at&#34;`</span>
</span></span><span style="display:flex;"><span>        UpdatedAt  <span style="color:#8be9fd">string</span> <span style="color:#f1fa8c">`json:&#34;updated_at&#34;`</span>
</span></span><span style="display:flex;"><span>        ExpireTime <span style="color:#8be9fd">string</span> <span style="color:#f1fa8c">`json:&#34;expire_time&#34;`</span>
</span></span><span style="display:flex;"><span>    }{
</span></span><span style="display:flex;"><span>        tmp: (<span style="color:#ff79c6">*</span>tmp)(b),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> json.<span style="color:#50fa7b">Unmarshal</span>(data, origin); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    createdAt, err <span style="color:#ff79c6">:=</span> time.<span style="color:#50fa7b">Parse</span>(DefaultTimeFormat, origin.CreatedAt)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    b.CreatedAt = createdAt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    updatedAt, err <span style="color:#ff79c6">:=</span> time.<span style="color:#50fa7b">Parse</span>(DefaultTimeFormat, origin.UpdatedAt)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    b.UpdatedAt = updatedAt
</span></span><span style="display:flex;"><span>    expireTime, err <span style="color:#ff79c6">:=</span> time.<span style="color:#50fa7b">Parse</span>(DefaultTimeFormat, origin.ExpireTime)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    b.ExpireTime = expireTime
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="如何计算结构体占用的空间">如何计算结构体占用的空间</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;unsafe&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> test1 <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    num1 <span style="color:#8be9fd">int</span>
</span></span><span style="display:flex;"><span>    num2 <span style="color:#8be9fd">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> test2 <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    num1 <span style="color:#8be9fd">int16</span>
</span></span><span style="display:flex;"><span>    num2 <span style="color:#8be9fd">int32</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(unsafe.<span style="color:#50fa7b">Sizeof</span>(test1{}))
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(unsafe.<span style="color:#50fa7b">Sizeof</span>(test2{}))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>运行结果:</p>
<pre tabindex="0"><code>16
8
</code></pre><p>test1结构体int类型在64位机器上占8字节，test1结构占16字节；test2结构体int16占2字节，int32占4字节，总共6字节。为什么不是8字节？
这是因为内存对齐的缘故，CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问。比如32位的CPU ，字长为4字节。
这么设计的目的，是减少 CPU 访问内存的次数，加大CPU访问内存的吞吐量。合理的内存对齐可以提高内存读写的性能，并且便于实现变量操作的原子性。</p>
<p>unsafe库提供<code>Alignof</code>方法查看一个类型的对齐值(对齐系数、对齐倍数)，golang官方文档有针对这个的说明，总结：</p>
<ul>
<li>对于任意类型的变量 x ，unsafe.Alignof(x) 至少为 1。</li>
<li>对于 struct 结构体类型的变量 x，计算x每一个字段f的unsafe.Alignof(x.f)，unsafe.Alignof(x)等于其中的最大值。但至少为1</li>
<li>对于 array 数组类型的变量 x，unsafe.Alignof(x) 等于构成数组的元素类型的对齐倍数。
没有任何字段的空 struct{} 和没有任何元素的 array 占据的内存空间大小为 0，不同的大小为 0 的变量可能指向同一块地址。</li>
</ul>
<h2 id="struct内存对齐技巧">struct内存对齐技巧</h2>
<p>合理放置变量位置减少内存占用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;unsafe&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//假设字长为4字节
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> test1 <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    a <span style="color:#8be9fd">int8</span>  <span style="color:#6272a4">//a和下面的b加起来为3字节，补齐1个字节凑齐一个字长
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    b <span style="color:#8be9fd">int16</span>
</span></span><span style="display:flex;"><span>    c <span style="color:#8be9fd">int32</span> <span style="color:#6272a4">//c刚好一个字长
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> test2 <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    a <span style="color:#8be9fd">int8</span>  <span style="color:#6272a4">//a和下面的b加起来超过一个字长的字节，所以a单独补齐3个字节
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    c <span style="color:#8be9fd">int32</span> <span style="color:#6272a4">//c刚好一个字长
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    b <span style="color:#8be9fd">int16</span> <span style="color:#6272a4">//b补齐2个字节，凑齐一个字长
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(unsafe.<span style="color:#50fa7b">Sizeof</span>(test1{})) <span style="color:#6272a4">// 8
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    fmt.<span style="color:#50fa7b">Println</span>(unsafe.<span style="color:#50fa7b">Sizeof</span>(test2{})) <span style="color:#6272a4">// 12
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><p>运行结果为8和12</p>
<h2 id="空struct的对齐">空struct{}的对齐</h2>
<p>struct{}作为其它struct最后一个字段时，需要填充额外的内存保证安全</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;unsafe&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> test1 <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    c <span style="color:#8be9fd">int32</span>
</span></span><span style="display:flex;"><span>    a <span style="color:#8be9fd;font-style:italic">struct</span>{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> test2 <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    a <span style="color:#8be9fd;font-style:italic">struct</span>{}
</span></span><span style="display:flex;"><span>    c <span style="color:#8be9fd">int32</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#50fa7b">Println</span>(unsafe.<span style="color:#50fa7b">Sizeof</span>(test1{})) <span style="color:#6272a4">// 8
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    fmt.<span style="color:#50fa7b">Println</span>(unsafe.<span style="color:#50fa7b">Sizeof</span>(test2{})) <span style="color:#6272a4">// 4
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><p>运行结果为8和4，test1的struct{}额外占用一个字长</p>
<h1 id="syncpool临时对象池">sync.Pool临时对象池</h1>
<p>为什么需要sync.Pool？保存和复用临时对象，减少内存分配，降低GC压力。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;sync&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;testing&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">type</span> A <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>    Name <span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (a <span style="color:#ff79c6">*</span>A) <span style="color:#50fa7b">Reset</span>() {
</span></span><span style="display:flex;"><span>    a.Name = <span style="color:#f1fa8c">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">var</span> pool = sync.Pool{
</span></span><span style="display:flex;"><span>    New: <span style="color:#8be9fd;font-style:italic">func</span>() <span style="color:#8be9fd;font-style:italic">interface</span>{} {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">new</span>(A)
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">BenchmarkWithoutPool</span>(b <span style="color:#ff79c6">*</span>testing.B) {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">var</span> a <span style="color:#ff79c6">*</span>A
</span></span><span style="display:flex;"><span>    b.<span style="color:#50fa7b">ReportAllocs</span>()
</span></span><span style="display:flex;"><span>    b.<span style="color:#50fa7b">ResetTimer</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; i &lt; b.N; i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">for</span> j <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; j &lt; <span style="color:#bd93f9">10000</span>; j<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>            a = <span style="color:#8be9fd;font-style:italic">new</span>(A)
</span></span><span style="display:flex;"><span>            a.Name = <span style="color:#f1fa8c">&#34;tink&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">BenchmarkWithPool</span>(b <span style="color:#ff79c6">*</span>testing.B) {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">var</span> a <span style="color:#ff79c6">*</span>A
</span></span><span style="display:flex;"><span>    b.<span style="color:#50fa7b">ReportAllocs</span>()
</span></span><span style="display:flex;"><span>    b.<span style="color:#50fa7b">ResetTimer</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; i &lt; b.N; i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">for</span> j <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; j &lt; <span style="color:#bd93f9">10000</span>; j<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>            a = pool.<span style="color:#50fa7b">Get</span>().(<span style="color:#ff79c6">*</span>A)
</span></span><span style="display:flex;"><span>            a.<span style="color:#50fa7b">Reset</span>()
</span></span><span style="display:flex;"><span>            a.Name = <span style="color:#f1fa8c">&#34;tink&#34;</span>
</span></span><span style="display:flex;"><span>            pool.<span style="color:#50fa7b">Put</span>(a)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code># go test -benchmem -run=^$ -bench .
goos: darwin
goarch: amd64
pkg: test/syncpool
cpu: Intel(R) Core(TM) i7-4770HQ CPU @ 2.20GHz
BenchmarkWithoutPool-8              3955            307508 ns/op          160000 B/op      10000 allocs/op
BenchmarkWithPool-8                 7032            148487 ns/op               0 B/op          0 allocs/op
PASS 
ok      test/syncpool   3.491s
</code></pre><p>运行耗时节省了一半以上，内存分配为0，内存分配次数也为0</p>
<h1 id="注册模式">注册模式</h1>
<p>slice方式注册，来自<code>github.com/bitpoke/mysql-operator</code>代码片段</p>
<p>多controller运行例子：</p>
<pre tabindex="0"><code>    // Setup all Controllers
    if err := controller.AddToManager(mgr); err != nil {
        log.Error(err, &#34;unable to setup controllers&#34;)
        os.Exit(1)
    }
</code></pre><p>定义一个AddToManagerFuncs变量存放函数组，AddToManager遍历AddToManagerFuncs，并执行其函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#6272a4">// AddToManagerFuncs is a list of functions to add all Controllers to the Manager
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">var</span> AddToManagerFuncs []<span style="color:#8be9fd;font-style:italic">func</span>(manager.Manager) <span style="color:#8be9fd">error</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// AddToManager adds all Controllers to the Manager
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">AddToManager</span>(m manager.Manager) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> _, f <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> AddToManagerFuncs {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">f</span>(m); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>同级目录下不同的controller的init函数有注册AddToManagerFuncs的实现</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#6272a4">//add_mysqlcontroller.go
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">init</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// AddToManagerFuncs is a list of functions to create controllers and add them to a manager.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    AddToManagerFuncs = <span style="color:#8be9fd;font-style:italic">append</span>(AddToManagerFuncs, mysqlcluster.Add)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">//add_nodecontroller.go
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">init</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// AddToManagerFuncs is a list of functions to create controllers and add them to a manager.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    AddToManagerFuncs = <span style="color:#8be9fd;font-style:italic">append</span>(AddToManagerFuncs, node.Add)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Note: 看到有大量项目使用下划线声明变量，mysql-operator项目中也存在
<code>var _ reconcile.Reconciler = &amp;ReconcileMysqlCluster{}</code>，这是一种接口断言，否则编译报错</p>
<h1 id="二级缓存常见实现">二级缓存常见实现</h1>
<p>引用左耳朵耗子的：<a href="https://coolshell.cn/articles/17416.html">缓存更新的套路</a></p>
<h2 id="cache-aside模式">Cache Aside模式</h2>
<ul>
<li>失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li>
<li>命中：应用程序从cache中取数据，取到后返回。</li>
<li>更新：先把数据存到数据库中，成功后，再让缓存失效。</li>
</ul>
<h2 id="read-through模式">Read Through模式</h2>
<p>查询操作中更新缓存</p>
<h2 id="write-through模式">Write Through模式</h2>
<p>更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。
如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库</p>
<h2 id="write-back模式">Write Back模式</h2>
<p>在更新数据的时候，只更新缓存，不更新数据库，缓存会异步地批量更新数据库</p>
<h1 id="for-range的坑">For Range的坑</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    arr1 <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd">int</span>{<span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">2</span>, <span style="color:#bd93f9">3</span>}
</span></span><span style="display:flex;"><span>	arr2 <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>([]<span style="color:#ff79c6">*</span><span style="color:#8be9fd">int</span>, <span style="color:#8be9fd;font-style:italic">len</span>(arr1))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> i, v <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> arr1 {
</span></span><span style="display:flex;"><span>		arr2[i] = <span style="color:#ff79c6">&amp;</span>v
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> _, v <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> arr2 {
</span></span><span style="display:flex;"><span>		fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#ff79c6">*</span>v)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出结果</p>
<pre tabindex="0"><code>3
3
3
</code></pre><p>原因是v变量在for range中只会被初始化一次，后面都是复用这个临时变量，v的指针地址始终是同一个地址；建议可以用slice下标避免这个问题</p>
<h1 id="leetcode热题100">LeetCode热题100</h1>
<ul>
<li>站内用户最喜爱的 100 道题</li>
<li>站内最经典的 100 道题</li>
</ul>
<h2 id="哈希">哈希</h2>
<h3 id="两数之和">两数之和</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#6272a4">/*
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">你可以按任意顺序返回答案。
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">示例 1：
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">输入：nums = [2,7,11,15], target = 9
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">输出：[0,1]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">示例 2：
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">输入：nums = [3,2,4], target = 6
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">输出：[1,2]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">示例 3：
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">输入：nums = [3,3], target = 6
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">输出：[0,1]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">提示：
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">2 &lt;= nums.length &lt;= 104
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">-109 &lt;= nums[i] &lt;= 109
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">-109 &lt;= target &lt;= 109
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">只会存在一个有效答案
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">twoSum</span>(nums []<span style="color:#8be9fd">int</span>, target <span style="color:#8be9fd">int</span>) []<span style="color:#8be9fd">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N) 降低到 O(1)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	hashTable <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">int</span>]<span style="color:#8be9fd">int</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> i, x <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> nums {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> p, ok <span style="color:#ff79c6">:=</span> hashTable[target<span style="color:#ff79c6">-</span>x]; ok {
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">return</span> []<span style="color:#8be9fd">int</span>{p, i}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		hashTable[x] = i
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	result <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">twoSum</span>([]<span style="color:#8be9fd">int</span>{<span style="color:#bd93f9">2</span>, <span style="color:#bd93f9">7</span>, <span style="color:#bd93f9">11</span>, <span style="color:#bd93f9">15</span>}, <span style="color:#bd93f9">9</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; i &lt; <span style="color:#8be9fd;font-style:italic">len</span>(result); i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#8be9fd;font-style:italic">println</span>(result[i])
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="字母异位词分组">字母异位词分组</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#6272a4">/*
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">字母异位词 是由重新排列源单词的所有字母得到的一个新单词。
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">示例 1:
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">输入: strs = [&#34;eat&#34;, &#34;tea&#34;, &#34;tan&#34;, &#34;ate&#34;, &#34;nat&#34;, &#34;bat&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">输出: [[&#34;bat&#34;],[&#34;nat&#34;,&#34;tan&#34;],[&#34;ate&#34;,&#34;eat&#34;,&#34;tea&#34;]]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">示例 2:
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">输入: strs = [&#34;&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">输出: [[&#34;&#34;]]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">示例 3:
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">输入: strs = [&#34;a&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">输出: [[&#34;a&#34;]]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">提示：
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">1 &lt;= strs.length &lt;= 104
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">0 &lt;= strs[i].length &lt;= 100
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">strs[i] 仅包含小写字母
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">思路：
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">两个字符串互为字母异位词，当且仅当两个字符串包含的字母相同。同一组字母异位词中的字符串具备相同点，可以使用相同点作为一组字母异位词的标志，使用哈希表存储每一组字母异位词，哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表。
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">遍历每个字符串，对于每个字符串，得到该字符串所在的一组字母异位词的标志，将当前字符串加入该组字母异位词的列表中。遍历全部字符串之后，哈希表中的每个键值对即为一组字母异位词
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">方法一：排序
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f1fa8c">&#34;sort&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">groupAnagrams</span>(strs []<span style="color:#8be9fd">string</span>) [][]<span style="color:#8be9fd">string</span> {
</span></span><span style="display:flex;"><span>	mp <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">string</span>][]<span style="color:#8be9fd">string</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> _, str <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> strs {
</span></span><span style="display:flex;"><span>		s <span style="color:#ff79c6">:=</span> []<span style="color:#8be9fd;font-style:italic">byte</span>(str)
</span></span><span style="display:flex;"><span>		sort.<span style="color:#50fa7b">Slice</span>(s, <span style="color:#8be9fd;font-style:italic">func</span>(i, j <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">bool</span> { <span style="color:#ff79c6">return</span> s[i] &lt; s[j] })
</span></span><span style="display:flex;"><span>		sortedStr <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">string</span>(s)
</span></span><span style="display:flex;"><span>		mp[sortedStr] = <span style="color:#8be9fd;font-style:italic">append</span>(mp[sortedStr], str)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	res <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>([][]<span style="color:#8be9fd">string</span>, <span style="color:#bd93f9">0</span>, <span style="color:#8be9fd;font-style:italic">len</span>(mp))
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> _, v <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> mp {
</span></span><span style="display:flex;"><span>		res = <span style="color:#8be9fd;font-style:italic">append</span>(res, v)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> res
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#50fa7b">groupAnagrams</span>([]<span style="color:#8be9fd">string</span>{<span style="color:#f1fa8c">&#34;eat&#34;</span>, <span style="color:#f1fa8c">&#34;tea&#34;</span>, <span style="color:#f1fa8c">&#34;tan&#34;</span>, <span style="color:#f1fa8c">&#34;ate&#34;</span>, <span style="color:#f1fa8c">&#34;nat&#34;</span>, <span style="color:#f1fa8c">&#34;bat&#34;</span>}))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="最长连续队列">最长连续队列</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#6272a4">/*
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">请你设计并实现时间复杂度为 O(n) 的算法解决此问题。
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">示例 1：
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">输入：nums = [100,4,200,1,3,2]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">输出：4
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">示例 2：
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">输入：nums = [0,3,7,2,5,8,4,6,0,1]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">输出：9
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">思路：
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">我们考虑枚举数组中的每个数 x，考虑以其为起点，不断尝试匹配 x+1,x+2,⋯ 是否存在，假设最长匹配到了 x+y，那么以 x 为起点的最长连续序列即为 x,x+1,x+2,⋯,x+y，其长度为 y+1，我们不断枚举并更新答案即可。
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">对于匹配的过程，暴力的方法是 O(n) 遍历数组去看是否存在这个数，但其实更高效的方法是用一个哈希表存储数组中的数，这样查看一个数是否存在即能优化至 O(1) 的时间复杂度。
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">仅仅是这样我们的算法时间复杂度最坏情况下还是会达到 O(n)（即外层需要枚举 O(n) 个数，内层需要暴力匹配 O(n) 次），无法满足题目的要求。但仔细分析这个过程，我们会发现其中执行了很多不必要的枚举，如果已知有一个 x,x+1,x+2,⋯,x+y 的连续序列，而我们却重新从 x+1，x+2 或者是 x+y 处开始尝试匹配，那么得到的结果肯定不会优于枚举 x 为起点的答案，因此我们在外层循环的时候碰到这种情况跳过即可。
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">那么怎么判断是否跳过呢？由于我们要枚举的数 x 一定是在数组中不存在前驱数 x−1 的，不然按照上面的分析我们会从 x−1 开始尝试匹配，因此我们每次在哈希表中检查是否存在 x−1 即能判断是否需要跳过了。
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#f1fa8c">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">longestConsecutive</span>(nums []<span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">int</span> {
</span></span><span style="display:flex;"><span>	numSet <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">int</span>]<span style="color:#8be9fd">bool</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> _, v <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> nums {
</span></span><span style="display:flex;"><span>		numSet[v] = <span style="color:#ff79c6">true</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	longStep <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> num <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> numSet {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> !numSet[num<span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>] {
</span></span><span style="display:flex;"><span>			currentNum <span style="color:#ff79c6">:=</span> num
</span></span><span style="display:flex;"><span>			currentStep <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">for</span> numSet[currentNum<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>] {
</span></span><span style="display:flex;"><span>				currentNum<span style="color:#ff79c6">++</span>
</span></span><span style="display:flex;"><span>				currentStep<span style="color:#ff79c6">++</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">if</span> longStep &lt; currentStep {
</span></span><span style="display:flex;"><span>				longStep = currentStep
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> longStep
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>	fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#50fa7b">longestConsecutive</span>([]<span style="color:#8be9fd">int</span>{<span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">3</span>, <span style="color:#bd93f9">7</span>, <span style="color:#bd93f9">2</span>, <span style="color:#bd93f9">5</span>, <span style="color:#bd93f9">8</span>, <span style="color:#bd93f9">4</span>, <span style="color:#bd93f9">6</span>, <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">1</span>}))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="其它">其它</h2>
<h3 id="一个数的阶乘最后有多少个0">一个数的阶乘，最后有多少个0</h3>
<p>实际上是一个数学题目，一个数n的阶乘，最后有多少个0，取决于n的阶乘中包含多少个5，因为5和2相乘会得到10，而10的倍数中，2的个数总是大于5的个数，所以只需要统计5的个数即可。</p>
<p>举例：</p>
<ul>
<li>10的阶乘是10<em>9</em>8<em>7</em>6<em>5</em>4<em>3</em>2*1=3628800，最后有2个0</li>
<li>15的阶乘是15<em>14</em>13<em>12</em>11<em>10</em>9<em>8</em>7<em>6</em>5<em>4</em>3<em>2</em>1=1307674368000，最后有3个0</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">countZero</span>(n <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> n &lt; <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	count <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">5</span>; n<span style="color:#ff79c6">/</span>i &gt; <span style="color:#bd93f9">0</span>; i <span style="color:#ff79c6">*=</span> <span style="color:#bd93f9">5</span> {
</span></span><span style="display:flex;"><span>		count <span style="color:#ff79c6">+=</span> n <span style="color:#ff79c6">/</span> i
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> count
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="动态规划">动态规划</h3>
<p>动态规划（Dynamic Programming，简称 DP）是一种通过把原问题分解为相对简单的子问题来解决复杂问题的算法思想。解决动态规划问题的步骤：</p>
<ul>
<li>定义状态（dp数组的含义）</li>
<li>找出状态转移方程</li>
<li>确定边界条件</li>
<li>确定计算顺序</li>
</ul>
<ol>
<li>斐波那契数列（最简单DP）</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#6272a4">// F(n) = F(n-1) + F(n-2)，其中 F(0)=0, F(1)=1
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// 普通递归(效率低)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">fib</span>(n <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> n &lt; <span style="color:#bd93f9">2</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> n
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> <span style="color:#50fa7b">fib</span>(n<span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">+</span> <span style="color:#50fa7b">fib</span>(n<span style="color:#ff79c6">-</span><span style="color:#bd93f9">2</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// 动态规划(效率高)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">fib</span>(n <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> n &lt; <span style="color:#bd93f9">2</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> n
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	a, b <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">2</span>; i <span style="color:#ff79c6">&lt;=</span> n; i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>		a, b = b, a<span style="color:#ff79c6">+</span>b
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> b
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="2">
<li>爬楼梯(经典DP)</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#6272a4">//问题：每次可以爬1或2个台阶，爬到第n阶有多少种方法？
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">climbStairs</span>(n <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> n <span style="color:#ff79c6">&lt;=</span> <span style="color:#bd93f9">2</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> n
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	a, b <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">1</span>, <span style="color:#bd93f9">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 爬到第i阶的方法数 = 从第(i-1)阶爬1步 + 从第(i-2)阶爬2步
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">3</span>; i <span style="color:#ff79c6">&lt;=</span> n; i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>		a, b = b, a<span style="color:#ff79c6">+</span>b
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> b
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="3">
<li>0-1背包问题（经典DP应用）</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#6272a4">// 问题：有n个物品，每个物品有重量和价值，背包容量为W，求最大价值
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">knapsack</span>(weights []<span style="color:#8be9fd">int</span>, values []<span style="color:#8be9fd">int</span>, capacity <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// weights: 物品重量数组，例如 [2, 3, 4, 5]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// values: 物品价值数组，例如 [3, 4, 5, 6]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// capacity: 背包容量，例如 8
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    
</span></span><span style="display:flex;"><span>    n <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">len</span>(weights)  <span style="color:#6272a4">// 获取物品数量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 步骤 1：定义状态
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 创建二维dp数组，大小为 (n+1) × (capacity+1)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// dp[i][j] 表示：使用前i个物品，容量为j时的最大价值
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    dp <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>([][]<span style="color:#8be9fd">int</span>, n<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> dp {
</span></span><span style="display:flex;"><span>        dp[i] = <span style="color:#8be9fd;font-style:italic">make</span>([]<span style="color:#8be9fd">int</span>, capacity<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 外层循环：遍历每个物品
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">1</span>; i <span style="color:#ff79c6">&lt;=</span> n; i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>        w <span style="color:#ff79c6">:=</span> weights[i<span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>] <span style="color:#6272a4">// 当前物品重量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        v <span style="color:#ff79c6">:=</span> values[i<span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>]  <span style="color:#6272a4">// 当前物品价值
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 内层循环：遍历每种容量（0到capacity）
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">for</span> j <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; j <span style="color:#ff79c6">&lt;=</span> capacity; j<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> w <span style="color:#ff79c6">&lt;=</span> j {
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">//步骤 2：状态转移方程
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#6272a4">// 当前物品重量小于等于当前容量，可以选择放入或不放入
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                dp[i][j] = <span style="color:#8be9fd;font-style:italic">max</span>(
</span></span><span style="display:flex;"><span>                    dp[i<span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>][j],        <span style="color:#6272a4">// 不放入当前物品
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                    dp[i<span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>][j<span style="color:#ff79c6">-</span>w] <span style="color:#ff79c6">+</span> v   <span style="color:#6272a4">// 放入当前物品
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                )
</span></span><span style="display:flex;"><span>            } <span style="color:#ff79c6">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// 当前物品太重，不能放入
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                dp[i][j] = dp[i<span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>][j]
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 返回使用所有物品、容量为capacity时的最大价值
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">return</span> dp[n][capacity]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="参考链接">参考链接</h1>
<ul>
<li><a href="https://www.dailybtc.cn/golang%e4%b8%ad%e7%9a%84defer%e5%bf%85%e6%8e%8c%e6%8f%a1%e7%9a%847%e7%9f%a5%e8%af%86%e7%82%b9golang%e4%b8%ad%e7%9a%84defer%e5%bf%85%e6%8e%8c%e6%8f%a1%e7%9a%847%e7%9f%a5%e8%af%86%e7%82%b9/">golang中的defer必掌握的7知识点golang中的defer必掌握的7知识点</a></li>
<li><a href="https://blog.betacat.io/post/golang-atomic-value-exploration/">Go 语言标准库中 atomic.Value 的前世今生</a></li>
<li><a href="https://juejin.im/post/6844904056918376456">浅谈协程和Go语言的Goroutine</a></li>
<li><a href="https://liudanking.com/performance/golang-%E8%8E%B7%E5%8F%96-goroutine-id-%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/">https://liudanking.com/performance/golang-%E8%8E%B7%E5%8F%96-goroutine-id-%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/</a></li>
<li><a href="https://chai2010.cn/advanced-go-programming-book/ch3-asm/ch3-08-goroutine-id.html">https://chai2010.cn/advanced-go-programming-book/ch3-asm/ch3-08-goroutine-id.html</a></li>
<li><a href="https://coolshell.cn/articles/21615.html">GO编程模式: 泛型编程</a></li>
<li><a href="https://go101.org/article/tips.html">Go Tips 101</a></li>
<li><a href="https://golang.org/ref/spec#Size_and_alignment_guarantees"> Size and alignment guarantees - golang spec 的unsafe.Alignof</a></li>
<li><a href="https://geektutu.com/post/hpg-struct-alignment.html">Go 语言高性能编程</a></li>
</ul>


                
                
<div class="entry-shang text-center">
    
	    <p>「真诚赞赏，手留余香」</p>
	
	<button class="zs show-zs btn btn-bred">赞赏支持</button>
</div>
<div class="zs-modal-bg"></div>
<div class="zs-modal-box">
	<div class="zs-modal-head">
		<button type="button" class="close">×</button>
		<span class="author"><a href="https://www.iceyao.com.cn/"><img src="/img/favicon.png" />爱折腾的工程师</a></span>
        
	        <p class="tip"><i></i><span>真诚赞赏，手留余香</span></p>
		
 
	</div>
	<div class="zs-modal-body">
		<div class="zs-modal-btns">
			<button class="btn btn-blink" data-num="2">2元</button>
			<button class="btn btn-blink" data-num="5">5元</button>
			<button class="btn btn-blink" data-num="10">10元</button>
			<button class="btn btn-blink" data-num="50">50元</button>
			<button class="btn btn-blink" data-num="100">100元</button>
			<button class="btn btn-blink" data-num="1">任意金额</button>
		</div>
		<div class="zs-modal-pay">
			<button class="btn btn-bred" id="pay-text">2元</button>
			<p>使用<span id="pay-type">微信</span>扫描二维码完成支付</p>
			<img src="/img/reward/wechat-2.png"  id="pay-image"/>
		</div>
	</div>
	<div class="zs-modal-footer">
		<label><input type="radio" name="zs-type" value="wechat" class="zs-type" checked="checked"><span ><span class="zs-wechat"><img src="/img/reward/wechat-btn.png"/></span></label>
		<label><input type="radio" name="zs-type" value="alipay" class="zs-type" class="zs-alipay"><img src="/img/reward/alipay-btn.png"/></span></label>
	</div>
</div>
<script type="text/javascript" src="/js/reward.js"></script>

                

                
                <hr>
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/post/2020-08-06-ebpf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-toggle="tooltip" data-placement="top" title="eBPF学习笔记">&larr;
                            Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/post/2020-08-12-k8s-network-develop-flannel_readnote/" data-toggle="tooltip" data-placement="top" title="flannel源码阅读笔记">Next
                            Post &rarr;</a>
                    </li>
                    
                </ul>
                

                


<script src="https://giscus.app/client.js"
        data-repo="yaoice/yaoice.github.io"
        data-repo-id="R_kgDOJnxqVg"
        data-category="General"
        data-category-id="DIC_kwDOJnxqVs4CWwUs"
        data-mapping="pathname"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-theme="light"
        data-lang="en"
        crossorigin="anonymous"
        async>
</script>


            </div>

            
            
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
            

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                        
                        
                        
                        
                        
                        <a href="/tags/devops" title="devops">
                            devops
                        </a>
                        
                        
                        
                        <a href="/tags/go" title="go">
                            go
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/k8s" title="k8s">
                            k8s
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/llm" title="llm">
                            llm
                        </a>
                        
                        
                        
                        <a href="/tags/openstack" title="openstack">
                            openstack
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/tkestack" title="tkestack">
                            tkestack
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/%E7%BB%83%E8%BD%A6" title="练车">
                            练车
                        </a>
                        
                        
                    </div>
                </section>
                

                
                
            </div>
        </div>
    </div>
</article>









<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">                  
                    
                    <li>
                        <a href="mailto:yao3690093@gmail.com">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		           
                    
                    
                    
                    

		            
                    
                    <li>
                        <a target="_blank" href="/img/wechat.jpeg">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-weixin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		            
                    
                    <li>
                        <a target="_blank" href="https://github.com/yaoice">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		            
                    
                    
                    
                    
                    
                    
                    
                    
                    
            
            
            
           
                   <li>
                       <a href="/index.xml" rel="alternate" type="application/rss+xml" title="爱折腾的工程师" >
                           <span class="fa-stack fa-lg">
                               <i class="fas fa-circle fa-stack-2x"></i>
                               <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                           </span>
                       </a>
                   </li>
            
             </ul>
		<p class="copyright text-muted">
                    Copyright &copy; 爱折腾的工程师 2025
                </p>
            </div>
        </div>
    </div>
</footer>




<script>
    function loadAsync(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>






<script>
    
    if($('#tag_cloud').length !== 0){
        loadAsync("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>


<script>
    loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>



<script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https'){
       bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else{
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>


<script>
    
    var _baId = '92c175994ded75a3cd2074bc1123e2be';

    
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>




<script type="text/javascript">
    function generateCatalog(selector) {

        
        
        
        
            _containerSelector = 'div.post-container'
        

        
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        
        $(selector).html('')

        
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    
    $(".catalog-toggle").click((function (e) {
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    


    loadAsync("\/js\/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>







</body>
</html>
