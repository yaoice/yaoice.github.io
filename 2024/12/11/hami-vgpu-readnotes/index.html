<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    

    
    <meta property="og:site_name" content="爱折腾的工程师">
    <meta property="og:type" content="article">

    
    <meta property="og:image" content="https://www.iceyao.com.cn//img/post-bg-unix-linux.jpg">
    <meta property="twitter:image" content="https://www.iceyao.com.cn//img/post-bg-unix-linux.jpg" />
    

    
    <meta name="title" content="HAMi vGPU学习笔记" />
    <meta property="og:title" content="HAMi vGPU学习笔记" />
    <meta property="twitter:title" content="HAMi vGPU学习笔记" />
    

    
    <meta name="description" content="HAMi vGPU学习笔记">
    <meta property="og:description" content="HAMi vGPU学习笔记" />
    <meta property="twitter:description" content="HAMi vGPU学习笔记" />
    

    
    <meta property="twitter:card" content="summary" />
    
    

    <meta name="keyword"  content="iceyao, IceYao&#39;s Blog, 博客, 个人网站, 互联网, Web, 云原生, PaaS, Istio, Kubernetes, 微服务, Microservice">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>HAMi vGPU学习笔记 | 爱折腾的工程师 | IceYao&#39;s Blog</title>

    <link rel="canonical" href="/2024/12/11/hami-vgpu-readnotes/">

    

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css">

    
    <link rel="stylesheet" href="/css/hugo-theme-cleanwhite.min.css">

    
    <link rel="stylesheet" href="/css/zanshang.css">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css">

    
    

    
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script>

    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js"></script>

    
    <script src="/js/hux-blog.min.js"></script>

    
    <script src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script>

    
    

</head>



  
    
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-9J7CKFVPPM"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-9J7CKFVPPM');
        }
      </script>
    
  







<nav class="navbar navbar-default navbar-custom navbar-fixed-top">

    <div class="container-fluid">
        
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">爱折腾的工程师</a>
        </div>

        
        
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">All Posts</a>
                    </li>
                    
                        
                    
                    
		    
                        <li><a href="/archive//">ARCHIVE</a></li>
                    
                        <li><a href="/notes//">NOTES</a></li>
                    
                        <li><a href="/about//">ABOUT</a></li>
                    
		            <li>
                        <a href="/search"><i class="fa fa-search"></i></a>
		           </li>
                </ul>
            </div>
        </div>
        
    </div>
    
</nav>
<script>
    
    
    
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        
            $navbar.className = " ";
            
            setTimeout(function(){
                
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>




<style type="text/css">
    header.intro-header {
        background-image: url('/img/post-bg-unix-linux.jpg')
    }
</style>

<header class="intro-header" >

    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/k8s" title="k8s">
                            k8s
                        </a>
                        
                    </div>
                    <h1>HAMi vGPU学习笔记</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        
                            Posted by 
                            
                                iceyao
                             
                            on 
                            Wednesday, December 11, 2024
                            
                            
                            
                            
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>




<article>
    <div class="container">
        <div class="row">

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                
                <h1 id="1-hami是什么">1. HAMi是什么</h1>
<p>想象一下你是一位繁忙的AI研究员，手头有好几个实验要跑，但实验室里的GPU显卡资源有限。这时候，<a href="https://github.com/Project-HAMi/HAMi">HAMi</a>就像一位智慧的资源管理员，帮你合理分配和调度这些宝贵的GPU资源。它就像是给GPU装上了&quot;分身术&quot;，让多个AI任务能够和谐共处在同一块显卡上。HAMi目前已经加入了云原生界的&quot;黄埔军校&quot;CNCF(云原生计算基金会)，作为一个充满潜力的沙箱项目茁壮成长。</p>
<p>让我们通过几个生动的场景，来了解HAMi的神奇之处：</p>
<ol>
<li>
<p>设备共享有妙招，就像一个灵活的&quot;设备调度大师&quot;：</p>
<ul>
<li>不管是GPU还是NPU，都能轻松管理，就像训练有素的管家</li>
<li>一个AI任务想要多个显卡？没问题！就像给你配备多位得力助手</li>
</ul>
</li>
<li>
<p>显存管理很智能，犹如一位精明的&quot;内存管家&quot;：</p>
<ul>
<li>每个任务的显存使用都有明确的&quot;配额&quot;，不会互相争抢</li>
<li>需要更多显存？可以随时调整，就像弹性伸缩的口袋</li>
<li>想用具体数值还是百分比来分配？都可以，就像点菜可以按份量也可以按比例</li>
</ul>
</li>
<li>
<p>设备挑选很贴心，像个专业的&quot;设备配对专家&quot;：</p>
<ul>
<li>只想用RTX 4090？没问题，就像指定特定型号的跑车</li>
<li>还能通过UUID精确定位设备，就像每个显卡都有自己的身份证</li>
</ul>
</li>
<li>
<p>上手特别容易，就像一个&quot;零门槛&quot;的好帮手：</p>
<ul>
<li>AI程序完全不用改代码，就像无缝衔接的魔法</li>
<li>安装卸载像玩积木一样简单，helm工具轻松搞定</li>
</ul>
</li>
<li>
<p>开放合作大家庭，像一个温暖的&quot;开源社区&quot;：</p>
<ul>
<li>各行各业的大咖都在参与，从互联网到金融，从制造业到云服务</li>
<li>加入CNCF大家庭，让更多朋友一起来建设，就像一个开放的创新工坊</li>
</ul>
</li>
</ol>
<h1 id="2-hami架构">2. HAMi架构</h1>
<p>
  <img src="https://project-hami.io/img/construct.JPG" alt="HAMi架构图">

</p>
<p>
  <img src="https://project-hami.io/assets/images/architect-0c69e5d8e1827a24d57edea269027eca.jpg" alt="HAMi架构图">


HAMi这套架构就像一个高效运转的智能办公大楼，由四个关键人员协同工作：</p>
<ol>
<li>
<p>前台接待员（HAMi MutatingWebhook）就像大楼的智能前台，当新的AI任务来访时：</p>
<ul>
<li>会仔细检查访客的&quot;需求清单&quot;（资源申请）</li>
<li>如果发现这位访客只需要基础设施（CPU、内存）或HAMi特供服务，就会贴上&quot;HAMi特别通行证&quot;</li>
<li>相当于一位细心的门卫，确保每个来访者都能得到合适的接待方式</li>
</ul>
</li>
<li>
<p>调度主管（HAMi scheduler-extender）犹如大楼的总调度室管理员：</p>
<ul>
<li>负责给每位访客安排最合适的办公位置（节点）和工作设备（GPU/NPU）</li>
<li>就像有一个实时更新的&quot;全楼设备状态大屏&quot;，随时掌握每个设备的使用情况</li>
<li>能够根据访客需求和设备状态，做出最优的分配决策</li>
</ul>
</li>
<li>
<p>设备管家（Device-plugin）像是一位神通广大的设备连接专家：</p>
<ul>
<li>看到调度主管的工位安排单后，立即着手准备相应的设备</li>
<li>负责将显卡等设备&quot;插上电源&quot;，确保设备随时可用</li>
<li>就像是在访客和设备之间搭建一座便捷的桥梁</li>
</ul>
</li>
<li>
<p>资源管控员（HAMi-Core）就像一位尽职的资源监管员：</p>
<ul>
<li>时刻关注每个访客的资源使用情况，确保不会超出预定配额</li>
<li>设置明确的资源使用界限，防止互相干扰</li>
<li>当某个任务试图占用过多资源时，会及时进行管控</li>
</ul>
</li>
</ol>
<h1 id="3-hami应用场景">3. HAMi应用场景</h1>
<h2 id="31-设备共享">3.1 设备共享</h2>
<p>
  <img src="https://project-hami.io/assets/images/example-36b9da0b8783bb0915cfaeed44c9fdb6.png" alt="HAMi设备共享">

</p>
<p>HAMi的设备共享就像是一个智能的资源分配系统，让一块显卡能够同时服务多个AI任务：</p>
<ol>
<li>
<p><strong>灵活的显存分配</strong></p>
<ul>
<li>可以精确指定每个任务使用多少显存</li>
<li>就像给每个租户分配固定大小的&quot;储物柜&quot;</li>
</ul>
</li>
<li>
<p><strong>算力精确控制</strong></p>
<ul>
<li>对计算单元（流处理器）进行严格限制</li>
<li>就像给每个租户分配固定数量的&quot;工作人员&quot;</li>
</ul>
</li>
<li>
<p><strong>核心使用率管理</strong></p>
<ul>
<li>支持按需分配设备核心使用率</li>
<li>就像给不同任务分配不同的&quot;工作时间&quot;</li>
</ul>
</li>
<li>
<p><strong>无缝适配已有程序</strong></p>
<ul>
<li>完全不需要修改现有的程序代码</li>
<li>就像租客入住时不需要重新装修，直接拎包入住</li>
</ul>
</li>
</ol>
<h2 id="32-设备资源隔离">3.2 设备资源隔离</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>resources:
</span></span><span style="display:flex;"><span>  limits:
</span></span><span style="display:flex;"><span>    nvidia.com/gpu: <span style="color:#bd93f9">1</span>    <span style="color:#6272a4"># 请求1个虚拟GPU</span>
</span></span><span style="display:flex;"><span>    nvidia.com/gpumem: <span style="color:#bd93f9">3000</span>    <span style="color:#6272a4"># 每个虚拟GPU包含3000MB设备内存</span>
</span></span></code></pre></div><p>在容器内部看到的1张卡，显存3GB</p>
<h1 id="4-helm部署hami">4. Helm部署HAMi</h1>
<h2 id="41-前置条件">4.1 前置条件</h2>
<ul>
<li><a href="https://helm.sh/zh/docs/">Helm</a> version v3+</li>
<li><a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/">kubectl</a> version v1.16+</li>
<li><a href="https://developer.nvidia.com/cuda-toolkit">CUDA</a> version v10.2+</li>
<li><a href="https://www.nvidia.cn/drivers/unix/">Nvidia Driver</a> version v440+</li>
</ul>
<h2 id="42-配置nvidia-runtime">4.2 配置nvidia runtime</h2>
<p>安装nvidia-container-toolkit，配置nvidia-container-runtime</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">distribution</span><span style="color:#ff79c6">=</span><span style="color:#ff79c6">$(</span>. /etc/os-release;<span style="color:#8be9fd;font-style:italic">echo</span> <span style="color:#8be9fd;font-style:italic">$ID$VERSION_ID</span><span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span>curl -s -L https://nvidia.github.io/libnvidia-container/gpgkey | sudo apt-key add -
</span></span><span style="display:flex;"><span>curl -s -L https://nvidia.github.io/libnvidia-container/<span style="color:#8be9fd;font-style:italic">$distribution</span>/libnvidia-container.list | sudo tee /etc/apt/sources.list.d/libnvidia-container.list
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sudo apt-get update <span style="color:#ff79c6">&amp;&amp;</span> sudo apt-get install -y nvidia-container-toolkit
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#6272a4"># 如果container runtime使用的是docker</span>
</span></span><span style="display:flex;"><span>vim /etc/docker/daemon.json
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;default-runtime&#34;</span>: <span style="color:#f1fa8c">&#34;nvidia&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;runtimes&#34;</span>: <span style="color:#ff79c6">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;nvidia&#34;</span>: <span style="color:#ff79c6">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f1fa8c">&#34;path&#34;</span>: <span style="color:#f1fa8c">&#34;/usr/bin/nvidia-container-runtime&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#f1fa8c">&#34;runtimeArgs&#34;</span>: <span style="color:#ff79c6">[]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">}</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sudo systemctl daemon-reload <span style="color:#ff79c6">&amp;&amp;</span> systemctl restart docker
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#6272a4"># 如果container runtime使用的是containerd</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">(</span>base<span style="color:#ff79c6">)</span> root@vgpu:/root# nvidia-ctk runtime configure --runtime<span style="color:#ff79c6">=</span>containerd
</span></span><span style="display:flex;"><span>INFO<span style="color:#ff79c6">[</span>0000<span style="color:#ff79c6">]</span> Wrote updated config to /etc/containerd/config.toml
</span></span><span style="display:flex;"><span>INFO<span style="color:#ff79c6">[</span>0000<span style="color:#ff79c6">]</span> It is recommended that containerd daemon be restarted.
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#6272a4"># 如果container runtime使用的是containerd</span>
</span></span><span style="display:flex;"><span>vim /etc/containerd/config.toml
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">version</span> <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">2</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>plugins<span style="color:#ff79c6">]</span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">[</span>plugins.<span style="color:#f1fa8c">&#34;io.containerd.grpc.v1.cri&#34;</span><span style="color:#ff79c6">]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">[</span>plugins.<span style="color:#f1fa8c">&#34;io.containerd.grpc.v1.cri&#34;</span>.containerd<span style="color:#ff79c6">]</span>
</span></span><span style="display:flex;"><span>      <span style="color:#8be9fd;font-style:italic">default_runtime_name</span> <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;nvidia&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#ff79c6">[</span>plugins.<span style="color:#f1fa8c">&#34;io.containerd.grpc.v1.cri&#34;</span>.containerd.runtimes<span style="color:#ff79c6">]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">[</span>plugins.<span style="color:#f1fa8c">&#34;io.containerd.grpc.v1.cri&#34;</span>.containerd.runtimes.nvidia<span style="color:#ff79c6">]</span>
</span></span><span style="display:flex;"><span>          <span style="color:#8be9fd;font-style:italic">privileged_without_host_devices</span> <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">false</span>
</span></span><span style="display:flex;"><span>          <span style="color:#8be9fd;font-style:italic">runtime_engine</span> <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#8be9fd;font-style:italic">runtime_root</span> <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#8be9fd;font-style:italic">runtime_type</span> <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;io.containerd.runc.v2&#34;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#ff79c6">[</span>plugins.<span style="color:#f1fa8c">&#34;io.containerd.grpc.v1.cri&#34;</span>.containerd.runtimes.nvidia.options<span style="color:#ff79c6">]</span>
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">BinaryName</span> <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;/usr/bin/nvidia-container-runtime&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sudo systemctl daemon-reload <span style="color:#ff79c6">&amp;&amp;</span> systemctl restart containerd
</span></span></code></pre></div><p>为containerd配置代理(docker daemon同理)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vim  /etc/systemd/system/containerd.service
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>Service<span style="color:#ff79c6">]</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">Environment</span><span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#34;HTTP_PROXY=http://&lt;代理地址&gt;:&lt;代理端口&gt;&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">Environment</span><span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#34;HTTPS_PROXY=http://&lt;代理地址&gt;:&lt;代理端口&gt;&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">Environment</span><span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#34;NO_PROXY=localhost,127.0.0.1&#34;</span>
</span></span></code></pre></div><h2 id="43-gpu节点标签">4.3 GPU节点标签</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>kubectl label nodes <span style="color:#ff79c6">{</span>nodeid<span style="color:#ff79c6">}</span> <span style="color:#8be9fd;font-style:italic">gpu</span><span style="color:#ff79c6">=</span>on
</span></span></code></pre></div><h2 id="44-部署hami">4.4 部署HAMi</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">image_version</span><span style="color:#ff79c6">=</span><span style="color:#ff79c6">$(</span>kubectl version 2&gt;/dev/null | grep GitVersion | head -1 | awk -F<span style="color:#f1fa8c">&#39;&#34;&#39;</span> <span style="color:#f1fa8c">&#39;{print $6}&#39;</span><span style="color:#ff79c6">)</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>helm repo add hami-charts https://project-hami.github.io/HAMi/
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>helm install hami hami-charts/hami --set scheduler.kubeScheduler.imageTag<span style="color:#ff79c6">=</span><span style="color:#f1fa8c">${</span><span style="color:#8be9fd;font-style:italic">image_version</span><span style="color:#f1fa8c">}</span> -n kube-system
</span></span></code></pre></div><h2 id="45-验证hami">4.5 验证HAMi</h2>
<p>创建gpu pod</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#6272a4"># 创建一个测试用的Pod，用于验证HAMi的基本功能</span>
</span></span><span style="display:flex;"><span>cat <span style="color:#f1fa8c">&lt;&lt; &#39;EOF&#39; | kubectl apply -f -
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">apiVersion: v1
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">kind: Pod
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">metadata:
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">  name: gpu-pod
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">spec:
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">  containers:
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">    - name: ubuntu-container
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">      image: ubuntu:18.04
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">      command: [&#34;bash&#34;, &#34;-c&#34;, &#34;sleep 86400&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">      resources:
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        limits:
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">          nvidia.com/gpu: 1 # requesting 1 vGPUs
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">          nvidia.com/gpumem: 10240 # Each vGPU contains 3000m device memory （Optional,Integer）
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">EOF</span>
</span></span></code></pre></div><p>进入到容器里查看，可以看到1张卡，显存1GB</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#ff79c6">(</span>base<span style="color:#ff79c6">)</span> root@vgpu:~# kubectl <span style="color:#8be9fd;font-style:italic">exec</span> -it gpu-pod -- nvidia-smi
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Msg<span style="color:#ff79c6">(</span>24:139957573396288:libvgpu.c:836<span style="color:#ff79c6">)]</span>: Initializing.....
</span></span><span style="display:flex;"><span>Fri Dec <span style="color:#bd93f9">13</span> 05:55:05 <span style="color:#bd93f9">2024</span>
</span></span><span style="display:flex;"><span>+-----------------------------------------------------------------------------------------+
</span></span><span style="display:flex;"><span>| NVIDIA-SMI 550.135                Driver Version: 550.135        CUDA Version: 12.4     |
</span></span><span style="display:flex;"><span>|-----------------------------------------+------------------------+----------------------+
</span></span><span style="display:flex;"><span>| GPU  Name                 Persistence-M | Bus-Id          Disp.A | Volatile Uncorr. ECC |
</span></span><span style="display:flex;"><span>| Fan  Temp   Perf          Pwr:Usage/Cap |           Memory-Usage | GPU-Util  Compute M. |
</span></span><span style="display:flex;"><span>|                                         |                        |               MIG M. |
</span></span><span style="display:flex;"><span>|<span style="color:#ff79c6">=========================================</span>+<span style="color:#ff79c6">========================</span>+<span style="color:#ff79c6">======================</span>|
</span></span><span style="display:flex;"><span>|   <span style="color:#bd93f9">0</span>  NVIDIA GeForce RTX <span style="color:#bd93f9">3090</span>        Off |   00000000:00:05.0 Off |                  N/A |
</span></span><span style="display:flex;"><span>|  0%   26C    P8              7W /  370W |       0MiB /  10240MiB |      0%      Default |
</span></span><span style="display:flex;"><span>|                                         |                        |                  N/A |
</span></span><span style="display:flex;"><span>+-----------------------------------------+------------------------+----------------------+
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>+-----------------------------------------------------------------------------------------+
</span></span><span style="display:flex;"><span>| Processes:                                                                              |
</span></span><span style="display:flex;"><span>|  GPU   GI   CI        PID   Type   Process name                              GPU Memory |
</span></span><span style="display:flex;"><span>|        ID   ID                                                               Usage      |
</span></span><span style="display:flex;"><span>|<span style="color:#ff79c6">=========================================================================================</span>|
</span></span><span style="display:flex;"><span>|  No running processes found                                                             |
</span></span><span style="display:flex;"><span>+-----------------------------------------------------------------------------------------+
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Msg<span style="color:#ff79c6">(</span>24:139957573396288:multiprocess_memory_limit.c:497<span style="color:#ff79c6">)]</span>: Calling <span style="color:#8be9fd;font-style:italic">exit</span> handler <span style="color:#bd93f9">24</span>
</span></span></code></pre></div><h2 id="46-多pod共享gpu">4.6 多pod共享GPU</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#6272a4"># 创建一个包含3个Pod的Deployment，用于测试GPU共享功能</span>
</span></span><span style="display:flex;"><span>cat <span style="color:#f1fa8c">&lt;&lt; &#39;EOF&#39; | kubectl apply -f -
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">apiVersion: apps/v1
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">kind: Deployment
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">metadata:
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">  name: hami-npod-1gpu
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">spec:
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">  replicas: 3  # 创建三个相同的 Pod，可根据需要修改数量
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">  selector:
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">    matchLabels:
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">      app: pytorch
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">  template:
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">    metadata:
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">      labels:
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        app: pytorch
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">    spec:
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">      containers:
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">      - name: pytorch-container
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        image: uhub.service.ucloud.cn/gpu-share/gpu_pytorch_test:latest
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        command: [&#34;/bin/sh&#34;, &#34;-c&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        args: [&#34;cd /app/pytorch_code &amp;&amp; python3 2.py&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">        resources:
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">          limits:
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">            nvidia.com/gpu: 1
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">            nvidia.com/gpumem: 3000
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">            nvidia.com/gpucores: 25
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">EOF</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#6272a4"># 查看创建的Pod状态</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">(</span>base<span style="color:#ff79c6">)</span> root@vgpu:~# kubectl get pod
</span></span><span style="display:flex;"><span>NAME                              READY   STATUS    RESTARTS   AGE
</span></span><span style="display:flex;"><span>hami-npod-1gpu-6f65f668b7-6k2jh   1/1     Running   <span style="color:#bd93f9">0</span>          5s
</span></span><span style="display:flex;"><span>hami-npod-1gpu-6f65f668b7-f48gm   1/1     Running   <span style="color:#bd93f9">0</span>          5s
</span></span><span style="display:flex;"><span>hami-npod-1gpu-6f65f668b7-kpnbg   1/1     Running   <span style="color:#bd93f9">0</span>          5s
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#6272a4"># 查看主机上的GPU使用情况</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">(</span>base<span style="color:#ff79c6">)</span> root@vgpu:~# nvidia-smi
</span></span><span style="display:flex;"><span>Fri Dec <span style="color:#bd93f9">13</span> 09:32:47 <span style="color:#bd93f9">2024</span>
</span></span><span style="display:flex;"><span>+-----------------------------------------------------------------------------------------+
</span></span><span style="display:flex;"><span>| NVIDIA-SMI 550.135                Driver Version: 550.135        CUDA Version: 12.4     |
</span></span><span style="display:flex;"><span>|-----------------------------------------+------------------------+----------------------+
</span></span><span style="display:flex;"><span>| GPU  Name                 Persistence-M | Bus-Id          Disp.A | Volatile Uncorr. ECC |
</span></span><span style="display:flex;"><span>| Fan  Temp   Perf          Pwr:Usage/Cap |           Memory-Usage | GPU-Util  Compute M. |
</span></span><span style="display:flex;"><span>|                                         |                        |               MIG M. |
</span></span><span style="display:flex;"><span>|<span style="color:#ff79c6">=========================================</span>+<span style="color:#ff79c6">========================</span>+<span style="color:#ff79c6">======================</span>|
</span></span><span style="display:flex;"><span>|   <span style="color:#bd93f9">0</span>  NVIDIA GeForce RTX <span style="color:#bd93f9">3090</span>        Off |   00000000:00:05.0 Off |                  N/A |
</span></span><span style="display:flex;"><span>| 34%   33C    P2            103W /  370W |    1320MiB /  24576MiB |      2%      Default |
</span></span><span style="display:flex;"><span>|                                         |                        |                  N/A |
</span></span><span style="display:flex;"><span>+-----------------------------------------+------------------------+----------------------+
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>+-----------------------------------------------------------------------------------------+
</span></span><span style="display:flex;"><span>| Processes:                                                                              |
</span></span><span style="display:flex;"><span>|  GPU   GI   CI        PID   Type   Process name                              GPU Memory |
</span></span><span style="display:flex;"><span>|        ID   ID                                                               Usage      |
</span></span><span style="display:flex;"><span>|<span style="color:#ff79c6">=========================================================================================</span>|
</span></span><span style="display:flex;"><span>|    <span style="color:#bd93f9">0</span>   N/A  N/A     <span style="color:#bd93f9">19635</span>      C   python3                                       478MiB |
</span></span><span style="display:flex;"><span>|    <span style="color:#bd93f9">0</span>   N/A  N/A     <span style="color:#bd93f9">19713</span>      C   python3                                       478MiB |
</span></span><span style="display:flex;"><span>|    <span style="color:#bd93f9">0</span>   N/A  N/A     <span style="color:#bd93f9">19900</span>      C   python3                                       352MiB |
</span></span><span style="display:flex;"><span>+-----------------------------------------------------------------------------------------+
</span></span></code></pre></div><h1 id="5-hami代码分析">5. HAMi代码分析</h1>
<p>以代码commit为例：<code>96adaec66c4472383108de2d18698b47f5e6e553</code></p>
<h2 id="51-hami-scheduler调试环境">5.1 hami-scheduler调试环境</h2>
<p>因为gpu环境在远程服务器端，所以利用dlv+golang来搭建远程调试环境.大体思路是：</p>
<ul>
<li>在远程gpu服务器上用dlv启动hami-scheduler</li>
<li>把hami-scheduler相关的配置指向本地本地dlv启动的hami-scheduler服务</li>
</ul>
<ol>
<li>在远程gpu服务器上用dlv启动hami-scheduler</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>root@vgpu:~# nerdctl -n k8s.io cp &lt;hami-scheduler-container-id&gt;:/tls/tls.crt /root/tls/
</span></span><span style="display:flex;"><span>root@vgpu:~# nerdctl -n k8s.io cp &lt;hami-scheduler-container-id&gt;:/tls/tls.key /root/tls/
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>dlv <span style="color:#8be9fd;font-style:italic">exec</span> bin/scheduler --headless -l 0.0.0.0:2345 --api-version<span style="color:#ff79c6">=</span><span style="color:#bd93f9">2</span> -- <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>--http_bind<span style="color:#ff79c6">=</span>0.0.0.0:9443 <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>--cert_file<span style="color:#ff79c6">=</span>/root/tls/tls.crt <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>--key_file<span style="color:#ff79c6">=</span>/root/tls/tls.key <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>--scheduler-name<span style="color:#ff79c6">=</span>hami-scheduler <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>--node-scheduler-policy<span style="color:#ff79c6">=</span>binpack <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>--gpu-scheduler-policy<span style="color:#ff79c6">=</span>spread <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>--device-config-file<span style="color:#ff79c6">=</span>/root/device-config.yaml
</span></span></code></pre></div><p>启动参数通过<code>kubectl -n kube-system edit deployments.apps hami-scheduler</code>可以查看，<code>device-config.yaml</code>文件通过<code>nerdctl -n k8s.io cp &lt;hami-scheduler-container-id&gt;:/root/device-config.yaml</code>获取。<code>dlv debug</code>直接调试源代码并自动编译（适合开发环境），而<code>dlv exec</code>调试已编译的二进制文件（适合生产环境，但需要编译时包含调试信息 -gcflags=&ldquo;all=-N -l&rdquo;）,<code>dlv exec</code>直接作用于二进制，启动较快。HAMi代码库中有提供<code>Makefile</code>需要移除下<code>-s -w</code>参数，<code>make build</code>可以编译出包含调试信息的二进制文件。</p>
<ol>
<li>hami-webhook指向本地dlv启动的hami-scheduler服务</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#ff79c6">(</span>base<span style="color:#ff79c6">)</span> root@vgpu:~# kubectl edit mutatingwebhookconfigurations.admissionregistration.k8s.io hami-webhook
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># webhook限制强制使用https，复用证书，用127.0.0.1的地址</span>
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>webhooks:
</span></span><span style="display:flex;"><span>  - admissionReviewVersions:
</span></span><span style="display:flex;"><span>    - v1beta1
</span></span><span style="display:flex;"><span>    clientConfig:
</span></span><span style="display:flex;"><span>      url: https://127.0.0.1:9443/webhook
</span></span><span style="display:flex;"><span>...      
</span></span></code></pre></div><ol start="2">
<li>hami-scheduler extender指向本地dlv启动的hami-scheduler服务</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#ff79c6">(</span>base<span style="color:#ff79c6">)</span> root@vgpu:~# kubectl -n kube-system edit cm hami-scheduler-newversion
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>apiVersion: v1
</span></span><span style="display:flex;"><span>data:
</span></span><span style="display:flex;"><span>  config.yaml: |
</span></span><span style="display:flex;"><span>    apiVersion: kubescheduler.config.k8s.io/v1beta2
</span></span><span style="display:flex;"><span>    kind: KubeSchedulerConfiguration
</span></span><span style="display:flex;"><span>    leaderElection:
</span></span><span style="display:flex;"><span>      leaderElect: <span style="color:#8be9fd;font-style:italic">false</span>
</span></span><span style="display:flex;"><span>    profiles:
</span></span><span style="display:flex;"><span>    - schedulerName: hami-scheduler
</span></span><span style="display:flex;"><span>    extenders:
</span></span><span style="display:flex;"><span>    - urlPrefix: <span style="color:#f1fa8c">&#34;https://&lt;dlv-local-ip&gt;:9443&#34;</span>
</span></span><span style="display:flex;"><span>      filterVerb: filter
</span></span><span style="display:flex;"><span>      bindVerb: <span style="color:#8be9fd;font-style:italic">bind</span>
</span></span><span style="display:flex;"><span>      nodeCacheCapable: <span style="color:#8be9fd;font-style:italic">true</span>
</span></span><span style="display:flex;"><span>      weight: <span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span>      httpTimeout: 30s
</span></span><span style="display:flex;"><span>      enableHTTPS: <span style="color:#8be9fd;font-style:italic">false</span>
</span></span><span style="display:flex;"><span>      tlsConfig:
</span></span><span style="display:flex;"><span>        insecure: <span style="color:#8be9fd;font-style:italic">true</span>
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>hami-scheduler deployment实际上包含两个container：一个是kube-scheduler原生调度器，一个是hami-scheduler自定义调度器；扩展调度器用的还是废弃的extender机制，并非scheduler framework。exterder机制虽有性能问题，但是使用起来比较简单。</p>
<ol start="3">
<li>goland添加Go Remote Debugger指向<!-- raw HTML omitted -->:2345</li>
</ol>
<h2 id="52-hami-scheduler核心逻辑">5.2 hami-scheduler核心逻辑</h2>
<p>hami-scheduler带的命令行参数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">init</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 禁用了命令行参数的自动排序，保持参数的定义顺序
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	rootCmd.<span style="color:#50fa7b">Flags</span>().SortFlags = <span style="color:#ff79c6">false</span>
</span></span><span style="display:flex;"><span>	rootCmd.<span style="color:#50fa7b">PersistentFlags</span>().SortFlags = <span style="color:#ff79c6">false</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	rootCmd.<span style="color:#50fa7b">Flags</span>().<span style="color:#50fa7b">StringVar</span>(<span style="color:#ff79c6">&amp;</span>config.HTTPBind, <span style="color:#f1fa8c">&#34;http_bind&#34;</span>, <span style="color:#f1fa8c">&#34;127.0.0.1:8080&#34;</span>, <span style="color:#f1fa8c">&#34;http server bind address&#34;</span>)
</span></span><span style="display:flex;"><span>	rootCmd.<span style="color:#50fa7b">Flags</span>().<span style="color:#50fa7b">StringVar</span>(<span style="color:#ff79c6">&amp;</span>tlsCertFile, <span style="color:#f1fa8c">&#34;cert_file&#34;</span>, <span style="color:#f1fa8c">&#34;&#34;</span>, <span style="color:#f1fa8c">&#34;tls cert file&#34;</span>)
</span></span><span style="display:flex;"><span>	rootCmd.<span style="color:#50fa7b">Flags</span>().<span style="color:#50fa7b">StringVar</span>(<span style="color:#ff79c6">&amp;</span>tlsKeyFile, <span style="color:#f1fa8c">&#34;key_file&#34;</span>, <span style="color:#f1fa8c">&#34;&#34;</span>, <span style="color:#f1fa8c">&#34;tls key file&#34;</span>)
</span></span><span style="display:flex;"><span>	rootCmd.<span style="color:#50fa7b">Flags</span>().<span style="color:#50fa7b">StringVar</span>(<span style="color:#ff79c6">&amp;</span>config.SchedulerName, <span style="color:#f1fa8c">&#34;scheduler-name&#34;</span>, <span style="color:#f1fa8c">&#34;&#34;</span>, <span style="color:#f1fa8c">&#34;the name to be added to pod.spec.schedulerName if not empty&#34;</span>)
</span></span><span style="display:flex;"><span>	rootCmd.<span style="color:#50fa7b">Flags</span>().<span style="color:#50fa7b">Int32Var</span>(<span style="color:#ff79c6">&amp;</span>config.DefaultMem, <span style="color:#f1fa8c">&#34;default-mem&#34;</span>, <span style="color:#bd93f9">0</span>, <span style="color:#f1fa8c">&#34;default gpu device memory to allocate&#34;</span>)
</span></span><span style="display:flex;"><span>	rootCmd.<span style="color:#50fa7b">Flags</span>().<span style="color:#50fa7b">Int32Var</span>(<span style="color:#ff79c6">&amp;</span>config.DefaultCores, <span style="color:#f1fa8c">&#34;default-cores&#34;</span>, <span style="color:#bd93f9">0</span>, <span style="color:#f1fa8c">&#34;default gpu core percentage to allocate&#34;</span>)
</span></span><span style="display:flex;"><span>	rootCmd.<span style="color:#50fa7b">Flags</span>().<span style="color:#50fa7b">Int32Var</span>(<span style="color:#ff79c6">&amp;</span>config.DefaultResourceNum, <span style="color:#f1fa8c">&#34;default-gpu&#34;</span>, <span style="color:#bd93f9">1</span>, <span style="color:#f1fa8c">&#34;default gpu to allocate&#34;</span>)
</span></span><span style="display:flex;"><span>	rootCmd.<span style="color:#50fa7b">Flags</span>().<span style="color:#50fa7b">StringVar</span>(<span style="color:#ff79c6">&amp;</span>config.NodeSchedulerPolicy, <span style="color:#f1fa8c">&#34;node-scheduler-policy&#34;</span>, util.NodeSchedulerPolicyBinpack.<span style="color:#50fa7b">String</span>(), <span style="color:#f1fa8c">&#34;node scheduler policy&#34;</span>)
</span></span><span style="display:flex;"><span>	rootCmd.<span style="color:#50fa7b">Flags</span>().<span style="color:#50fa7b">StringVar</span>(<span style="color:#ff79c6">&amp;</span>config.GPUSchedulerPolicy, <span style="color:#f1fa8c">&#34;gpu-scheduler-policy&#34;</span>, util.GPUSchedulerPolicySpread.<span style="color:#50fa7b">String</span>(), <span style="color:#f1fa8c">&#34;GPU scheduler policy&#34;</span>)
</span></span><span style="display:flex;"><span>	rootCmd.<span style="color:#50fa7b">Flags</span>().<span style="color:#50fa7b">StringVar</span>(<span style="color:#ff79c6">&amp;</span>config.MetricsBindAddress, <span style="color:#f1fa8c">&#34;metrics-bind-address&#34;</span>, <span style="color:#f1fa8c">&#34;:9395&#34;</span>, <span style="color:#f1fa8c">&#34;The TCP address that the scheduler should bind to for serving prometheus metrics(e.g. 127.0.0.1:9395, :9395)&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 区分了 Flags() 和 PersistentFlags()：
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// Flags()：仅对当前命令有效的参数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// PersistentFlags()：对当前命令及其子命令都有效的参数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	rootCmd.<span style="color:#50fa7b">Flags</span>().<span style="color:#50fa7b">StringToStringVar</span>(<span style="color:#ff79c6">&amp;</span>config.NodeLabelSelector, <span style="color:#f1fa8c">&#34;node-label-selector&#34;</span>, <span style="color:#ff79c6">nil</span>, <span style="color:#f1fa8c">&#34;key=value pairs separated by commas&#34;</span>)
</span></span><span style="display:flex;"><span>	rootCmd.<span style="color:#50fa7b">PersistentFlags</span>().<span style="color:#50fa7b">AddGoFlagSet</span>(device.<span style="color:#50fa7b">GlobalFlagSet</span>())
</span></span><span style="display:flex;"><span>	rootCmd.<span style="color:#50fa7b">AddCommand</span>(version.VersionCmd)
</span></span><span style="display:flex;"><span>	rootCmd.<span style="color:#50fa7b">Flags</span>().<span style="color:#50fa7b">AddGoFlagSet</span>(util.<span style="color:#50fa7b">InitKlogFlags</span>())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// 其它的全局命令行参数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">GlobalFlagSet</span>() <span style="color:#ff79c6">*</span>flag.FlagSet {
</span></span><span style="display:flex;"><span>	fs <span style="color:#ff79c6">:=</span> flag.<span style="color:#50fa7b">NewFlagSet</span>(os.Args[<span style="color:#bd93f9">0</span>], flag.ExitOnError)
</span></span><span style="display:flex;"><span>	ascend.<span style="color:#50fa7b">ParseConfig</span>(fs)
</span></span><span style="display:flex;"><span>	cambricon.<span style="color:#50fa7b">ParseConfig</span>(fs)
</span></span><span style="display:flex;"><span>	hygon.<span style="color:#50fa7b">ParseConfig</span>(fs)
</span></span><span style="display:flex;"><span>	iluvatar.<span style="color:#50fa7b">ParseConfig</span>(fs)
</span></span><span style="display:flex;"><span>	nvidia.<span style="color:#50fa7b">ParseConfig</span>(fs)
</span></span><span style="display:flex;"><span>	mthreads.<span style="color:#50fa7b">ParseConfig</span>(fs)
</span></span><span style="display:flex;"><span>	metax.<span style="color:#50fa7b">ParseConfig</span>(fs)
</span></span><span style="display:flex;"><span>	fs.<span style="color:#50fa7b">BoolVar</span>(<span style="color:#ff79c6">&amp;</span>DebugMode, <span style="color:#f1fa8c">&#34;debug&#34;</span>, <span style="color:#ff79c6">false</span>, <span style="color:#f1fa8c">&#34;debug mode&#34;</span>)
</span></span><span style="display:flex;"><span>	fs.<span style="color:#50fa7b">StringVar</span>(<span style="color:#ff79c6">&amp;</span>configFile, <span style="color:#f1fa8c">&#34;device-config-file&#34;</span>, <span style="color:#f1fa8c">&#34;&#34;</span>, <span style="color:#f1fa8c">&#34;device config file&#34;</span>)
</span></span><span style="display:flex;"><span>	klog.<span style="color:#50fa7b">InitFlags</span>(fs)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> fs
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>scheduler启动函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">start</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 根据device-config初始化devices map
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	device.<span style="color:#50fa7b">InitDevices</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 初始化hami-scheduelr调度器
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	sher = scheduler.<span style="color:#50fa7b">NewScheduler</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 启动hami-scheduelr调度器
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	sher.<span style="color:#50fa7b">Start</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 停止调度器
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">defer</span> sher.<span style="color:#50fa7b">Stop</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// 这个函数的主要职责是：
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 1. 持续监控：
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 通过channel和定时器实现持续监控
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 响应节点变更事件和定时检查
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 2. 设备健康检查：
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 定期检查每个节点上的设备健康状态
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 处理不健康的设备（清理和移除）
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 3. 设备信息更新：
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 维护最新的节点设备信息
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 处理设备握手机制
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 更新调度器的设备缓存
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 4. 资源使用统计：
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 追踪并更新节点资源使用情况
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 这是调度器的核心组件之一，确保调度决策基于最新的节点和设备状态信息。
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">go</span> sher.<span style="color:#50fa7b">RegisterFromNodeAnnotations</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 暴露metrics监控指标
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">go</span> <span style="color:#50fa7b">initMetrics</span>(config.MetricsBindAddress)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// 启动一个http server，用于处理调度器请求
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	router <span style="color:#ff79c6">:=</span> httprouter.<span style="color:#50fa7b">New</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 调度filter阶段请求
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	router.<span style="color:#50fa7b">POST</span>(<span style="color:#f1fa8c">&#34;/filter&#34;</span>, routes.<span style="color:#50fa7b">PredicateRoute</span>(sher))
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 调度bind阶段请求
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	router.<span style="color:#50fa7b">POST</span>(<span style="color:#f1fa8c">&#34;/bind&#34;</span>, routes.<span style="color:#50fa7b">Bind</span>(sher))
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// webhook请求
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	router.<span style="color:#50fa7b">POST</span>(<span style="color:#f1fa8c">&#34;/webhook&#34;</span>, routes.<span style="color:#50fa7b">WebHookRoute</span>())
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 健康检查请求
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	router.<span style="color:#50fa7b">GET</span>(<span style="color:#f1fa8c">&#34;/healthz&#34;</span>, routes.<span style="color:#50fa7b">HealthzRoute</span>())
</span></span><span style="display:flex;"><span>	klog.<span style="color:#50fa7b">Info</span>(<span style="color:#f1fa8c">&#34;listen on &#34;</span>, config.HTTPBind)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">len</span>(tlsCertFile) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">||</span> <span style="color:#8be9fd;font-style:italic">len</span>(tlsKeyFile) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> http.<span style="color:#50fa7b">ListenAndServe</span>(config.HTTPBind, router); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>			klog.<span style="color:#50fa7b">Fatal</span>(<span style="color:#f1fa8c">&#34;Listen and Serve error, &#34;</span>, err)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	} <span style="color:#ff79c6">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> http.<span style="color:#50fa7b">ListenAndServeTLS</span>(config.HTTPBind, tlsCertFile, tlsKeyFile, router); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>			klog.<span style="color:#50fa7b">Fatal</span>(<span style="color:#f1fa8c">&#34;Listen and Serve error, &#34;</span>, err)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>为什么要初始化GPU设备devices map？通过这种初始化机制，HAMi可以统一管理不同类型的GPU，为上层调度提供统一的设备抽象。需要维护一个设备注册表，记录所有支持的GPU。每个设备都需要实现<code>Devices</code>接口，提供以下核心功能：</p>
<ul>
<li>资源分配和管理</li>
<li>设备健康检查</li>
<li>节点打分和筛选</li>
<li>设备锁定和释放</li>
<li>资源使用统计</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#6272a4">// Devices接口定义了GPU设备的核心功能，从目前实现来看支持7种设备：nvidia、ascend、cambricon、hygon、iluvatar、mthreads、metax
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> Devices <span style="color:#8be9fd;font-style:italic">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#50fa7b">CommonWord</span>() <span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>	<span style="color:#50fa7b">MutateAdmission</span>(ctr <span style="color:#ff79c6">*</span>corev1.Container, pod <span style="color:#ff79c6">*</span>corev1.Pod) (<span style="color:#8be9fd">bool</span>, <span style="color:#8be9fd">error</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#50fa7b">CheckHealth</span>(devType <span style="color:#8be9fd">string</span>, n <span style="color:#ff79c6">*</span>corev1.Node) (<span style="color:#8be9fd">bool</span>, <span style="color:#8be9fd">bool</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#50fa7b">NodeCleanUp</span>(nn <span style="color:#8be9fd">string</span>) <span style="color:#8be9fd">error</span>
</span></span><span style="display:flex;"><span>	<span style="color:#50fa7b">GetNodeDevices</span>(n corev1.Node) ([]<span style="color:#ff79c6">*</span>util.DeviceInfo, <span style="color:#8be9fd">error</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#50fa7b">CheckType</span>(annos <span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">string</span>]<span style="color:#8be9fd">string</span>, d util.DeviceUsage, n util.ContainerDeviceRequest) (<span style="color:#8be9fd">bool</span>, <span style="color:#8be9fd">bool</span>, <span style="color:#8be9fd">bool</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// CheckUUID is check current device id whether in GPUUseUUID or GPUNoUseUUID set, return true is check success.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#50fa7b">CheckUUID</span>(annos <span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">string</span>]<span style="color:#8be9fd">string</span>, d util.DeviceUsage) <span style="color:#8be9fd">bool</span>
</span></span><span style="display:flex;"><span>	<span style="color:#50fa7b">LockNode</span>(n <span style="color:#ff79c6">*</span>corev1.Node, p <span style="color:#ff79c6">*</span>corev1.Pod) <span style="color:#8be9fd">error</span>
</span></span><span style="display:flex;"><span>	<span style="color:#50fa7b">ReleaseNodeLock</span>(n <span style="color:#ff79c6">*</span>corev1.Node, p <span style="color:#ff79c6">*</span>corev1.Pod) <span style="color:#8be9fd">error</span>
</span></span><span style="display:flex;"><span>	<span style="color:#50fa7b">GenerateResourceRequests</span>(ctr <span style="color:#ff79c6">*</span>corev1.Container) util.ContainerDeviceRequest
</span></span><span style="display:flex;"><span>	<span style="color:#50fa7b">PatchAnnotations</span>(annoinput <span style="color:#ff79c6">*</span><span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">string</span>]<span style="color:#8be9fd">string</span>, pd util.PodDevices) <span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">string</span>]<span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>	<span style="color:#50fa7b">CustomFilterRule</span>(allocated <span style="color:#ff79c6">*</span>util.PodDevices, request util.ContainerDeviceRequest, toAllicate util.ContainerDevices, device <span style="color:#ff79c6">*</span>util.DeviceUsage) <span style="color:#8be9fd">bool</span>
</span></span><span style="display:flex;"><span>	<span style="color:#50fa7b">ScoreNode</span>(node <span style="color:#ff79c6">*</span>corev1.Node, podDevices util.PodSingleDevice, policy <span style="color:#8be9fd">string</span>) <span style="color:#8be9fd">float32</span>
</span></span><span style="display:flex;"><span>	<span style="color:#50fa7b">AddResourceUsage</span>(n <span style="color:#ff79c6">*</span>util.DeviceUsage, ctr <span style="color:#ff79c6">*</span>util.ContainerDevice) <span style="color:#8be9fd">error</span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// This should not be associated with a specific device object
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">//ParseConfig(fs *flag.FlagSet)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">InitDevicesWithConfig</span>(config <span style="color:#ff79c6">*</span>Config) {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 初始化devices map
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	devices = <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">string</span>]Devices)
</span></span><span style="display:flex;"><span>	DevicesToHandle = []<span style="color:#8be9fd">string</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 初始化nvidia设备
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	devices[nvidia.NvidiaGPUDevice] = nvidia.<span style="color:#50fa7b">InitNvidiaDevice</span>(config.NvidiaConfig)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 初始化cambricon设备
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	devices[cambricon.CambriconMLUDevice] = cambricon.<span style="color:#50fa7b">InitMLUDevice</span>(config.CambriconConfig)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 初始化hygon设备
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	devices[hygon.HygonDCUDevice] = hygon.<span style="color:#50fa7b">InitDCUDevice</span>(config.HygonConfig)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 初始化iluvatar设备
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	devices[iluvatar.IluvatarGPUDevice] = iluvatar.<span style="color:#50fa7b">InitIluvatarDevice</span>(config.IluvatarConfig)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 初始化mthreads设备
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	devices[mthreads.MthreadsGPUDevice] = mthreads.<span style="color:#50fa7b">InitMthreadsDevice</span>(config.MthreadsConfig)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 初始化metax设备
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	devices[metax.MetaxGPUDevice] = metax.<span style="color:#50fa7b">InitMetaxDevice</span>(config.MetaxConfig)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// CommonWord函数，看起来像是设备别名转换
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	DevicesToHandle = <span style="color:#8be9fd;font-style:italic">append</span>(DevicesToHandle, nvidia.NvidiaGPUCommonWord)
</span></span><span style="display:flex;"><span>	DevicesToHandle = <span style="color:#8be9fd;font-style:italic">append</span>(DevicesToHandle, cambricon.CambriconMLUCommonWord)
</span></span><span style="display:flex;"><span>	DevicesToHandle = <span style="color:#8be9fd;font-style:italic">append</span>(DevicesToHandle, hygon.HygonDCUCommonWord)
</span></span><span style="display:flex;"><span>	DevicesToHandle = <span style="color:#8be9fd;font-style:italic">append</span>(DevicesToHandle, iluvatar.IluvatarGPUCommonWord)
</span></span><span style="display:flex;"><span>	DevicesToHandle = <span style="color:#8be9fd;font-style:italic">append</span>(DevicesToHandle, mthreads.MthreadsGPUCommonWord)
</span></span><span style="display:flex;"><span>	DevicesToHandle = <span style="color:#8be9fd;font-style:italic">append</span>(DevicesToHandle, metax.MetaxGPUCommonWord)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> _, dev <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> ascend.<span style="color:#50fa7b">InitDevices</span>(config.VNPUs) {
</span></span><span style="display:flex;"><span>		devices[dev.<span style="color:#50fa7b">CommonWord</span>()] = dev
</span></span><span style="display:flex;"><span>		DevicesToHandle = <span style="color:#8be9fd;font-style:italic">append</span>(DevicesToHandle, dev.<span style="color:#50fa7b">CommonWord</span>())
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>hami也会在集群中运行一个hami-scheduler的调度器，pod调度时，如何区分是集群内原有的调度器还是hami-scheduler？<code>mutatingwebhook</code> hami-webhook会指定pod调度器为hami-scheduler</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#6272a4">// 创建一个webhook，用于处理pod调度请求
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">NewWebHook</span>() (<span style="color:#ff79c6">*</span>admission.Webhook, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>	logf.<span style="color:#50fa7b">SetLogger</span>(klog.<span style="color:#50fa7b">NewKlogr</span>())
</span></span><span style="display:flex;"><span>	schema <span style="color:#ff79c6">:=</span> runtime.<span style="color:#50fa7b">NewScheme</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> clientgoscheme.<span style="color:#50fa7b">AddToScheme</span>(schema); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, err
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	decoder <span style="color:#ff79c6">:=</span> admission.<span style="color:#50fa7b">NewDecoder</span>(schema)
</span></span><span style="display:flex;"><span>	wh <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&amp;</span>admission.Webhook{Handler: <span style="color:#ff79c6">&amp;</span>webhook{decoder: decoder}}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> wh, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// webhook结构体实现了Handler interface
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (h <span style="color:#ff79c6">*</span>webhook) <span style="color:#50fa7b">Handle</span>(_ context.Context, req admission.Request) admission.Response {
</span></span><span style="display:flex;"><span>	pod <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&amp;</span>corev1.Pod{}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 解码请求，获取pod信息
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	err <span style="color:#ff79c6">:=</span> h.decoder.<span style="color:#50fa7b">Decode</span>(req, pod)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		klog.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;Failed to decode request: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> admission.<span style="color:#50fa7b">Errored</span>(http.StatusBadRequest, err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 检查pod是否有容器
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">len</span>(pod.Spec.Containers) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>		klog.<span style="color:#50fa7b">Warningf</span>(template<span style="color:#ff79c6">+</span><span style="color:#f1fa8c">&#34; - Denying admission as pod has no containers&#34;</span>, req.Namespace, req.Name, req.UID)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> admission.<span style="color:#50fa7b">Denied</span>(<span style="color:#f1fa8c">&#34;pod has no containers&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	klog.<span style="color:#50fa7b">Infof</span>(template, req.Namespace, req.Name, req.UID)
</span></span><span style="display:flex;"><span>	hasResource <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">false</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> idx, ctr <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> pod.Spec.Containers {
</span></span><span style="display:flex;"><span>		c <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&amp;</span>pod.Spec.Containers[idx]
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 检查容器是否为特权容器
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">if</span> ctr.SecurityContext <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">if</span> ctr.SecurityContext.Privileged <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> <span style="color:#ff79c6">&amp;&amp;</span> <span style="color:#ff79c6">*</span>ctr.SecurityContext.Privileged {
</span></span><span style="display:flex;"><span>				klog.<span style="color:#50fa7b">Warningf</span>(template<span style="color:#ff79c6">+</span><span style="color:#f1fa8c">&#34; - Denying admission as container %s is privileged&#34;</span>, req.Namespace, req.Name, req.UID, c.Name)
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">continue</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 检查容器是否为vgpu容器
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">for</span> _, val <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> device.<span style="color:#50fa7b">GetDevices</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// 调用设备接口的MutateAdmission方法，检查容器是否为vgpu容器
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>			found, err <span style="color:#ff79c6">:=</span> val.<span style="color:#50fa7b">MutateAdmission</span>(c, pod)
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>				klog.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;validating pod failed:%s&#34;</span>, err.<span style="color:#50fa7b">Error</span>())
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">return</span> admission.<span style="color:#50fa7b">Errored</span>(http.StatusInternalServerError, err)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			hasResource = hasResource <span style="color:#ff79c6">||</span> found
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> !hasResource {
</span></span><span style="display:flex;"><span>		klog.<span style="color:#50fa7b">Infof</span>(template<span style="color:#ff79c6">+</span><span style="color:#f1fa8c">&#34; - Allowing admission for pod: no resource found&#34;</span>, req.Namespace, req.Name, req.UID)
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">//return admission.Allowed(&#34;no resource found&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	} <span style="color:#ff79c6">else</span> <span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">len</span>(config.SchedulerName) &gt; <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 如果配置了scheduler-name，则设置pod调度器为hami-scheduler
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		pod.Spec.SchedulerName = config.SchedulerName
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> pod.Spec.NodeName <span style="color:#ff79c6">!=</span> <span style="color:#f1fa8c">&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>			klog.<span style="color:#50fa7b">Infof</span>(template<span style="color:#ff79c6">+</span><span style="color:#f1fa8c">&#34; - Pod already has node assigned&#34;</span>, req.Namespace, req.Name, req.UID)
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">return</span> admission.<span style="color:#50fa7b">Denied</span>(<span style="color:#f1fa8c">&#34;pod has node assigned&#34;</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	marshaledPod, err <span style="color:#ff79c6">:=</span> json.<span style="color:#50fa7b">Marshal</span>(pod)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		klog.<span style="color:#50fa7b">Errorf</span>(template<span style="color:#ff79c6">+</span><span style="color:#f1fa8c">&#34; - Failed to marshal pod, error: %v&#34;</span>, req.Namespace, req.Name, req.UID, err)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> admission.<span style="color:#50fa7b">Errored</span>(http.StatusInternalServerError, err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> admission.<span style="color:#50fa7b">PatchResponseFromRaw</span>(req.Object.Raw, marshaledPod)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>vgpu pod的annotation是什么时候添加的？在scheduler filter阶段添加</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#6272a4">// filter核心函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (s <span style="color:#ff79c6">*</span>Scheduler) <span style="color:#50fa7b">Filter</span>(args extenderv1.ExtenderArgs) (<span style="color:#ff79c6">*</span>extenderv1.ExtenderFilterResult, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>	klog.<span style="color:#50fa7b">InfoS</span>(<span style="color:#f1fa8c">&#34;begin schedule filter&#34;</span>, <span style="color:#f1fa8c">&#34;pod&#34;</span>, args.Pod.Name, <span style="color:#f1fa8c">&#34;uuid&#34;</span>, args.Pod.UID, <span style="color:#f1fa8c">&#34;namespaces&#34;</span>, args.Pod.Namespace)
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// 用于统计Pod中容器的设备资源请求
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    nums <span style="color:#ff79c6">:=</span> k8sutil.<span style="color:#50fa7b">Resourcereqs</span>(args.Pod)
</span></span><span style="display:flex;"><span>	total <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> _, n <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> nums {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">for</span> _, k <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> n {
</span></span><span style="display:flex;"><span>			total <span style="color:#ff79c6">+=</span> <span style="color:#8be9fd;font-style:italic">int</span>(k.Nums)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> total <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 如果Pod中没有请求任何资源，则记录调度失败事件
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		klog.<span style="color:#50fa7b">V</span>(<span style="color:#bd93f9">1</span>).<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;pod %v not find resource&#34;</span>, args.Pod.Name)
</span></span><span style="display:flex;"><span>		s.<span style="color:#50fa7b">recordScheduleFilterResultEvent</span>(args.Pod, EventReasonFilteringFailed, []<span style="color:#8be9fd">string</span>{}, fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;does not request any resource&#34;</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>extenderv1.ExtenderFilterResult{
</span></span><span style="display:flex;"><span>			NodeNames:   args.NodeNames,
</span></span><span style="display:flex;"><span>			FailedNodes: <span style="color:#ff79c6">nil</span>,
</span></span><span style="display:flex;"><span>			Error:       <span style="color:#f1fa8c">&#34;&#34;</span>,
</span></span><span style="display:flex;"><span>		}, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	annos <span style="color:#ff79c6">:=</span> args.Pod.Annotations
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 从podManager维护的pods map中删除pod
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	s.<span style="color:#50fa7b">delPod</span>(args.Pod)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 调度器中的重要函数，用于获取节点资源使用情况
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	nodeUsage, failedNodes, err <span style="color:#ff79c6">:=</span> s.<span style="color:#50fa7b">getNodesUsage</span>(args.NodeNames, args.Pod)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		s.<span style="color:#50fa7b">recordScheduleFilterResultEvent</span>(args.Pod, EventReasonFilteringFailed, []<span style="color:#8be9fd">string</span>{}, err)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, err
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">len</span>(failedNodes) <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>		klog.<span style="color:#50fa7b">V</span>(<span style="color:#bd93f9">5</span>).<span style="color:#50fa7b">InfoS</span>(<span style="color:#f1fa8c">&#34;getNodesUsage failed nodes&#34;</span>, <span style="color:#f1fa8c">&#34;nodes&#34;</span>, failedNodes)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 计算节点得分的函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 1. 获取节点调度策略
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 2. 遍历所有可用节点
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 3. 计算每个节点的基础得分
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 4. 检查容器的设备需求适配性
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 5. 根据策略调整最终得分
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 6. 记录符合要求的节点得分
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 计算逻辑说明:
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 分别计算三个维度的使用率：设备、核心、显存
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 每个维度的得分是使用量与总量的比值
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 最终得分是三个维度得分之和乘以权重
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 适配性检查，检查节点上的设备是否能满足容器的资源请求；如果适配成功，会在score.Devices中记录设备的分配方案
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">//     fit, _ := fitInDevices(
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">//     node,           // 节点信息（包含该节点上的设备状态）
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">//     n,              // 容器的设备请求数量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">//     annos,          // Pod 的注解信息
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">//     task,           // 待调度的 Pod
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">//     &amp;score.Devices  // 输出参数：记录设备分配结果
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// )
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	nodeScores, err <span style="color:#ff79c6">:=</span> s.<span style="color:#50fa7b">calcScore</span>(nodeUsage, nums, annos, args.Pod, failedNodes)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		err <span style="color:#ff79c6">:=</span> fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;calcScore failed %v for pod %v&#34;</span>, err, args.Pod.Name)
</span></span><span style="display:flex;"><span>		s.<span style="color:#50fa7b">recordScheduleFilterResultEvent</span>(args.Pod, EventReasonFilteringFailed, []<span style="color:#8be9fd">string</span>{}, err)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, err
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 如果所有节点得分都不符合要求，则记录调度失败事件
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">len</span>((<span style="color:#ff79c6">*</span>nodeScores).NodeList) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>		klog.<span style="color:#50fa7b">V</span>(<span style="color:#bd93f9">4</span>).<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;All node scores do not meet for pod %v&#34;</span>, args.Pod.Name)
</span></span><span style="display:flex;"><span>		s.<span style="color:#50fa7b">recordScheduleFilterResultEvent</span>(args.Pod, EventReasonFilteringFailed, []<span style="color:#8be9fd">string</span>{}, fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;no available node, all node scores do not meet&#34;</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>extenderv1.ExtenderFilterResult{
</span></span><span style="display:flex;"><span>			FailedNodes: failedNodes,
</span></span><span style="display:flex;"><span>		}, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	klog.<span style="color:#50fa7b">V</span>(<span style="color:#bd93f9">4</span>).<span style="color:#50fa7b">Infoln</span>(<span style="color:#f1fa8c">&#34;nodeScores_len=&#34;</span>, <span style="color:#8be9fd;font-style:italic">len</span>((<span style="color:#ff79c6">*</span>nodeScores).NodeList))
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 对节点得分进行排序
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	sort.<span style="color:#50fa7b">Sort</span>(nodeScores)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 获取得分最高的节点
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	m <span style="color:#ff79c6">:=</span> (<span style="color:#ff79c6">*</span>nodeScores).NodeList[<span style="color:#8be9fd;font-style:italic">len</span>((<span style="color:#ff79c6">*</span>nodeScores).NodeList)<span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>]
</span></span><span style="display:flex;"><span>	klog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;schedule %v/%v to %v %v&#34;</span>, args.Pod.Namespace, args.Pod.Name, m.NodeID, m.Devices)
</span></span><span style="display:flex;"><span>	annotations <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">string</span>]<span style="color:#8be9fd">string</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 添加调度节点和调度时间到pod的annotation中
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	annotations[util.AssignedNodeAnnotations] = m.NodeID
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 添加调度时间到pod的annotation中
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	annotations[util.AssignedTimeAnnotations] = strconv.<span style="color:#50fa7b">FormatInt</span>(time.<span style="color:#50fa7b">Now</span>().<span style="color:#50fa7b">Unix</span>(), <span style="color:#bd93f9">10</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> _, val <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> device.<span style="color:#50fa7b">GetDevices</span>() {
</span></span><span style="display:flex;"><span>		val.<span style="color:#50fa7b">PatchAnnotations</span>(<span style="color:#ff79c6">&amp;</span>annotations, m.Devices)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//InRequestDevices := util.EncodePodDevices(util.InRequestDevices, m.devices)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">//supportDevices := util.EncodePodDevices(util.SupportDevices, m.devices)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">//maps.Copy(annotations, InRequestDevices)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">//maps.Copy(annotations, supportDevices)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 将pod添加到podManager维护的pods map中
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	s.<span style="color:#50fa7b">addPod</span>(args.Pod, m.NodeID, m.Devices)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 更新pod的annotation
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	err = util.<span style="color:#50fa7b">PatchPodAnnotations</span>(args.Pod, annotations)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		s.<span style="color:#50fa7b">recordScheduleFilterResultEvent</span>(args.Pod, EventReasonFilteringFailed, []<span style="color:#8be9fd">string</span>{}, err)
</span></span><span style="display:flex;"><span>		s.<span style="color:#50fa7b">delPod</span>(args.Pod)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, err
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 记录调度成功事件
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	s.<span style="color:#50fa7b">recordScheduleFilterResultEvent</span>(args.Pod, EventReasonFilteringSucceed, []<span style="color:#8be9fd">string</span>{m.NodeID}, <span style="color:#ff79c6">nil</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 返回调度结果
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	res <span style="color:#ff79c6">:=</span> extenderv1.ExtenderFilterResult{NodeNames: <span style="color:#ff79c6">&amp;</span>[]<span style="color:#8be9fd">string</span>{m.NodeID}}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>res, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>除了filter阶段，scheduler还有bind阶段，bind阶段是带有资源锁定的安全绑定过程，确保设备资源不会被重复分配，并在失败时能够正确清理资源。</p>
<p>hami-scheduler本身也是个controller，这个controller监听什么资源，然后reconcile处理什么逻辑?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">NewScheduler</span>() <span style="color:#ff79c6">*</span>Scheduler {
</span></span><span style="display:flex;"><span>	klog.<span style="color:#50fa7b">Info</span>(<span style="color:#f1fa8c">&#34;New Scheduler&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 初始化scheduler
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	s <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&amp;</span>Scheduler{
</span></span><span style="display:flex;"><span>		stopCh:       <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}),
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 维护一个缓存map，保存节点GPU设备使用情况
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		cachedstatus: <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">string</span>]<span style="color:#ff79c6">*</span>NodeUsage),
</span></span><span style="display:flex;"><span>		nodeNotify:   <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{}, <span style="color:#bd93f9">1</span>),
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 初始化nodeManager，维护一个nodes map，key为node_id，value为节点GPU设备的信息
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	s.nodeManager.<span style="color:#50fa7b">init</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 初始化podManager，维护一个pods map，key为pod_id，value为pod GPU设备信息
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	s.podManager.<span style="color:#50fa7b">init</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> s
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#6272a4">// 启动controller
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (s <span style="color:#ff79c6">*</span>Scheduler) <span style="color:#50fa7b">Start</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 初始化k8s clientSet
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	kubeClient, err <span style="color:#ff79c6">:=</span> k8sutil.<span style="color:#50fa7b">NewClient</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#50fa7b">check</span>(err)
</span></span><span style="display:flex;"><span>	s.kubeClient = kubeClient
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 初始化informerFactory，用于监听k8s资源变化   
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	informerFactory <span style="color:#ff79c6">:=</span> informers.<span style="color:#50fa7b">NewSharedInformerFactoryWithOptions</span>(s.kubeClient, time.Hour<span style="color:#ff79c6">*</span><span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 初始化podLister，用于获取pod信息
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	s.podLister = informerFactory.<span style="color:#50fa7b">Core</span>().<span style="color:#50fa7b">V1</span>().<span style="color:#50fa7b">Pods</span>().<span style="color:#50fa7b">Lister</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 初始化nodeLister，用于获取node信息
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	s.nodeLister = informerFactory.<span style="color:#50fa7b">Core</span>().<span style="color:#50fa7b">V1</span>().<span style="color:#50fa7b">Nodes</span>().<span style="color:#50fa7b">Lister</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 初始化podInformer，用于监听pod资源变化
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	informer <span style="color:#ff79c6">:=</span> informerFactory.<span style="color:#50fa7b">Core</span>().<span style="color:#50fa7b">V1</span>().<span style="color:#50fa7b">Pods</span>().<span style="color:#50fa7b">Informer</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 添加pod资源事件处理函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	informer.<span style="color:#50fa7b">AddEventHandler</span>(cache.ResourceEventHandlerFuncs{
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// onAddPod 处理 Pod 添加事件
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 1. 验证对象类型是否为 Pod
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 2. 检查 Pod 是否有指定节点的注解
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 3. 如果 Pod 处于终止状态则删除
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 4. 解析 Pod 的设备注解并添加到podManager维护的pods map中
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		AddFunc:    s.onAddPod,
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// onUpdatePod 处理 Pod 更新事件，走的还是onAddPod逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		UpdateFunc: s.onUpdatePod,
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// onDelPod 处理 Pod 删除事件，从podManager维护的pods map中删除pod
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		DeleteFunc: s.onDelPod,
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 初始化nodeInformer，用于监听node资源变化
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	informerFactory.<span style="color:#50fa7b">Core</span>().<span style="color:#50fa7b">V1</span>().<span style="color:#50fa7b">Nodes</span>().<span style="color:#50fa7b">Informer</span>().<span style="color:#50fa7b">AddEventHandler</span>(cache.ResourceEventHandlerFuncs{
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 这三个事件函数都是向nodeNotify channel发送一个空结构体信号
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 这个设计的关键点：
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 1. 通知机制：
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// nodeNotify是一个 channel，用于发送通知信号
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// struct{}{}是一个空结构体，在Go中常用作信号传递（因为它不占用内存）
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 2. 触发更新：
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 这些函数与RegisterFromNodeAnnotations()方法配合工作
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 当节点发生任何变化时，都会触发重新扫描和同步节点状态
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 3. 统一处理：
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 所有节点事件（添加/更新/删除）都触发相同的通知
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 实际的节点状态更新逻辑在接收通知的地方统一处理
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		AddFunc:    s.onAddNode,
</span></span><span style="display:flex;"><span>		UpdateFunc: s.onUpdateNode,
</span></span><span style="display:flex;"><span>		DeleteFunc: s.onDelNode,
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 启动informerFactory，开始监听k8s资源变化
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	informerFactory.<span style="color:#50fa7b">Start</span>(s.stopCh)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 等待informerFactory缓存同步完成
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	informerFactory.<span style="color:#50fa7b">WaitForCacheSync</span>(s.stopCh)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 添加其它的事件处理函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	s.<span style="color:#50fa7b">addAllEventHandlers</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="53-hami-device-plugin调试环境">5.3 hami-device-plugin调试环境</h2>
<p>远程gpu服务器上dlv启动hami-device-plugin，本地goland添加Go Remote Debugger指向<!-- raw HTML omitted -->:2346</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">NODE_NAME</span><span style="color:#ff79c6">=</span>vgpu <span style="color:#8be9fd;font-style:italic">NVIDIA_MIG_MONITOR_DEVICES</span><span style="color:#ff79c6">=</span>all <span style="color:#8be9fd;font-style:italic">HOOK_PATH</span><span style="color:#ff79c6">=</span>/usr/local <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>dlv <span style="color:#8be9fd;font-style:italic">exec</span> bin/nvidia-device-plugin --headless -l 0.0.0.0:2346 --api-version<span style="color:#ff79c6">=</span><span style="color:#bd93f9">2</span> -- <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>--config-file<span style="color:#ff79c6">=</span>/root/device-config.yaml <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>--mig-strategy<span style="color:#ff79c6">=</span>none <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>--disable-core-limit<span style="color:#ff79c6">=</span><span style="color:#8be9fd;font-style:italic">false</span> <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>-v<span style="color:#ff79c6">=</span><span style="color:#8be9fd;font-style:italic">false</span>
</span></span></code></pre></div><h2 id="54-hami-device-plugin核心逻辑">5.4 hami-device-plugin核心逻辑</h2>
<p>在了解hami nvidia-device-plugin前，需要了解下nvidia-runtime、GPU Operator、k8s device plugin等</p>
<ul>
<li>nvidia-runtime：对应Docker环境，安装nvidia-container-toolkit组件，docker配置使用nvidia-runtime，启动容器时增加<code>--gpu</code>参数；nvidia-container-toolkit根据<code>NVIDIA_VISIBLE_DEVICES</code>环境变量将GPU、驱动等相关文件挂载到容器里。</li>
<li>k8s device plugin：对应k8s环境，Nvidia提供的一种k8s GPU实现方案</li>
<li>GPU Operator：对应k8s环境，Nvidia提供的一种在Kubernetes环境中简化使用GPU的部署方案</li>
</ul>
<p>device-plugin原理：<a href="https://www.iceyao.com.cn/post/2020-11-11-device_plugin_learning_note/">device plugin学习笔记</a></p>
<p>实现一个device-plugin大致分为两部分：插件注册、kubelet调用插件(grpc调用，device-plugin做为grpc server启动)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#6272a4">// DevicePluginServer是device-plugin的server接口，定义了device-plugin需要实现的方法
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// DevicePluginServer is the server API for DevicePlugin service.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> DevicePluginServer <span style="color:#8be9fd;font-style:italic">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// GetDevicePluginOptions returns options to be communicated with Device
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// Manager
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#50fa7b">GetDevicePluginOptions</span>(context.Context, <span style="color:#ff79c6">*</span>Empty) (<span style="color:#ff79c6">*</span>DevicePluginOptions, <span style="color:#8be9fd">error</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// ListAndWatch returns a stream of List of Devices
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// Whenever a Device state change or a Device disappears, ListAndWatch
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// returns the new list
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#50fa7b">ListAndWatch</span>(<span style="color:#ff79c6">*</span>Empty, DevicePlugin_ListAndWatchServer) <span style="color:#8be9fd">error</span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// GetPreferredAllocation returns a preferred set of devices to allocate
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// from a list of available ones. The resulting preferred allocation is not
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// guaranteed to be the allocation ultimately performed by the
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// devicemanager. It is only designed to help the devicemanager make a more
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// informed allocation decision when possible.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#50fa7b">GetPreferredAllocation</span>(context.Context, <span style="color:#ff79c6">*</span>PreferredAllocationRequest) (<span style="color:#ff79c6">*</span>PreferredAllocationResponse, <span style="color:#8be9fd">error</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Allocate is called during container creation so that the Device
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// Plugin can run device specific operations and instruct Kubelet
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// of the steps to make the Device available in the container
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#50fa7b">Allocate</span>(context.Context, <span style="color:#ff79c6">*</span>AllocateRequest) (<span style="color:#ff79c6">*</span>AllocateResponse, <span style="color:#8be9fd">error</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// PreStartContainer is called, if indicated by Device Plugin during registeration phase,
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// before each container start. Device plugin can run device specific operations
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// such as resetting the device before making devices available to the container
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#50fa7b">PreStartContainer</span>(context.Context, <span style="color:#ff79c6">*</span>PreStartContainerRequest) (<span style="color:#ff79c6">*</span>PreStartContainerResponse, <span style="color:#8be9fd">error</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>虽然接口定义了5个方法，但是HAMi nvidia-device-plugin只实现了Allocate、ListAndWatch，外加一个Register方法，所以重点关注这三个实现</p>
<ul>
<li>Register：插件注册到kubelet</li>
<li>ListAndWatch：获取GPU设备信息，并上报给kubelet</li>
<li>Allocate：分配GPU设备给容器</li>
</ul>
<p>device-plugin启动函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">start</span>(c <span style="color:#ff79c6">*</span>cli.Context, flags []cli.Flag) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>	klog.<span style="color:#50fa7b">Info</span>(<span style="color:#f1fa8c">&#34;Starting FS watcher.&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 获取节点名称
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	util.NodeName = os.<span style="color:#50fa7b">Getenv</span>(util.NodeNameEnvName)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 创建一个文件系统监视器，用于监听kubelet设备插件路径的变化
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	watcher, err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">newFSWatcher</span>(kubeletdevicepluginv1beta1.DevicePluginPath)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;failed to create FS watcher: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">defer</span> watcher.<span style="color:#50fa7b">Close</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//device.InitDevices()
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">/*Loading config files*/</span>
</span></span><span style="display:flex;"><span>	klog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;Start working on node %s&#34;</span>, util.NodeName)
</span></span><span style="display:flex;"><span>	klog.<span style="color:#50fa7b">Info</span>(<span style="color:#f1fa8c">&#34;Starting OS watcher.&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 创建一个信号监听器，用于监听SIGHUP、SIGINT、SIGTERM、SIGQUIT信号
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	sigs <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">newOSWatcher</span>(syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">var</span> restarting <span style="color:#8be9fd">bool</span>
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">var</span> restartTimeout <span style="color:#ff79c6">&lt;-</span><span style="color:#8be9fd;font-style:italic">chan</span> time.Time
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">var</span> plugins []plugin.Interface
</span></span><span style="display:flex;"><span>restart:
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// If we are restarting, stop plugins from previous run.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">if</span> restarting {
</span></span><span style="display:flex;"><span>		err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">stopPlugins</span>(plugins)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">return</span> fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;error stopping plugins from previous run: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	klog.<span style="color:#50fa7b">Info</span>(<span style="color:#f1fa8c">&#34;Starting Plugins.&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 启动插件
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	plugins, restartPlugins, err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">startPlugins</span>(c, flags, restarting)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;error starting plugins: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> restartPlugins {
</span></span><span style="display:flex;"><span>		klog.<span style="color:#50fa7b">Info</span>(<span style="color:#f1fa8c">&#34;Failed to start one or more plugins. Retrying in 30s...&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 设置重启超时时间
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		restartTimeout = time.<span style="color:#50fa7b">After</span>(<span style="color:#bd93f9">30</span> <span style="color:#ff79c6">*</span> time.Second)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 设置重启标志
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	restarting = <span style="color:#ff79c6">true</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">// Start an infinite loop, waiting for several indicators to either log
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// some messages, trigger a restart of the plugins, or exit the program.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">select</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// If the restart timeout has expired, then restart the plugins
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span>restartTimeout:
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">goto</span> restart
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// Detect a kubelet restart by watching for a newly created
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#6272a4">// &#39;kubeletdevicepluginv1beta1.KubeletSocket&#39; file. When this occurs, restart this loop,
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#6272a4">// restarting all of the plugins in the process.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">case</span> event <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&lt;-</span>watcher.Events:
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// 监听kubelet设备插件路径的变化
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>			<span style="color:#ff79c6">if</span> event.Name <span style="color:#ff79c6">==</span> kubeletdevicepluginv1beta1.KubeletSocket <span style="color:#ff79c6">&amp;&amp;</span> event.Op<span style="color:#ff79c6">&amp;</span>fsnotify.Create <span style="color:#ff79c6">==</span> fsnotify.Create {
</span></span><span style="display:flex;"><span>				klog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;inotify: %s created, restarting.&#34;</span>, kubeletdevicepluginv1beta1.KubeletSocket)
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">goto</span> restart
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// Watch for any other fs errors and log them.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">case</span> err <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&lt;-</span>watcher.Errors:
</span></span><span style="display:flex;"><span>			klog.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;inotify: %s&#34;</span>, err)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// Watch for any signals from the OS. On SIGHUP, restart this loop,
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#6272a4">// restarting all of the plugins in the process. On all other
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#6272a4">// signals, exit the loop and exit the program.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">case</span> s <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&lt;-</span>sigs:
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">switch</span> s {
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">case</span> syscall.SIGHUP:
</span></span><span style="display:flex;"><span>				klog.<span style="color:#50fa7b">Info</span>(<span style="color:#f1fa8c">&#34;Received SIGHUP, restarting.&#34;</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">goto</span> restart
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">default</span>:
</span></span><span style="display:flex;"><span>				klog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;Received signal \&#34;%v\&#34;, shutting down.&#34;</span>, s)
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">goto</span> exit
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>exit:
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 停止插件
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	err = <span style="color:#50fa7b">stopPlugins</span>(plugins)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;error stopping plugins: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>启动函数除了启动插件外，还启动监视器来监听<code>/var/lib/kubelet/device-plugins/kubelet.sock</code>的变化，每次重启kubelet，kubelet.sock都会被重新创建，kubelet是通过map来存储device-plugin的注册信息，所以每次kubelet重启，device-plugin都需要重新注册（也跟着重启）</p>
<p>HAMi作为GPU管理框架，针对插件的启动、停止，自身抽象了一套接口：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#6272a4">// Interface defines the API for the plugin package
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> Interface <span style="color:#8be9fd;font-style:italic">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#50fa7b">Devices</span>() rm.Devices
</span></span><span style="display:flex;"><span>	<span style="color:#50fa7b">Start</span>() <span style="color:#8be9fd">error</span>
</span></span><span style="display:flex;"><span>	<span style="color:#50fa7b">Stop</span>() <span style="color:#8be9fd">error</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>插件Start实现包含：plugin.Serve、plugin.Register、plugin.WatchAndRegister</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#6272a4">// 在插件注册前，plugin.Serve会先启动插件grpc server
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// Serve starts the gRPC server of the device plugin.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (plugin <span style="color:#ff79c6">*</span>NvidiaDevicePlugin) <span style="color:#50fa7b">Serve</span>() <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 删除已存在的socket文件
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	os.<span style="color:#50fa7b">Remove</span>(plugin.socket)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 监听socket文件   
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	sock, err <span style="color:#ff79c6">:=</span> net.<span style="color:#50fa7b">Listen</span>(<span style="color:#f1fa8c">&#34;unix&#34;</span>, plugin.socket)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 注册设备插件的gRPC服务器
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	kubeletdevicepluginv1beta1.<span style="color:#50fa7b">RegisterDevicePluginServer</span>(plugin.server, plugin)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 启动grpc server
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">go</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>		lastCrashTime <span style="color:#ff79c6">:=</span> time.<span style="color:#50fa7b">Now</span>()
</span></span><span style="display:flex;"><span>		restartCount <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>			klog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;Starting GRPC server for &#39;%s&#39;&#34;</span>, plugin.rm.<span style="color:#50fa7b">Resource</span>())
</span></span><span style="display:flex;"><span>			err <span style="color:#ff79c6">:=</span> plugin.server.<span style="color:#50fa7b">Serve</span>(sock)
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">break</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			klog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;GRPC server for &#39;%s&#39; crashed with error: %v&#34;</span>, plugin.rm.<span style="color:#50fa7b">Resource</span>(), err)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#6272a4">// restart if it has not been too often
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>			<span style="color:#6272a4">// i.e. if server has crashed more than 5 times and it didn&#39;t last more than one hour each time
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>			<span style="color:#ff79c6">if</span> restartCount &gt; <span style="color:#bd93f9">5</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#6272a4">// quit
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>				klog.<span style="color:#50fa7b">Fatalf</span>(<span style="color:#f1fa8c">&#34;GRPC server for &#39;%s&#39; has repeatedly crashed recently. Quitting&#34;</span>, plugin.rm.<span style="color:#50fa7b">Resource</span>())
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			timeSinceLastCrash <span style="color:#ff79c6">:=</span> time.<span style="color:#50fa7b">Since</span>(lastCrashTime).<span style="color:#50fa7b">Seconds</span>()
</span></span><span style="display:flex;"><span>			lastCrashTime = time.<span style="color:#50fa7b">Now</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">if</span> timeSinceLastCrash &gt; <span style="color:#bd93f9">3600</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#6272a4">// it has been one hour since the last crash.. reset the count
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>				<span style="color:#6272a4">// to reflect on the frequency
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>				restartCount = <span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span>			} <span style="color:#ff79c6">else</span> {
</span></span><span style="display:flex;"><span>				restartCount<span style="color:#ff79c6">++</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 验证连接到device-plugin
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	conn, err <span style="color:#ff79c6">:=</span> plugin.<span style="color:#50fa7b">dial</span>(plugin.socket, <span style="color:#bd93f9">5</span><span style="color:#ff79c6">*</span>time.Second)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 关闭连接
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	conn.<span style="color:#50fa7b">Close</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>plugin.Register实现</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#6272a4">// Register registers the device plugin for the given resourceName with Kubelet.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (plugin <span style="color:#ff79c6">*</span>NvidiaDevicePlugin) <span style="color:#50fa7b">Register</span>() <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 连接到kubelet
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	conn, err <span style="color:#ff79c6">:=</span> plugin.<span style="color:#50fa7b">dial</span>(kubeletdevicepluginv1beta1.KubeletSocket, <span style="color:#bd93f9">5</span><span style="color:#ff79c6">*</span>time.Second)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">defer</span> conn.<span style="color:#50fa7b">Close</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 创建一个注册客户端
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	client <span style="color:#ff79c6">:=</span> kubeletdevicepluginv1beta1.<span style="color:#50fa7b">NewRegistrationClient</span>(conn)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 创建一个注册请求
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	reqt <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&amp;</span>kubeletdevicepluginv1beta1.RegisterRequest{
</span></span><span style="display:flex;"><span>		Version:      kubeletdevicepluginv1beta1.Version,
</span></span><span style="display:flex;"><span>		Endpoint:     path.<span style="color:#50fa7b">Base</span>(plugin.socket),
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 资源名称
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		ResourceName: <span style="color:#8be9fd;font-style:italic">string</span>(plugin.rm.<span style="color:#50fa7b">Resource</span>()),
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 设备插件选项
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		Options: <span style="color:#ff79c6">&amp;</span>kubeletdevicepluginv1beta1.DevicePluginOptions{
</span></span><span style="display:flex;"><span>			GetPreferredAllocationAvailable: <span style="color:#ff79c6">false</span>,
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 发送注册请求
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	_, err = client.<span style="color:#50fa7b">Register</span>(context.<span style="color:#50fa7b">Background</span>(), reqt)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>plugin.WatchAndRegister实现</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (plugin <span style="color:#ff79c6">*</span>NvidiaDevicePlugin) <span style="color:#50fa7b">WatchAndRegister</span>() {
</span></span><span style="display:flex;"><span>	klog.<span style="color:#50fa7b">Info</span>(<span style="color:#f1fa8c">&#34;Starting WatchAndRegister&#34;</span>)
</span></span><span style="display:flex;"><span>	errorSleepInterval <span style="color:#ff79c6">:=</span> time.Second <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">5</span>
</span></span><span style="display:flex;"><span>	successSleepInterval <span style="color:#ff79c6">:=</span> time.Second <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">30</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// annotation格式形如：
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// annotations:
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">//   hami.io/node-nvidia-register: &#39;GPU-a8243209-6b70-5b3d-de52-1aaafc1495fc,10,24576,100,NVIDIA-NVIDIA GeForce RTX 3090,0,true,0,:&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 通过nvml库获取GPU信息，并更新到Node的annotation上
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		err <span style="color:#ff79c6">:=</span> plugin.<span style="color:#50fa7b">RegistrInAnnotation</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>			klog.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;Failed to register annotation: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>			klog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;Retrying in %v seconds...&#34;</span>, errorSleepInterval)
</span></span><span style="display:flex;"><span>			time.<span style="color:#50fa7b">Sleep</span>(errorSleepInterval)
</span></span><span style="display:flex;"><span>		} <span style="color:#ff79c6">else</span> {
</span></span><span style="display:flex;"><span>			klog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;Successfully registered annotation. Next check in %v seconds...&#34;</span>, successSleepInterval)
</span></span><span style="display:flex;"><span>			time.<span style="color:#50fa7b">Sleep</span>(successSleepInterval)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里device-plugin是直接和k8s-apiserver交互，更新Node信息，<code>hami.io/node-nvidia-register</code>的annotation信息，后面hami-scheduler的<code>RegisterFromNodeAnnotations</code>函数会根据annotation信息进行调度</p>
<p>插件ListAndWatch实现（启动nvidi-device-plugin时进入）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#6272a4">// ListAndWatch lists devices and update that list according to the health status
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (plugin <span style="color:#ff79c6">*</span>NvidiaDevicePlugin) <span style="color:#50fa7b">ListAndWatch</span>(e <span style="color:#ff79c6">*</span>kubeletdevicepluginv1beta1.Empty, s kubeletdevicepluginv1beta1.DevicePlugin_ListAndWatchServer) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 发送GPU设备信息给kubelet
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	s.<span style="color:#50fa7b">Send</span>(<span style="color:#ff79c6">&amp;</span>kubeletdevicepluginv1beta1.ListAndWatchResponse{Devices: plugin.<span style="color:#50fa7b">apiDevices</span>()})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">select</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span>plugin.stop:
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">case</span> d <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&lt;-</span>plugin.health:
</span></span><span style="display:flex;"><span>			<span style="color:#6272a4">// FIXME: there is no way to recover from the Unhealthy state.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>			d.Health = kubeletdevicepluginv1beta1.Unhealthy
</span></span><span style="display:flex;"><span>			klog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;&#39;%s&#39; device marked unhealthy: %s&#34;</span>, plugin.rm.<span style="color:#50fa7b">Resource</span>(), d.ID)
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// 发送GPU设备信息给kubelet
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>			s.<span style="color:#50fa7b">Send</span>(<span style="color:#ff79c6">&amp;</span>kubeletdevicepluginv1beta1.ListAndWatchResponse{Devices: plugin.<span style="color:#50fa7b">apiDevices</span>()})
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// plugin.apiDevices最终会进入到GetPluginDevices函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// GetPluginDevices returns the plugin Devices from all devices in the Devices
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (ds Devices) <span style="color:#50fa7b">GetPluginDevices</span>(count <span style="color:#8be9fd">uint</span>) []<span style="color:#ff79c6">*</span>kubeletdevicepluginv1beta1.Device {
</span></span><span style="display:flex;"><span>	<span style="color:#8be9fd;font-style:italic">var</span> res []<span style="color:#ff79c6">*</span>kubeletdevicepluginv1beta1.Device
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 如果GPU不是MIG模式，则需要根据count，复制多个device，每个device的ID不同
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">if</span> !strings.<span style="color:#50fa7b">Contains</span>(ds.<span style="color:#50fa7b">GetIDs</span>()[<span style="color:#bd93f9">0</span>], <span style="color:#f1fa8c">&#34;MIG&#34;</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">for</span> _, dev <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> ds {
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// count取值来自--device-split-count参数，单卡同时运行多少个任务，一般推荐10以上
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>			<span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">uint</span>(<span style="color:#bd93f9">0</span>); i &lt; count; i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>				id <span style="color:#ff79c6">:=</span> fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;%v-%v&#34;</span>, dev.ID, i)
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// 根据count，复制多个device，每个device的ID不同
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>				res = <span style="color:#8be9fd;font-style:italic">append</span>(res, <span style="color:#ff79c6">&amp;</span>kubeletdevicepluginv1beta1.Device{
</span></span><span style="display:flex;"><span>					ID:       id,
</span></span><span style="display:flex;"><span>					Health:   dev.Health,
</span></span><span style="display:flex;"><span>					Topology: <span style="color:#ff79c6">nil</span>,
</span></span><span style="display:flex;"><span>				})
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	} <span style="color:#ff79c6">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 如果GPU是MIG模式，则直接返回所有GPU设备信息
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">for</span> _, d <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> ds {
</span></span><span style="display:flex;"><span>			res = <span style="color:#8be9fd;font-style:italic">append</span>(res, <span style="color:#ff79c6">&amp;</span>d.Device)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 返回GPU设备信息
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">return</span> res
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里<code>ds Devices</code>参数是从哪里传入的？在pluginManager初始化的时候，最终<code>b.buildGPUDeviceMap</code>传入的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#6272a4"># mig-strategies为none时</span>
</span></span><span style="display:flex;"><span>pluginManager.GetPlugins -&gt; rm.NewNVMLResourceManagers -&gt; NewDeviceMap -&gt; b.build
</span></span><span style="display:flex;"><span>-&gt; b.buildDeviceMapFromConfigResources -&gt; b.buildGPUDeviceMap
</span></span></code></pre></div><p>NVIDIA设备插件中用于构建GPU设备映射的函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#6272a4">// buildGPUDeviceMap builds a map of resource names to GPU devices
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (b <span style="color:#ff79c6">*</span>deviceMapBuilder) <span style="color:#50fa7b">buildGPUDeviceMap</span>() (DeviceMap, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 创建一个空的设备映射
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    devices <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(DeviceMap)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 遍历所有 GPU 设备
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    b.<span style="color:#50fa7b">VisitDevices</span>(<span style="color:#8be9fd;font-style:italic">func</span>(i <span style="color:#8be9fd">int</span>, gpu device.Device) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 获取 GPU 的产品名称
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        name, ret <span style="color:#ff79c6">:=</span> gpu.<span style="color:#50fa7b">GetName</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> ret <span style="color:#ff79c6">!=</span> nvml.SUCCESS {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;error getting product name for GPU: %v&#34;</span>, ret)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 检查 GPU 是否启用了 MIG (Multi-Instance GPU) 功能
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        migEnabled, err <span style="color:#ff79c6">:=</span> gpu.<span style="color:#50fa7b">IsMigEnabled</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;error checking if MIG is enabled on GPU: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 如果 GPU 启用了 MIG 且 MIG 策略不是 &#34;None&#34;，则跳过这个 GPU
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 因为 MIG 启用的 GPU 将由 buildMigDeviceMap 函数处理
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">if</span> migEnabled <span style="color:#ff79c6">&amp;&amp;</span> <span style="color:#ff79c6">*</span>b.config.Flags.MigStrategy <span style="color:#ff79c6">!=</span> spec.MigStrategyNone {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 遍历配置中定义的 GPU 资源
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">for</span> _, resource <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> b.config.Resources.GPUs {
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// 检查 GPU 名称是否匹配资源模式
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">if</span> resource.Pattern.<span style="color:#50fa7b">Matches</span>(name) {
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// 如果匹配，创建新的 GPU 设备条目
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                index, info <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">newGPUDevice</span>(i, gpu)
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">return</span> devices.<span style="color:#50fa7b">setEntry</span>(resource.Name, index, info)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 如果 GPU 名称不匹配任何资源模式，返回错误
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">return</span> fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;GPU name &#39;%v&#39; does not match any resource patterns&#34;</span>, name)
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> devices, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>插件Allocate实现（pod挂载GPU设备时进入）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#6272a4">// Allocate which return list of devices.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (plugin <span style="color:#ff79c6">*</span>NvidiaDevicePlugin) <span style="color:#50fa7b">Allocate</span>(ctx context.Context, reqs <span style="color:#ff79c6">*</span>kubeletdevicepluginv1beta1.AllocateRequest) (<span style="color:#ff79c6">*</span>kubeletdevicepluginv1beta1.AllocateResponse, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>	klog.<span style="color:#50fa7b">InfoS</span>(<span style="color:#f1fa8c">&#34;Allocate&#34;</span>, <span style="color:#f1fa8c">&#34;request&#34;</span>, reqs)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 创建一个AllocateResponse对象
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	responses <span style="color:#ff79c6">:=</span> kubeletdevicepluginv1beta1.AllocateResponse{}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 获取当前节点名称
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	nodename <span style="color:#ff79c6">:=</span> os.<span style="color:#50fa7b">Getenv</span>(util.NodeNameEnvName)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 获取当前挂载的pod
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	current, err <span style="color:#ff79c6">:=</span> util.<span style="color:#50fa7b">GetPendingPod</span>(ctx, nodename)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">//nodelock.ReleaseNodeLock(nodename, NodeLockNvidia, current)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>kubeletdevicepluginv1beta1.AllocateResponse{}, err
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	klog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;Allocate pod name is %s/%s, annotation is %+v&#34;</span>, current.Namespace, current.Name, current.Annotations)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 遍历pod的容器请求
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">for</span> idx, req <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> reqs.ContainerRequests {
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// If the devices being allocated are replicas, then (conditionally)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#6272a4">// error out if more than one resource is being allocated.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 如果请求的设备ID包含MIG，则需要检查是否启用了时间切片，并且请求的设备ID数量大于1
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">if</span> strings.<span style="color:#50fa7b">Contains</span>(req.DevicesIDs[<span style="color:#bd93f9">0</span>], <span style="color:#f1fa8c">&#34;MIG&#34;</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">if</span> plugin.config.Sharing.TimeSlicing.FailRequestsGreaterThanOne <span style="color:#ff79c6">&amp;&amp;</span> rm.<span style="color:#50fa7b">AnnotatedIDs</span>(req.DevicesIDs).<span style="color:#50fa7b">AnyHasAnnotations</span>() {
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">len</span>(req.DevicesIDs) &gt; <span style="color:#bd93f9">1</span> {
</span></span><span style="display:flex;"><span>					device.<span style="color:#50fa7b">PodAllocationFailed</span>(nodename, current, NodeLockNvidia)
</span></span><span style="display:flex;"><span>					<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;request for &#39;%v: %v&#39; too large: maximum request size for shared resources is 1&#34;</span>, plugin.rm.<span style="color:#50fa7b">Resource</span>(), <span style="color:#8be9fd;font-style:italic">len</span>(req.DevicesIDs))
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">for</span> _, id <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> req.DevicesIDs {
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">if</span> !plugin.rm.<span style="color:#50fa7b">Devices</span>().<span style="color:#50fa7b">Contains</span>(id) {
</span></span><span style="display:flex;"><span>					device.<span style="color:#50fa7b">PodAllocationFailed</span>(nodename, current, NodeLockNvidia)
</span></span><span style="display:flex;"><span>					<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;invalid allocation request for &#39;%s&#39;: unknown device: %s&#34;</span>, plugin.rm.<span style="color:#50fa7b">Resource</span>(), id)
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			response, err <span style="color:#ff79c6">:=</span> plugin.<span style="color:#50fa7b">getAllocateResponse</span>(req.DevicesIDs)
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>				device.<span style="color:#50fa7b">PodAllocationFailed</span>(nodename, current, NodeLockNvidia)
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;failed to get allocate response: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			responses.ContainerResponses = <span style="color:#8be9fd;font-style:italic">append</span>(responses.ContainerResponses, response)
</span></span><span style="display:flex;"><span>		} <span style="color:#ff79c6">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// 如果请求的设备ID不包含MIG，则需要获取下一个设备请求
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>			currentCtr, devreq, err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">GetNextDeviceRequest</span>(nvidia.NvidiaGPUDevice, <span style="color:#ff79c6">*</span>current)
</span></span><span style="display:flex;"><span>			klog.<span style="color:#50fa7b">Infoln</span>(<span style="color:#f1fa8c">&#34;deviceAllocateFromAnnotation=&#34;</span>, devreq)
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>				device.<span style="color:#50fa7b">PodAllocationFailed</span>(nodename, current, NodeLockNvidia)
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>kubeletdevicepluginv1beta1.AllocateResponse{}, err
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// 检查设备数量是否匹配
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>			<span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">len</span>(devreq) <span style="color:#ff79c6">!=</span> <span style="color:#8be9fd;font-style:italic">len</span>(reqs.ContainerRequests[idx].DevicesIDs) {
</span></span><span style="display:flex;"><span>				device.<span style="color:#50fa7b">PodAllocationFailed</span>(nodename, current, NodeLockNvidia)
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>kubeletdevicepluginv1beta1.AllocateResponse{}, errors.<span style="color:#50fa7b">New</span>(<span style="color:#f1fa8c">&#34;device number not matched&#34;</span>)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// 获取容器设备字符串数组，通过设置NVIDIA_VISIBLE_DEVICES环境变量，将GPU设备ID传递给容器
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>			response, err <span style="color:#ff79c6">:=</span> plugin.<span style="color:#50fa7b">getAllocateResponse</span>(plugin.<span style="color:#50fa7b">GetContainerDeviceStrArray</span>(devreq))
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;failed to get allocate response: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// 清除下一个设备类型从annotation
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>			err = <span style="color:#50fa7b">EraseNextDeviceTypeFromAnnotation</span>(nvidia.NvidiaGPUDevice, <span style="color:#ff79c6">*</span>current)
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>				device.<span style="color:#50fa7b">PodAllocationFailed</span>(nodename, current, NodeLockNvidia)
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>kubeletdevicepluginv1beta1.AllocateResponse{}, err
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// 如果操作模式不是MIG，则需要设置CUDA_DEVICE_MEMORY_LIMIT、CUDA_DEVICE_SM_LIMIT、CUDA_DEVICE_MEMORY_SHARED_CACHE、CUDA_OVERSUBSCRIBE、CUDA_DISABLE_CONTROL等环境变量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>			<span style="color:#ff79c6">if</span> plugin.operatingMode <span style="color:#ff79c6">!=</span> <span style="color:#f1fa8c">&#34;mig&#34;</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">for</span> i, dev <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> devreq {
</span></span><span style="display:flex;"><span>					limitKey <span style="color:#ff79c6">:=</span> fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;CUDA_DEVICE_MEMORY_LIMIT_%v&#34;</span>, i)
</span></span><span style="display:flex;"><span>					response.Envs[limitKey] = fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;%vm&#34;</span>, dev.Usedmem)
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				response.Envs[<span style="color:#f1fa8c">&#34;CUDA_DEVICE_SM_LIMIT&#34;</span>] = fmt.<span style="color:#50fa7b">Sprint</span>(devreq[<span style="color:#bd93f9">0</span>].Usedcores)
</span></span><span style="display:flex;"><span>				response.Envs[<span style="color:#f1fa8c">&#34;CUDA_DEVICE_MEMORY_SHARED_CACHE&#34;</span>] = fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;%s/vgpu/%v.cache&#34;</span>, hostHookPath, uuid.<span style="color:#50fa7b">New</span>().<span style="color:#50fa7b">String</span>())
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">if</span> plugin.schedulerConfig.DeviceMemoryScaling &gt; <span style="color:#bd93f9">1</span> {
</span></span><span style="display:flex;"><span>					response.Envs[<span style="color:#f1fa8c">&#34;CUDA_OVERSUBSCRIBE&#34;</span>] = <span style="color:#f1fa8c">&#34;true&#34;</span>
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">if</span> plugin.schedulerConfig.DisableCoreLimit {
</span></span><span style="display:flex;"><span>					response.Envs[util.CoreLimitSwitch] = <span style="color:#f1fa8c">&#34;disable&#34;</span>
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// 删除容器缓存目录
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>				cacheFileHostDirectory <span style="color:#ff79c6">:=</span> fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;%s/vgpu/containers/%s_%s&#34;</span>, hostHookPath, current.UID, currentCtr.Name)
</span></span><span style="display:flex;"><span>				os.<span style="color:#50fa7b">RemoveAll</span>(cacheFileHostDirectory)
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// 创建容器缓存目录
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>				os.<span style="color:#50fa7b">MkdirAll</span>(cacheFileHostDirectory, <span style="color:#bd93f9">0777</span>)
</span></span><span style="display:flex;"><span>				os.<span style="color:#50fa7b">Chmod</span>(cacheFileHostDirectory, <span style="color:#bd93f9">0777</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// 创建vgpulock目录
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>				os.<span style="color:#50fa7b">MkdirAll</span>(<span style="color:#f1fa8c">&#34;/tmp/vgpulock&#34;</span>, <span style="color:#bd93f9">0777</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// 设置vgpulock目录权限
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>				os.<span style="color:#50fa7b">Chmod</span>(<span style="color:#f1fa8c">&#34;/tmp/vgpulock&#34;</span>, <span style="color:#bd93f9">0777</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				response.Mounts = <span style="color:#8be9fd;font-style:italic">append</span>(response.Mounts,
</span></span><span style="display:flex;"><span>                    <span style="color:#6272a4">// 挂载libvgpu.so
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>					<span style="color:#ff79c6">&amp;</span>kubeletdevicepluginv1beta1.Mount{ContainerPath: fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;%s/vgpu/libvgpu.so&#34;</span>, hostHookPath),
</span></span><span style="display:flex;"><span>						HostPath: hostHookPath <span style="color:#ff79c6">+</span> <span style="color:#f1fa8c">&#34;/vgpu/libvgpu.so&#34;</span>,
</span></span><span style="display:flex;"><span>						ReadOnly: <span style="color:#ff79c6">true</span>},
</span></span><span style="display:flex;"><span>                    <span style="color:#6272a4">// 挂载容器缓存目录 
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>					<span style="color:#ff79c6">&amp;</span>kubeletdevicepluginv1beta1.Mount{ContainerPath: fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;%s/vgpu&#34;</span>, hostHookPath),
</span></span><span style="display:flex;"><span>						HostPath: cacheFileHostDirectory,
</span></span><span style="display:flex;"><span>						ReadOnly: <span style="color:#ff79c6">false</span>},
</span></span><span style="display:flex;"><span>                    <span style="color:#6272a4">// 挂载vgpulock目录
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>					<span style="color:#ff79c6">&amp;</span>kubeletdevicepluginv1beta1.Mount{ContainerPath: <span style="color:#f1fa8c">&#34;/tmp/vgpulock&#34;</span>,
</span></span><span style="display:flex;"><span>						HostPath: <span style="color:#f1fa8c">&#34;/tmp/vgpulock&#34;</span>,
</span></span><span style="display:flex;"><span>						ReadOnly: <span style="color:#ff79c6">false</span>},
</span></span><span style="display:flex;"><span>				)
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// 检查CUDA_DISABLE_CONTROL环境变量是否存在
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>				found <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">false</span>
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">for</span> _, val <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> currentCtr.Env {
</span></span><span style="display:flex;"><span>                    <span style="color:#6272a4">// 如果环境变量是CUDA_DISABLE_CONTROL，则跳过
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>					<span style="color:#ff79c6">if</span> strings.<span style="color:#50fa7b">Compare</span>(val.Name, <span style="color:#f1fa8c">&#34;CUDA_DISABLE_CONTROL&#34;</span>) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>						<span style="color:#6272a4">// if env existed but is set to false or can not be parsed, ignore
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                        <span style="color:#6272a4">// 将环境变量值转换为布尔值
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>						t, _ <span style="color:#ff79c6">:=</span> strconv.<span style="color:#50fa7b">ParseBool</span>(val.Value)
</span></span><span style="display:flex;"><span>                        <span style="color:#6272a4">// 如果环境变量值为false，则跳过
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>						<span style="color:#ff79c6">if</span> !t {
</span></span><span style="display:flex;"><span>							<span style="color:#ff79c6">continue</span>
</span></span><span style="display:flex;"><span>						}
</span></span><span style="display:flex;"><span>						<span style="color:#6272a4">// only env existed and set to true, we mark it &#34;found&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>						found = <span style="color:#ff79c6">true</span>
</span></span><span style="display:flex;"><span>						<span style="color:#ff79c6">break</span>
</span></span><span style="display:flex;"><span>					}
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// 如果CUDA_DISABLE_CONTROL环境变量不存在，则需要预加载链接库
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>				<span style="color:#ff79c6">if</span> !found {
</span></span><span style="display:flex;"><span>                    <span style="color:#6272a4">// 预加载链接库
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>					response.Mounts = <span style="color:#8be9fd;font-style:italic">append</span>(response.Mounts, <span style="color:#ff79c6">&amp;</span>kubeletdevicepluginv1beta1.Mount{ContainerPath: <span style="color:#f1fa8c">&#34;/etc/ld.so.preload&#34;</span>,
</span></span><span style="display:flex;"><span>						HostPath: hostHookPath <span style="color:#ff79c6">+</span> <span style="color:#f1fa8c">&#34;/vgpu/ld.so.preload&#34;</span>,
</span></span><span style="display:flex;"><span>						ReadOnly: <span style="color:#ff79c6">true</span>},
</span></span><span style="display:flex;"><span>					)
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// 检查vgpu license是否存在
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>				_, err = os.<span style="color:#50fa7b">Stat</span>(fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;%s/vgpu/license&#34;</span>, hostHookPath))
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#6272a4">// 挂载vgpu license
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>					response.Mounts = <span style="color:#8be9fd;font-style:italic">append</span>(response.Mounts, <span style="color:#ff79c6">&amp;</span>kubeletdevicepluginv1beta1.Mount{
</span></span><span style="display:flex;"><span>						ContainerPath: <span style="color:#f1fa8c">&#34;/tmp/license&#34;</span>,
</span></span><span style="display:flex;"><span>						HostPath:      fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;%s/vgpu/license&#34;</span>, hostHookPath),
</span></span><span style="display:flex;"><span>						ReadOnly:      <span style="color:#ff79c6">true</span>,
</span></span><span style="display:flex;"><span>					})
</span></span><span style="display:flex;"><span>                    <span style="color:#6272a4">// 挂载vgpuvalidator
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>					response.Mounts = <span style="color:#8be9fd;font-style:italic">append</span>(response.Mounts, <span style="color:#ff79c6">&amp;</span>kubeletdevicepluginv1beta1.Mount{
</span></span><span style="display:flex;"><span>						ContainerPath: <span style="color:#f1fa8c">&#34;/usr/bin/vgpuvalidator&#34;</span>,
</span></span><span style="display:flex;"><span>						HostPath:      fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;%s/vgpu/vgpuvalidator&#34;</span>, hostHookPath),
</span></span><span style="display:flex;"><span>						ReadOnly:      <span style="color:#ff79c6">true</span>,
</span></span><span style="display:flex;"><span>					})
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// 将响应添加到响应列表中
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>			responses.ContainerResponses = <span style="color:#8be9fd;font-style:italic">append</span>(responses.ContainerResponses, response)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	klog.<span style="color:#50fa7b">Infoln</span>(<span style="color:#f1fa8c">&#34;Allocate Response&#34;</span>, responses.ContainerResponses)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 标记pod分配成功
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	device.<span style="color:#50fa7b">PodAllocationTrySuccess</span>(nodename, nvidia.NvidiaGPUDevice, NodeLockNvidia, current)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>responses, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这些环境变量如何生效? cuda天生支持的？是HAMi-core能够解析自定义的<code>CUDA_xxx</code>环境变量，而<code>NVIDIA_VISIBLE_DEVICES</code>是nvidia-container-toolkit支持的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>NVIDIA_VISIBLE_DEVICES -&gt; GPU-a8243209-6b70-5b3d-de52-1aaafc1495fc
</span></span><span style="display:flex;"><span>CUDA_DEVICE_MEMORY_LIMIT_0 -&gt; 3000m
</span></span><span style="display:flex;"><span>CUDA_DEVICE_SM_LIMIT -&gt; <span style="color:#bd93f9">25</span>
</span></span><span style="display:flex;"><span>CUDA_DEVICE_MEMORY_SHARED_CACHE -&gt; /usr/local/vgpu/55202346-8648-4a49-9037-51b28eeb74ba.cache
</span></span></code></pre></div><p><code>NVIDIA_VISIBLE_DEVICES</code>环境变量在<code>nvidia-container-toolkit</code>源码中<code>nvidia-container-runtime</code>服务会根据它用于获取NVIDIA GPU设备。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">const</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// NVIDIA_VISIBLE_DEVICES变量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	EnvVarNvidiaVisibleDevices     = <span style="color:#f1fa8c">&#34;NVIDIA_VISIBLE_DEVICES&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (i CUDA) <span style="color:#50fa7b">VisibleDevicesFromEnvVar</span>() []<span style="color:#8be9fd">string</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> i.<span style="color:#50fa7b">DevicesFromEnvvars</span>(EnvVarNvidiaVisibleDevices).<span style="color:#50fa7b">List</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// DevicesFromEnvvars returns the devices requested by the image through environment variables
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (i CUDA) <span style="color:#50fa7b">DevicesFromEnvvars</span>(envVars <span style="color:#ff79c6">...</span><span style="color:#8be9fd">string</span>) VisibleDevices {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 从指定的环境变量中获取并合并所有设备信息
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd;font-style:italic">var</span> isSet <span style="color:#8be9fd">bool</span>                    <span style="color:#6272a4">// 标记是否有环境变量被设置
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd;font-style:italic">var</span> devices []<span style="color:#8be9fd">string</span>              <span style="color:#6272a4">// 存储所有找到的设备
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    requested <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">string</span>]<span style="color:#8be9fd">bool</span>) <span style="color:#6272a4">// 用于追踪请求的设备（避免重复）
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 遍历所有传入的环境变量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">for</span> _, envVar <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> envVars {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> devs, ok <span style="color:#ff79c6">:=</span> i.env[envVar]; ok {
</span></span><span style="display:flex;"><span>            isSet = <span style="color:#ff79c6">true</span>  <span style="color:#6272a4">// 标记找到了至少一个环境变量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#6272a4">// 解析环境变量值，按逗号分割
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">for</span> _, d <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> strings.<span style="color:#50fa7b">Split</span>(devs, <span style="color:#f1fa8c">&#34;,&#34;</span>) {
</span></span><span style="display:flex;"><span>                trimmed <span style="color:#ff79c6">:=</span> strings.<span style="color:#50fa7b">TrimSpace</span>(d)  <span style="color:#6272a4">// 去除空白字符
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">len</span>(trimmed) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">continue</span>  <span style="color:#6272a4">// 跳过空值
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                }
</span></span><span style="display:flex;"><span>                devices = <span style="color:#8be9fd;font-style:italic">append</span>(devices, trimmed)  <span style="color:#6272a4">// 添加到设备列表
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                requested[trimmed] = <span style="color:#ff79c6">true</span>           <span style="color:#6272a4">// 记录该设备已被请求
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 特殊情况处理：
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 1. 如果是传统镜像且没有设置环境变量：返回&#34;all&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> !isSet <span style="color:#ff79c6">&amp;&amp;</span> <span style="color:#8be9fd;font-style:italic">len</span>(devices) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">&amp;&amp;</span> i.<span style="color:#50fa7b">IsLegacy</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">NewVisibleDevices</span>(<span style="color:#f1fa8c">&#34;all&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 2. 如果没有找到设备或明确要求&#34;void&#34;：返回&#34;void&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">len</span>(devices) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">||</span> requested[<span style="color:#f1fa8c">&#34;void&#34;</span>] {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">NewVisibleDevices</span>(<span style="color:#f1fa8c">&#34;void&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 返回找到的所有设备
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">NewVisibleDevices</span>(devices<span style="color:#ff79c6">...</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="55-hami-core核心逻辑">5.5 hami-core核心逻辑</h2>
<p>libvgpu.so替换完为什么就生效？在Linux下预加载链接库有好几种方式，动态链接库加载优先级从高到低：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>LD_PRELOAD &gt; /etc/ld.so.preload &gt; LD_LIBRARY_PATH &gt; /etc/ld.so.conf.d/.conf &gt; 默认系统路径<span style="color:#ff79c6">(</span>/lib, /usr/lib<span style="color:#ff79c6">)</span>
</span></span></code></pre></div><p>通过/etc/ld.so.preload定义，确保libvgpu.so肯定会被加载。cuda api的请求如何劫持？这部分逻辑定义在<code>HAMi-core</code>实现里，HAMi-core主要实现是在libvgpu.c文件里，实现了一个虚拟GPU库的核心功能。</p>
<p>核心功能:</p>
<ul>
<li>实现了一个动态链接库劫持(hook)系统，用于拦截和重写CUDA和NVML相关的函数调用</li>
<li>管理GPU资源的虚拟化和分配</li>
<li>提供多进程间的GPU内存和利用率限制</li>
</ul>
<p>CUDA API主要分为三大类：</p>
<ul>
<li>CUDA Runtime API：最常用、最高层的API，以cuda为前缀，头文件cuda_runtime.h；用于普通CUDA应用开发</li>
<li>CUDA Driver API: 底层API，以cu为前缀，头文件：cuda.h；用于底层控制/动态加载</li>
<li>NVIDIA Management Library (NVML)：系统级管理API，以nvml为前缀，头文件：nvml.h；用于系统监控/管理</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Runtime API  --&gt;  Driver API  --&gt;  硬件
</span></span><span style="display:flex;"><span>    ^
</span></span><span style="display:flex;"><span>    |
</span></span><span style="display:flex;"><span>  NVML <span style="color:#ff79c6">(</span>系统管理<span style="color:#ff79c6">)</span>
</span></span></code></pre></div><p>hami-core劫持的请求实际上是cuda-runtime调用cuda-driver的请求</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>+--------------+          +-----------------+
</span></span><span style="display:flex;"><span>| Nvidia GPU  |          | CUDA Application|
</span></span><span style="display:flex;"><span>+------+-------+          +---------+-------+
</span></span><span style="display:flex;"><span>       ^                            |
</span></span><span style="display:flex;"><span>       |                            v
</span></span><span style="display:flex;"><span>+--------------+          +-----------------+
</span></span><span style="display:flex;"><span>|Nvidia Driver |          |   CUDA Library  |
</span></span><span style="display:flex;"><span>+------+-------+          +---------+-------+
</span></span><span style="display:flex;"><span>       ^                            |
</span></span><span style="display:flex;"><span>       |                            v
</span></span><span style="display:flex;"><span>+--------------+          +-----------------+
</span></span><span style="display:flex;"><span>| CUDA Driver  |          |  CUDA Runtime   |
</span></span><span style="display:flex;"><span>+--------------+          +---------+-------+
</span></span><span style="display:flex;"><span>       ^                            |
</span></span><span style="display:flex;"><span>       |                            v
</span></span><span style="display:flex;"><span>       |                  +-----------------+
</span></span><span style="display:flex;"><span>       +------------------+    HAMi-Core    |
</span></span><span style="display:flex;"><span>                          +-----------------+
</span></span></code></pre></div><p>劫持机制的关键点:</p>
<ul>
<li>符号拦截：
<ul>
<li>当程序调用CUDA或NVML函数时，底层会通过dlsym查找符号</li>
<li>通过重写dlsym，我们可以拦截这些查找请求</li>
<li>根据符号名称前缀（&ldquo;cu&rdquo; 或 &ldquo;nvml&rdquo;）来识别目标函数</li>
</ul>
</li>
<li>函数重写：
<ul>
<li>在劫持函数中，我们重写了CUDA和NVML函数的实现</li>
<li>这些重写后的函数会执行虚拟化或限制逻辑</li>
<li>例如，在CUDA函数中，我们可能模拟了GPU内存的虚拟化</li>
<li>在NVML函数中，我们可能模拟了GPU利用率的限制</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#6272a4">// dlsym函数的重写
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>FUNC_ATTR_VISIBLE <span style="color:#8be9fd">void</span><span style="color:#ff79c6">*</span> <span style="color:#50fa7b">dlsym</span>(<span style="color:#8be9fd">void</span><span style="color:#ff79c6">*</span> handle, <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span><span style="color:#ff79c6">*</span> symbol) {
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">pthread_once</span>(<span style="color:#ff79c6">&amp;</span>dlsym_init_flag, init_dlsym);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 1. 初始化真实的dlsym
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> (real_dlsym <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">NULL</span>) {
</span></span><span style="display:flex;"><span>        real_dlsym <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">dlvsym</span>(RTLD_NEXT, <span style="color:#f1fa8c">&#34;dlsym&#34;</span>, <span style="color:#f1fa8c">&#34;GLIBC_2.2.5&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> (real_dlsym <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">NULL</span>) {
</span></span><span style="display:flex;"><span>            real_dlsym <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">_dl_sym</span>(RTLD_NEXT, <span style="color:#f1fa8c">&#34;dlsym&#34;</span>, dlsym);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 2. 处理RTLD_NEXT的特殊情况
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> (handle <span style="color:#ff79c6">==</span> RTLD_NEXT) {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd">void</span> <span style="color:#ff79c6">*</span>h <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">real_dlsym</span>(RTLD_NEXT, symbol);
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 防止递归调用
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#8be9fd">int</span> tid <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">pthread_self</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#50fa7b">pthread_mutex_lock</span>(<span style="color:#ff79c6">&amp;</span>dlsym_lock);
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> (<span style="color:#50fa7b">check_dlmap</span>(tid, h)) {
</span></span><span style="display:flex;"><span>            h <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">NULL</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#50fa7b">pthread_mutex_unlock</span>(<span style="color:#ff79c6">&amp;</span>dlsym_lock);
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> h;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 3. 劫持CUDA函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> (symbol[<span style="color:#bd93f9">0</span>] <span style="color:#ff79c6">==</span> <span style="color:#f1fa8c">&#39;c&#39;</span> <span style="color:#ff79c6">&amp;&amp;</span> symbol[<span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">==</span> <span style="color:#f1fa8c">&#39;u&#39;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#50fa7b">pthread_once</span>(<span style="color:#ff79c6">&amp;</span>pre_cuinit_flag, preInit);
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 调用__dlsym_hook_section函数，返回劫持后的CUDA函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#8be9fd">void</span><span style="color:#ff79c6">*</span> f <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">__dlsym_hook_section</span>(handle, symbol);
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> (f <span style="color:#ff79c6">!=</span> <span style="color:#8be9fd;font-style:italic">NULL</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> f;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 4. 劫持NVML函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">#ifdef HOOK_NVML_ENABLE
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>    <span style="color:#ff79c6">if</span> (symbol[<span style="color:#bd93f9">0</span>] <span style="color:#ff79c6">==</span> <span style="color:#f1fa8c">&#39;n&#39;</span> <span style="color:#ff79c6">&amp;&amp;</span> symbol[<span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">==</span> <span style="color:#f1fa8c">&#39;v&#39;</span> <span style="color:#ff79c6">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        symbol[<span style="color:#bd93f9">2</span>] <span style="color:#ff79c6">==</span> <span style="color:#f1fa8c">&#39;m&#39;</span> <span style="color:#ff79c6">&amp;&amp;</span> symbol[<span style="color:#bd93f9">3</span>] <span style="color:#ff79c6">==</span> <span style="color:#f1fa8c">&#39;l&#39;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 调用__dlsym_hook_section_nvml函数，返回劫持后的NVML函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#8be9fd">void</span><span style="color:#ff79c6">*</span> f <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">__dlsym_hook_section_nvml</span>(handle, symbol);
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> (f <span style="color:#ff79c6">!=</span> <span style="color:#8be9fd;font-style:italic">NULL</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> f;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 5. 其他情况使用真实的 dlsym
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">real_dlsym</span>(handle, symbol);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// __dlsym_hook_section hook实现
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd">void</span><span style="color:#ff79c6">*</span> <span style="color:#50fa7b">__dlsym_hook_section</span>(<span style="color:#8be9fd">void</span><span style="color:#ff79c6">*</span> handle, <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span><span style="color:#ff79c6">*</span> symbol) {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 遍历所有需要劫持的CUDA函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">for</span> (it <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>; it <span style="color:#ff79c6">&lt;</span> CUDA_ENTRY_END; it<span style="color:#ff79c6">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> (<span style="color:#50fa7b">strcmp</span>(cuda_library_entry[it].name, symbol) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> (cuda_library_entry[it].fn_ptr <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">NULL</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">NULL</span>;
</span></span><span style="display:flex;"><span>            } <span style="color:#ff79c6">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 使用宏定义批量劫持函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">DLSYM_HOOK_FUNC</span>(cuCtxGetDevice);
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">DLSYM_HOOK_FUNC</span>(cuCtxCreate);
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// ... 更多函数劫持
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// __dlsym_hook_section_nvml hook实现
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd">void</span><span style="color:#ff79c6">*</span> <span style="color:#50fa7b">__dlsym_hook_section_nvml</span>(<span style="color:#8be9fd">void</span><span style="color:#ff79c6">*</span> handle, <span style="color:#ff79c6">const</span> <span style="color:#8be9fd">char</span><span style="color:#ff79c6">*</span> symbol) {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 使用宏定义批量劫持函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">DLSYM_HOOK_FUNC</span>(nvmlInit);
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">/** nvmlShutdown */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">DLSYM_HOOK_FUNC</span>(nvmlShutdown);
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">/** nvmlErrorString */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">DLSYM_HOOK_FUNC</span>(nvmlErrorString);
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">/** nvmlDeviceGetHandleByIndex */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">DLSYM_HOOK_FUNC</span>(nvmlDeviceGetHandleByIndex);
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// ... 更多函数劫持
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">NULL</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>DLSYM_HOOK_FUNC 是一个宏，用于动态符号链接钩子函数，它的基本工作流程是：</p>
<ul>
<li>检查请求的符号名称是否匹配目标函数</li>
<li>如果匹配，返回一个钩子函数的指针，而不是原始函数</li>
<li>这允许程序在原始函数被调用之前或之后插入自定义代码</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#6272a4">// DLSYM_HOOK_FUNC宏定义，用于批量劫持函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">#if defined(DLSYM_HOOK_DEBUG)
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#define DLSYM_HOOK_FUNC(f)                                       \
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">    if (0 == strcmp(symbol, #f)) {                               \
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">        LOG_DEBUG(&#34;Detect dlsym for %s\n&#34;, #f);                     \
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">        return (void*) f; }                                      \
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#else 
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#define DLSYM_HOOK_FUNC(f)                                       \
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">    if (0 == strcmp(symbol, #f)) {                               \
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">        return (void*) f; }                                      \
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#endif   
</span></span></span></code></pre></div><p>这种劫持机制的优点是：</p>
<ol>
<li>对应用程序透明，不需要修改源代码</li>
<li>可以完全控制 GPU 资源的分配和使用</li>
<li>可以实现细粒度的资源管理和监控</li>
<li>支持动态调整和策略更新</li>
</ol>
<p>缺点是：</p>
<ol>
<li>需要维护完整的函数映射表</li>
<li>版本更新时需要同步更新劫持函数</li>
<li>需要处理复杂的线程安全和递归问题</li>
<li>可能影响性能（额外的函数调用开销）</li>
</ol>
<p>K8s yaml文件中的显存限制和gpu core限制，hami-core具体是如何处理的?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>        resources:
</span></span><span style="display:flex;"><span>          limits:
</span></span><span style="display:flex;"><span>            nvidia.com/gpumem: <span style="color:#bd93f9">3000</span>
</span></span><span style="display:flex;"><span>            nvidia.com/gpucores: <span style="color:#bd93f9">25</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>hami -&gt; nvidia.com/gpumem -&gt; <span style="color:#8be9fd;font-style:italic">CUDA_DEVICE_MEMORY_LIMIT_0</span><span style="color:#ff79c6">=</span>3000m -&gt; hami-core<span style="color:#ff79c6">(</span>libvgpu.so<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span>hami -&gt; nvidia.com/gpucores -&gt; <span style="color:#8be9fd;font-style:italic">CUDA_DEVICE_SM_LIMIT</span><span style="color:#ff79c6">=</span><span style="color:#bd93f9">25</span> -&gt; hami-core<span style="color:#ff79c6">(</span>libvgpu.so<span style="color:#ff79c6">)</span>
</span></span></code></pre></div><p>通过一系列转化后，在hami的源码中可以找到，最终传给hami-core的是这两个环境变量<code>CUDA_DEVICE_MEMORY_LIMIT_0</code>和<code>CUDA_DEVICE_SM_LIMIT</code>,<code>CUDA_DEVICE_MEMORY_LIMIT_i</code>是动态环境变量. 在<code>HAMi-core/src/multiprocess/multiprocess_memory_limit.c</code>源码中有对应的处理逻辑，在进程初始化时通过ensure_initialized()调用,用于初始化共享内存区域</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ensure_initialized -&gt; initialized -&gt; try_create_shrreg -&gt; do_init_device_memory_limits<span style="color:#ff79c6">(</span>显存限制<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span>                                               ｜
</span></span><span style="display:flex;"><span>                                      do_init_device_sm_limits<span style="color:#ff79c6">(</span>core利用率限制<span style="color:#ff79c6">)</span>       
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#6272a4">// 共享区域信息
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">typedef</span> <span style="color:#ff79c6">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">int32_t</span> initialized_flag;  <span style="color:#6272a4">// 初始化标志
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">uint32_t</span> major_version;    <span style="color:#6272a4">// 主版本号
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">uint32_t</span> minor_version;    <span style="color:#6272a4">// 次版本号
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">sem_t</span> sem;                 <span style="color:#6272a4">// 信号量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">uint64_t</span> limit[CUDA_DEVICE_MAX_COUNT];     <span style="color:#6272a4">// 设备内存限制
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">uint64_t</span> sm_limit[CUDA_DEVICE_MAX_COUNT];  <span style="color:#6272a4">// SM限制
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">shrreg_proc_slot_t</span> procs[SHARED_REGION_MAX_PROCESS_NUM]; <span style="color:#6272a4">// 进程信息数组
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> proc_num;             <span style="color:#6272a4">// 进程数量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> utilization_switch;   <span style="color:#6272a4">// 利用率开关
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> recent_kernel;        <span style="color:#6272a4">// 最近kernel信息
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> priority;            <span style="color:#6272a4">// 优先级
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>} <span style="color:#8be9fd">shared_region_t</span>;
</span></span></code></pre></div><p>do_init_device_memory_limits(region-&gt;limit, CUDA_DEVICE_MAX_COUNT); 往共享内存区域region写入显存限制，为了方便验证测试，直接设置这两个环境变量，通过<code>nvidia-smi</code>查看，设置LIBCUDA_LOG_LEVEL=4，可以查看hami-core打印的 debug日志，比如进到哪个cuda、nvml函数了</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#6272a4"># 为挂载的设备添加1GiB内存限制并将最大SM利用率设置为50%</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">export</span> <span style="color:#8be9fd;font-style:italic">LD_PRELOAD</span><span style="color:#ff79c6">=</span>./libvgpu.so
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">export</span> <span style="color:#8be9fd;font-style:italic">CUDA_DEVICE_MEMORY_LIMIT</span><span style="color:#ff79c6">=</span>1g
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">export</span> <span style="color:#8be9fd;font-style:italic">CUDA_DEVICE_SM_LIMIT</span><span style="color:#ff79c6">=</span><span style="color:#bd93f9">50</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#ff79c6">(</span>base<span style="color:#ff79c6">)</span> root@vgpu:/libvgpu/build# <span style="color:#8be9fd;font-style:italic">LIBCUDA_LOG_LEVEL</span><span style="color:#ff79c6">=</span><span style="color:#bd93f9">4</span> nvidia-smi
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:libvgpu.c:56<span style="color:#ff79c6">)]</span>: init_dlsym
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:libvgpu.c:79<span style="color:#ff79c6">)]</span>: into dlsym nvmlInitWithFlags
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:hook.c:442<span style="color:#ff79c6">)]</span>: nvmlInitWithFlags
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:hook.c:296<span style="color:#ff79c6">)]</span>: loading nvmlInit:0
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:multiprocess_memory_limit.c:777<span style="color:#ff79c6">)]</span>: shrreg created
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:device.c:94<span style="color:#ff79c6">)]</span>: into cuDriverGetVersion__
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:libvgpu.c:79<span style="color:#ff79c6">)]</span>: into dlsym cuDriverGetVersion
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:device.c:99<span style="color:#ff79c6">)]</span>: Hijacking cuDriverGetVersion
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Info<span style="color:#ff79c6">(</span>17398:140432464095040:device.c:102<span style="color:#ff79c6">)]</span>: driver <span style="color:#8be9fd;font-style:italic">version</span><span style="color:#ff79c6">=</span><span style="color:#bd93f9">12040</span>
</span></span><span style="display:flex;"><span>Mon Jan <span style="color:#bd93f9">20</span> 16:55:21 <span style="color:#bd93f9">2025</span>
</span></span><span style="display:flex;"><span>+-----------------------------------------------------------------------------------------+
</span></span><span style="display:flex;"><span>| NVIDIA-SMI 550.135                Driver Version: 550.135        CUDA Version: 12.4     |
</span></span><span style="display:flex;"><span>|-----------------------------------------+------------------------+----------------------+
</span></span><span style="display:flex;"><span>| GPU  Name                 Persistence-M | Bus-Id          Disp.A | Volatile Uncorr. ECC |
</span></span><span style="display:flex;"><span>| Fan  Temp   Perf          Pwr:Usage/Cap |           Memory-Usage | GPU-Util  Compute M. |
</span></span><span style="display:flex;"><span>|                                         |                        |               MIG M. |
</span></span><span style="display:flex;"><span>|<span style="color:#ff79c6">=========================================</span>+<span style="color:#ff79c6">========================</span>+<span style="color:#ff79c6">======================</span>|
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:libvgpu.c:79<span style="color:#ff79c6">)]</span>: into dlsym nvmlDeviceGetIndex
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:libvgpu.c:79<span style="color:#ff79c6">)]</span>: into dlsym nvmlDeviceGetMemoryInfo_v2
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:hook.c:321<span style="color:#ff79c6">)]</span>: into nvmlDeviceGetMemoryInfo
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:hook.c:328<span style="color:#ff79c6">)]</span>: Hijacking nvmlDeviceGetMemoryInfo_v2
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:hook.c:330<span style="color:#ff79c6">)]</span>: <span style="color:#8be9fd;font-style:italic">origin_free</span><span style="color:#ff79c6">=</span><span style="color:#bd93f9">25769803776</span> <span style="color:#8be9fd;font-style:italic">total</span><span style="color:#ff79c6">=</span><span style="color:#bd93f9">4192904278781722664</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:hook.c:268<span style="color:#ff79c6">)]</span>: Hijacking nvmlDeviceGetIndex
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:hook.c:437<span style="color:#ff79c6">)]</span>: Hijacking nvmlDeviceGetCount_v2
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Info<span style="color:#ff79c6">(</span>17398:140432464095040:multiprocess_memory_limit.c:289<span style="color:#ff79c6">)]</span>: get_gpu_memory_usage <span style="color:#8be9fd;font-style:italic">dev</span><span style="color:#ff79c6">=</span><span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Info<span style="color:#ff79c6">(</span>17398:140432464095040:multiprocess_memory_limit.c:296<span style="color:#ff79c6">)]</span>: <span style="color:#8be9fd;font-style:italic">dev</span><span style="color:#ff79c6">=</span><span style="color:#bd93f9">0</span> <span style="color:#8be9fd;font-style:italic">pid</span><span style="color:#ff79c6">=</span><span style="color:#bd93f9">17398</span> host <span style="color:#8be9fd;font-style:italic">pid</span><span style="color:#ff79c6">=</span><span style="color:#bd93f9">0</span> <span style="color:#8be9fd;font-style:italic">i</span><span style="color:#ff79c6">=</span><span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:multiprocess_memory_limit.c:883<span style="color:#ff79c6">)]</span>: get_current_device_memory_usage:tick<span style="color:#ff79c6">=</span><span style="color:#bd93f9">15</span> <span style="color:#8be9fd;font-style:italic">result</span><span style="color:#ff79c6">=</span><span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:multiprocess_memory_limit.c:275<span style="color:#ff79c6">)]</span>: get_gpu_memory_monitor <span style="color:#8be9fd;font-style:italic">dev</span><span style="color:#ff79c6">=</span><span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:multiprocess_memory_limit.c:281<span style="color:#ff79c6">)]</span>: <span style="color:#8be9fd;font-style:italic">dev</span><span style="color:#ff79c6">=</span><span style="color:#bd93f9">0</span> <span style="color:#8be9fd;font-style:italic">i</span><span style="color:#ff79c6">=</span>0,0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:hook.c:338<span style="color:#ff79c6">)]</span>: <span style="color:#8be9fd;font-style:italic">usage</span><span style="color:#ff79c6">=</span><span style="color:#bd93f9">0</span> <span style="color:#8be9fd;font-style:italic">limit</span><span style="color:#ff79c6">=</span><span style="color:#bd93f9">1073741824</span> <span style="color:#8be9fd;font-style:italic">monitor</span><span style="color:#ff79c6">=</span><span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:libvgpu.c:79<span style="color:#ff79c6">)]</span>: into dlsym nvmlDeviceGetUtilizationRates
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:nvml_entry.c:753<span style="color:#ff79c6">)]</span>: Hijacking nvmlDeviceGetUtilizationRates
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:libvgpu.c:79<span style="color:#ff79c6">)]</span>: into dlsym nvmlDeviceGetComputeMode
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:nvml_entry.c:220<span style="color:#ff79c6">)]</span>: Hijacking nvmlDeviceGetComputeMode
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:libvgpu.c:79<span style="color:#ff79c6">)]</span>: into dlsym nvmlDeviceGetMigMode
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:nvml_entry.c:1445<span style="color:#ff79c6">)]</span>: Hijacking nvmlDeviceGetMigMode
</span></span><span style="display:flex;"><span>|   <span style="color:#bd93f9">0</span>  NVIDIA GeForce RTX <span style="color:#bd93f9">3090</span>        Off |   00000000:00:05.0 Off |                  N/A |
</span></span><span style="display:flex;"><span>|  0%   27C    P8              7W /  370W |       0MiB /   1024MiB |      0%      Default |
</span></span><span style="display:flex;"><span>|                                         |                        |                  N/A |
</span></span><span style="display:flex;"><span>+-----------------------------------------+------------------------+----------------------+
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:nvml_entry.c:1445<span style="color:#ff79c6">)]</span>: Hijacking nvmlDeviceGetMigMode
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>+-----------------------------------------------------------------------------------------+
</span></span><span style="display:flex;"><span>| Processes:                                                                              |
</span></span><span style="display:flex;"><span>|  GPU   GI   CI        PID   Type   Process name                              GPU Memory |
</span></span><span style="display:flex;"><span>|        ID   ID                                                               Usage      |
</span></span><span style="display:flex;"><span>|<span style="color:#ff79c6">=========================================================================================</span>|
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:libvgpu.c:79<span style="color:#ff79c6">)]</span>: into dlsym nvmlDeviceGetVirtualizationMode
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:nvml_entry.c:798<span style="color:#ff79c6">)]</span>: Hijacking nvmlDeviceGetVirtualizationMode
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:libvgpu.c:79<span style="color:#ff79c6">)]</span>: into dlsym nvmlDeviceGetMaxMigDeviceCount
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:nvml_entry.c:1422<span style="color:#ff79c6">)]</span>: Hijacking nvmlDeviceGetMaxMigDeviceCount
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:libvgpu.c:79<span style="color:#ff79c6">)]</span>: into dlsym nvmlDeviceIsMigDeviceHandle
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:nvml_entry.c:1467<span style="color:#ff79c6">)]</span>: Hijacking nvmlDeviceIsMigDeviceHandle
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:hook.c:268<span style="color:#ff79c6">)]</span>: Hijacking nvmlDeviceGetIndex
</span></span><span style="display:flex;"><span>|  No running processes found                                                             |
</span></span><span style="display:flex;"><span>+-----------------------------------------------------------------------------------------+
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:libvgpu.c:79<span style="color:#ff79c6">)]</span>: into dlsym nvmlShutdown
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Debug<span style="color:#ff79c6">(</span>17398:140432464095040:nvml_entry.c:32<span style="color:#ff79c6">)]</span>: Hijacking nvmlShutdown
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Msg<span style="color:#ff79c6">(</span>17398:140432464095040:multiprocess_memory_limit.c:497<span style="color:#ff79c6">)]</span>: Calling <span style="color:#8be9fd;font-style:italic">exit</span> handler <span style="color:#bd93f9">17398</span>
</span></span></code></pre></div><p>从输出的debug日志<code>[HAMI-core Debug(17398:140432464095040:hook.c:328)]: Hijacking nvmlDeviceGetMemoryInfo_v2</code>来看，nvmlDeviceGetMemoryInfo_v2函数被劫持了. 使用gdb调试进入到<code>nvmlDeviceGetMemoryInfo_v2</code>函数，gdb调试设置参考<a href="#56-hami-core-gdb%E8%B0%83%E8%AF%95">5.6 hami-core gdb调试</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#ff79c6">(</span>base<span style="color:#ff79c6">)</span> root@vgpu:/libvgpu/build# gdb nvidia-smi
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">(</span>No debugging symbols found in nvidia-smi<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">(</span>gdb<span style="color:#ff79c6">)</span> b nvmlDeviceGetMemoryInfo_v2
</span></span><span style="display:flex;"><span>Function <span style="color:#f1fa8c">&#34;nvmlDeviceGetMemoryInfo_v2&#34;</span> not defined.
</span></span><span style="display:flex;"><span>Make breakpoint pending on future shared library load? <span style="color:#ff79c6">(</span>y or <span style="color:#ff79c6">[</span>n<span style="color:#ff79c6">])</span> y
</span></span><span style="display:flex;"><span>Breakpoint <span style="color:#bd93f9">1</span> <span style="color:#ff79c6">(</span>nvmlDeviceGetMemoryInfo_v2<span style="color:#ff79c6">)</span> pending.
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">(</span>gdb<span style="color:#ff79c6">)</span> r
</span></span><span style="display:flex;"><span>Starting program: /usr/bin/nvidia-smi
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>Thread debugging using libthread_db enabled<span style="color:#ff79c6">]</span>
</span></span><span style="display:flex;"><span>Using host libthread_db library <span style="color:#f1fa8c">&#34;/lib/x86_64-linux-gnu/libthread_db.so.1&#34;</span>.
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>HAMI-core Msg<span style="color:#ff79c6">(</span>24206:140737321068352:libvgpu.c:836<span style="color:#ff79c6">)]</span>: Initializing.....
</span></span><span style="display:flex;"><span>Mon Jan <span style="color:#bd93f9">20</span> 17:10:36 <span style="color:#bd93f9">2025</span>
</span></span><span style="display:flex;"><span>+-----------------------------------------------------------------------------------------+
</span></span><span style="display:flex;"><span>| NVIDIA-SMI 550.135                Driver Version: 550.135        CUDA Version: 12.4     |
</span></span><span style="display:flex;"><span>|-----------------------------------------+------------------------+----------------------+
</span></span><span style="display:flex;"><span>| GPU  Name                 Persistence-M | Bus-Id          Disp.A | Volatile Uncorr. ECC |
</span></span><span style="display:flex;"><span>| Fan  Temp   Perf          Pwr:Usage/Cap |           Memory-Usage | GPU-Util  Compute M. |
</span></span><span style="display:flex;"><span>|                                         |                        |               MIG M. |
</span></span><span style="display:flex;"><span>|<span style="color:#ff79c6">=========================================</span>+<span style="color:#ff79c6">========================</span>+<span style="color:#ff79c6">======================</span>|
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Breakpoint 1, nvmlDeviceGetMemoryInfo_v2 <span style="color:#ff79c6">(</span><span style="color:#8be9fd;font-style:italic">device</span><span style="color:#ff79c6">=</span>0x7ffff51fbf38, <span style="color:#8be9fd;font-style:italic">memory</span><span style="color:#ff79c6">=</span>0x7fffffffd730<span style="color:#ff79c6">)</span> at /libvgpu/src/nvml/hook.c:375
</span></span><span style="display:flex;"><span>375	    <span style="color:#ff79c6">return</span> _nvmlDeviceGetMemoryInfo<span style="color:#ff79c6">(</span>device,memory,2<span style="color:#ff79c6">)</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">(</span>gdb<span style="color:#ff79c6">)</span> info sharedlibrary
</span></span><span style="display:flex;"><span>From                To                  Syms Read   Shared Object Library
</span></span><span style="display:flex;"><span>0x00007ffff7fc5090  0x00007ffff7fee315  Yes         /lib64/ld-linux-x86-64.so.2
</span></span><span style="display:flex;"><span>0x00007ffff7f73850  0x00007ffff7fa1050  Yes         ./libvgpu.so
</span></span><span style="display:flex;"><span>0x00007ffff7f62040  0x00007ffff7f62105  Yes         /lib/x86_64-linux-gnu/libpthread.so.0
</span></span><span style="display:flex;"><span>0x00007ffff7e883a0  0x00007ffff7f038c8  Yes         /lib/x86_64-linux-gnu/libm.so.6
</span></span><span style="display:flex;"><span>0x00007ffff7e76040  0x00007ffff7e76105  Yes         /lib/x86_64-linux-gnu/libdl.so.2
</span></span><span style="display:flex;"><span>0x00007ffff7c74700  0x00007ffff7e0693d  Yes         /lib/x86_64-linux-gnu/libc.so.6
</span></span><span style="display:flex;"><span>0x00007ffff7c46080  0x00007ffff7c46275  Yes         /lib/x86_64-linux-gnu/librt.so.1
</span></span><span style="display:flex;"><span>0x00007ffff6157d80  0x00007ffff662b504  Yes <span style="color:#ff79c6">(</span>*<span style="color:#ff79c6">)</span>     /lib/x86_64-linux-gnu/libcuda.so.1
</span></span><span style="display:flex;"><span>0x00007ffff4e18740  0x00007ffff4f6aef2  Yes <span style="color:#ff79c6">(</span>*<span style="color:#ff79c6">)</span>     /lib/x86_64-linux-gnu/libnvidia-ml.so.1
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">(</span>*<span style="color:#ff79c6">)</span>: Shared library is missing debugging information.
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">(</span>gdb<span style="color:#ff79c6">)</span> s
</span></span><span style="display:flex;"><span>_nvmlDeviceGetMemoryInfo <span style="color:#ff79c6">(</span><span style="color:#8be9fd;font-style:italic">device</span><span style="color:#ff79c6">=</span>0x7ffff51fbf38, <span style="color:#8be9fd;font-style:italic">memory</span><span style="color:#ff79c6">=</span>0x7fffffffd730, <span style="color:#8be9fd;font-style:italic">version</span><span style="color:#ff79c6">=</span>2<span style="color:#ff79c6">)</span> at /libvgpu/src/nvml/hook.c:319
</span></span><span style="display:flex;"><span>319	nvmlReturn_t _nvmlDeviceGetMemoryInfo<span style="color:#ff79c6">(</span>nvmlDevice_t device,nvmlMemory_t* memory,int version<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">(</span>gdb<span style="color:#ff79c6">)</span> l
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#8be9fd">nvmlReturn_t</span> <span style="color:#50fa7b">nvmlDeviceGetMemoryInfo_v2</span>(<span style="color:#8be9fd">nvmlDevice_t</span> device, <span style="color:#8be9fd">nvmlMemory_v2_t</span><span style="color:#ff79c6">*</span> memory) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">_nvmlDeviceGetMemoryInfo</span>(device,memory,<span style="color:#bd93f9">2</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">/**
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"> * 获取设备内存信息的内部函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"> * 这是一个hook函数，用于拦截和修改NVML的内存信息查询结果，实现GPU内存使用的限制和监控
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">nvmlReturn_t</span> <span style="color:#50fa7b">_nvmlDeviceGetMemoryInfo</span>(<span style="color:#8be9fd">nvmlDevice_t</span> device, <span style="color:#8be9fd">nvmlMemory_t</span><span style="color:#ff79c6">*</span> memory, <span style="color:#8be9fd">int</span> version) {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 用于存储设备ID的变量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">unsigned</span> <span style="color:#8be9fd">int</span> dev_id;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 记录函数入口的调试日志
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">LOG_DEBUG</span>(<span style="color:#f1fa8c">&#34;into nvmlDeviceGetMemoryInfo&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 根据API版本调用相应的原始NVML函数获取基础内存信息
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 这一步会获取GPU的原始内存信息，后续可能会根据限制进行修改
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">switch</span> (version) {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">case</span> <span style="color:#bd93f9">1</span><span style="color:#ff79c6">:</span>
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// v1版本API调用，直接使用nvmlMemory_t结构体
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#6272a4">// NVML_OVERRIDE_CALL宏用于调用原始的NVML库函数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#50fa7b">CHECK_NVML_API</span>(<span style="color:#50fa7b">NVML_OVERRIDE_CALL</span>(nvml_library_entry, nvmlDeviceGetMemoryInfo, device, memory));
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">case</span> <span style="color:#bd93f9">2</span><span style="color:#ff79c6">:</span>
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// v2版本API调用，需要将memory指针转换为nvmlMemory_v2_t*类型
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#6272a4">// nvmlMemory_v2_t结构体包含了更多的内存相关信息
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#50fa7b">CHECK_NVML_API</span>(<span style="color:#50fa7b">NVML_OVERRIDE_CALL</span>(nvml_library_entry, nvmlDeviceGetMemoryInfo_v2, device, (<span style="color:#8be9fd">nvmlMemory_v2_t</span> <span style="color:#ff79c6">*</span>)memory));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 记录从NVML获取的原始内存信息，用于调试和比较
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">LOG_DEBUG</span>(<span style="color:#f1fa8c">&#34;origin_free=%lld total=%lld</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>, memory<span style="color:#ff79c6">-&gt;</span>free, memory<span style="color:#ff79c6">-&gt;</span>total);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 获取NVML设备索引，并转换为CUDA设备索引
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// NVML和CUDA的设备索引可能不同，需要进行映射
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">CHECK_NVML_API</span>(<span style="color:#50fa7b">nvmlDeviceGetIndex</span>(device, <span style="color:#ff79c6">&amp;</span>dev_id));
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">int</span> cudadev <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">nvml_to_cuda_map</span>(dev_id);
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> (cudadev <span style="color:#ff79c6">&lt;</span> <span style="color:#bd93f9">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 设备映射失败，说明找不到对应的CUDA设备
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 此时返回原始的NVML信息，不做修改
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">return</span> NVML_SUCCESS;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 获取当前设备的实际内存使用情况和限制
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 这些信息来自我们自己的内存跟踪系统，而不是NVML
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">size_t</span> usage <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">get_current_device_memory_usage</span>(cudadev);     <span style="color:#6272a4">// 获取当前实际使用的GPU内存量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">size_t</span> monitor <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">get_current_device_memory_monitor</span>(cudadev); <span style="color:#6272a4">// 获取内存监控的阈值设置
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 从共享内存region中获取limit，跟上面的do_init_device_memory_limits函数有关
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">size_t</span> limit <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">get_current_device_memory_limit</span>(cudadev);     <span style="color:#6272a4">// 获取设置的内存使用上限
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 记录实际的内存使用情况，用于调试
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">LOG_DEBUG</span>(<span style="color:#f1fa8c">&#34;usage=%ld limit=%ld monitor=%ld&#34;</span>, usage, limit, monitor);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 检查传入的memory指针是否为空
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 这是一个安全检查，防止访问空指针
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> (memory <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">NULL</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> NVML_SUCCESS;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 根据是否设置了内存限制来更新返回的内存信息
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> (limit <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 未设置内存限制的情况（limit = 0）
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 此时只更新已用内存信息，保持其他信息（如total）不变
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">switch</span> (version) {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">case</span> <span style="color:#bd93f9">1</span><span style="color:#ff79c6">:</span>
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// 更新v1版本结构体中的已用内存字段
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            memory<span style="color:#ff79c6">-&gt;</span>used <span style="color:#ff79c6">=</span> usage;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> NVML_SUCCESS;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">case</span> <span style="color:#bd93f9">2</span><span style="color:#ff79c6">:</span>
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// 更新v2版本结构体中的已用内存字段
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            ((<span style="color:#8be9fd">nvmlMemory_v2_t</span> <span style="color:#ff79c6">*</span>)memory)<span style="color:#ff79c6">-&gt;</span>used <span style="color:#ff79c6">=</span> usage;
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> NVML_SUCCESS;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#ff79c6">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 设置了内存限制的情况
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 需要更新所有内存相关字段，包括total、free和used
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">switch</span> (version) {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">case</span> <span style="color:#bd93f9">1</span><span style="color:#ff79c6">:</span>
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// 更新v1版本结构体的所有字段
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            memory<span style="color:#ff79c6">-&gt;</span>free <span style="color:#ff79c6">=</span> (limit <span style="color:#ff79c6">-</span> usage);  <span style="color:#6272a4">// 可用内存为限制值减去已用内存
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            memory<span style="color:#ff79c6">-&gt;</span>total <span style="color:#ff79c6">=</span> limit;           <span style="color:#6272a4">// 将总内存设置为限制值
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            memory<span style="color:#ff79c6">-&gt;</span>used <span style="color:#ff79c6">=</span> usage;            <span style="color:#6272a4">// 设置已用内存
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">return</span> NVML_SUCCESS;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">case</span> <span style="color:#bd93f9">2</span><span style="color:#ff79c6">:</span>
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// 更新v2版本结构体的所有字段
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            ((<span style="color:#8be9fd">nvmlMemory_v2_t</span> <span style="color:#ff79c6">*</span>)memory)<span style="color:#ff79c6">-&gt;</span>used <span style="color:#ff79c6">=</span> usage;   <span style="color:#6272a4">// 设置已用内存
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            ((<span style="color:#8be9fd">nvmlMemory_v2_t</span> <span style="color:#ff79c6">*</span>)memory)<span style="color:#ff79c6">-&gt;</span>total <span style="color:#ff79c6">=</span> limit;  <span style="color:#6272a4">// 将总内存设置为限制值
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            ((<span style="color:#8be9fd">nvmlMemory_v2_t</span> <span style="color:#ff79c6">*</span>)memory)<span style="color:#ff79c6">-&gt;</span>used <span style="color:#ff79c6">=</span> usage;   <span style="color:#6272a4">// BUG: 这行是重复的，应该删除
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                                                        <span style="color:#6272a4">// 可能是复制粘贴导致的错误
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">return</span> NVML_SUCCESS;
</span></span><span style="display:flex;"><span>        } 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 所有情况都已在switch语句中返回
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 这个return语句实际上永远不会被执行到
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">return</span> NVML_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>CUDA_DEVICE_SM_LIMIT=50，是如何控制GPU利用率稳定在50%的，有个监控在watcher吗？通过源码查看，大概率就是这个文件了<code>HAMi-core/src/multiprocess/multiprocess_utilization_watcher.c</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cuInit -&gt; postInit -&gt; init_utilization_watcher -&gt; utilization_watcher
</span></span></code></pre></div><p>在cuInit初始化驱动API的时候，被hook劫持，最后会调用到<code>utilization_watcher</code>函数，这个函数会持续监控GPU利用率，并根据设置的CUDA_DEVICE_SM_LIMIT来调整GPU利用率。</p>
<p>监控线程函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#8be9fd">void</span><span style="color:#ff79c6">*</span> <span style="color:#50fa7b">utilization_watcher</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">nvmlInit</span>();  <span style="color:#6272a4">// 初始化NVIDIA管理库
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> userutil[CUDA_DEVICE_MAX_COUNT];  <span style="color:#6272a4">// 存储每个设备的用户使用率
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> sysprocnum;  <span style="color:#6272a4">// 系统进程数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> share <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;   <span style="color:#6272a4">// 当前分配的share值
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> upper_limit <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">get_current_device_sm_limit</span>(<span style="color:#bd93f9">0</span>);  <span style="color:#6272a4">// 获取SM使用率上限
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">LOG_DEBUG</span>(<span style="color:#f1fa8c">&#34;upper_limit=%d</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>,upper_limit);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 持续监控循环
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">while</span> (<span style="color:#bd93f9">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#50fa7b">nanosleep</span>(<span style="color:#ff79c6">&amp;</span>g_wait, <span style="color:#8be9fd;font-style:italic">NULL</span>);  <span style="color:#6272a4">// 周期性休眠
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 确保目标进程存在
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">if</span> (pidfound<span style="color:#ff79c6">==</span><span style="color:#bd93f9">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#50fa7b">update_host_pid</span>();  <span style="color:#6272a4">// 更新主机进程ID
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">if</span> (pidfound<span style="color:#ff79c6">==</span><span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">continue</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 初始化GPU设备SM使用率
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#50fa7b">init_gpu_device_sm_utilization</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 获取当前GPU使用情况
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#50fa7b">get_used_gpu_utilization</span>(userutil,<span style="color:#ff79c6">&amp;</span>sysprocnum);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 动态扩容机制
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 当share达到最大值且没有可用核心时,翻倍总容量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">if</span> ((share<span style="color:#ff79c6">==</span>g_total_cuda_cores) <span style="color:#ff79c6">&amp;&amp;</span> (g_cur_cuda_cores<span style="color:#ff79c6">&lt;</span><span style="color:#bd93f9">0</span>)) {
</span></span><span style="display:flex;"><span>            g_total_cuda_cores <span style="color:#ff79c6">*=</span> <span style="color:#bd93f9">2</span>;
</span></span><span style="display:flex;"><span>            share <span style="color:#ff79c6">=</span> g_total_cuda_cores;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 计算新的share值
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        share <span style="color:#ff79c6">=</span> <span style="color:#50fa7b">delta</span>(upper_limit, userutil[<span style="color:#bd93f9">0</span>], share);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#50fa7b">LOG_DEBUG</span>(<span style="color:#f1fa8c">&#34;userutil=%d currentcores=%d total=%d limit=%d share=%d</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">&#34;</span>,
</span></span><span style="display:flex;"><span>                 userutil[<span style="color:#bd93f9">0</span>],g_cur_cuda_cores,g_total_cuda_cores,upper_limit,share);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 更新令牌数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#50fa7b">change_token</span>(share);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个GPU SM(Stream Multiprocessor)资源的动态分配和限制机制其实是基于令牌桶思想. 接下来来看下GPU利用率令牌桶的实现：</p>
<ol>
<li>关键全局变量</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#ff79c6">static</span> <span style="color:#8be9fd">int</span> g_sm_num;                    <span style="color:#6272a4">// GPU中的Stream Multiprocessor数量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">static</span> <span style="color:#8be9fd">int</span> g_max_thread_per_sm;         <span style="color:#6272a4">// 每个SM支持的最大线程数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">static</span> <span style="color:#ff79c6">volatile</span> <span style="color:#8be9fd">int</span> g_cur_cuda_cores;   <span style="color:#6272a4">// 当前可用的CUDA核心数(令牌数)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">static</span> <span style="color:#ff79c6">volatile</span> <span style="color:#8be9fd">int</span> g_total_cuda_cores; <span style="color:#6272a4">// 总的CUDA核心数(桶容量)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">extern</span> <span style="color:#8be9fd">int</span> pidfound;                    <span style="color:#6272a4">// 是否找到目标进程的标志
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd">int</span> cuda_to_nvml_map[<span style="color:#bd93f9">16</span>];              <span style="color:#6272a4">// CUDA设备到NVML设备的映射关系
</span></span></span></code></pre></div><ol start="2">
<li>令牌消耗函数</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#8be9fd">void</span> <span style="color:#50fa7b">rate_limiter</span>(<span style="color:#8be9fd">int</span> grids, <span style="color:#8be9fd">int</span> blocks) {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">int</span> before_cuda_cores <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;  <span style="color:#6272a4">// 消耗令牌前的数量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> after_cuda_cores <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;   <span style="color:#6272a4">// 消耗令牌后的数量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> kernel_size <span style="color:#ff79c6">=</span> grids;    <span style="color:#6272a4">// 将要启动的kernel大小(需要消耗的令牌数)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 等待直到有最近的kernel信息
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">while</span> (<span style="color:#50fa7b">get_recent_kernel</span>()<span style="color:#ff79c6">&lt;</span><span style="color:#bd93f9">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#50fa7b">sleep</span>(<span style="color:#bd93f9">1</span>);  <span style="color:#6272a4">// 如果没有最近的kernel信息,睡眠1秒后重试
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">set_recent_kernel</span>(<span style="color:#bd93f9">2</span>);  <span style="color:#6272a4">// 设置kernel状态为2
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 检查是否需要进行限制
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 如果SM利用率限制&gt;=100%或为0,表示不需要限制
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> ((<span style="color:#50fa7b">get_current_device_sm_limit</span>(<span style="color:#bd93f9">0</span>)<span style="color:#ff79c6">&gt;=</span><span style="color:#bd93f9">100</span>) <span style="color:#ff79c6">||</span> (<span style="color:#50fa7b">get_current_device_sm_limit</span>(<span style="color:#bd93f9">0</span>)<span style="color:#ff79c6">==</span><span style="color:#bd93f9">0</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 如果利用率开关未打开,也不需要限制
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> (<span style="color:#50fa7b">get_utilization_switch</span>()<span style="color:#ff79c6">==</span><span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">LOG_DEBUG</span>(<span style="color:#f1fa8c">&#34;grid: %d, blocks: %d&#34;</span>, grids, blocks);
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">LOG_DEBUG</span>(<span style="color:#f1fa8c">&#34;launch kernel %d, curr core: %d&#34;</span>, kernel_size, g_cur_cuda_cores);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 循环尝试消耗令牌
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">do</span> {
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">CHECK</span>:
</span></span><span style="display:flex;"><span>        before_cuda_cores <span style="color:#ff79c6">=</span> g_cur_cuda_cores;  <span style="color:#6272a4">// 获取当前可用令牌数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#50fa7b">LOG_DEBUG</span>(<span style="color:#f1fa8c">&#34;current core: %d&#34;</span>, g_cur_cuda_cores);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 如果没有足够的令牌,等待一段时间后重试
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">if</span> (before_cuda_cores <span style="color:#ff79c6">&lt;</span> <span style="color:#bd93f9">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#50fa7b">nanosleep</span>(<span style="color:#ff79c6">&amp;</span>g_cycle, <span style="color:#8be9fd;font-style:italic">NULL</span>);  <span style="color:#6272a4">// 使用nanosleep避免忙等待
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">goto</span> CHECK;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 计算消耗令牌后的数量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        after_cuda_cores <span style="color:#ff79c6">=</span> before_cuda_cores <span style="color:#ff79c6">-</span> kernel_size;
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// CAS操作确保原子性,如果失败则重试整个过程
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    } <span style="color:#ff79c6">while</span> (<span style="color:#ff79c6">!</span><span style="color:#50fa7b">CAS</span>(<span style="color:#ff79c6">&amp;</span>g_cur_cuda_cores, before_cuda_cores, after_cuda_cores));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>rate_limiter</code>在hook的<code>cuLaunchKernel</code>中被调用，拦截了原始的<code>cuLaunchKernel</code>调用，在原始调用前后添加了资源控制逻辑，保持了与原始CUDA API相同的接口. 什么时候会触发cuLaunchKernel？大多数CUDA计算最终都会转化为kernel的执行，而cuLaunchKernel是启动kernel的底层API.</p>
<ol start="3">
<li>令牌更新函数</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#ff79c6">static</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">change_token</span>(<span style="color:#8be9fd">int</span> delta) {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">int</span> cuda_cores_before <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;  <span style="color:#6272a4">// 更新前的令牌数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> cuda_cores_after <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>;   <span style="color:#6272a4">// 更新后的令牌数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#50fa7b">LOG_DEBUG</span>(<span style="color:#f1fa8c">&#34;delta: %d, curr: %d&#34;</span>, delta, g_cur_cuda_cores);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 循环尝试更新令牌数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">do</span> {
</span></span><span style="display:flex;"><span>        cuda_cores_before <span style="color:#ff79c6">=</span> g_cur_cuda_cores;  <span style="color:#6272a4">// 获取当前令牌数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        cuda_cores_after <span style="color:#ff79c6">=</span> cuda_cores_before <span style="color:#ff79c6">+</span> delta;  <span style="color:#6272a4">// 计算新的令牌数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 确保不超过最大容量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">if</span> (cuda_cores_after <span style="color:#ff79c6">&gt;</span> g_total_cuda_cores) {
</span></span><span style="display:flex;"><span>            cuda_cores_after <span style="color:#ff79c6">=</span> g_total_cuda_cores;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// CAS操作确保原子性,如果失败则重试
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    } <span style="color:#ff79c6">while</span> (<span style="color:#ff79c6">!</span><span style="color:#50fa7b">CAS</span>(<span style="color:#ff79c6">&amp;</span>g_cur_cuda_cores, cuda_cores_before, cuda_cores_after));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="4">
<li>令牌计算函数</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#8be9fd">int</span> <span style="color:#50fa7b">delta</span>(<span style="color:#8be9fd">int</span> up_limit, <span style="color:#8be9fd">int</span> user_current, <span style="color:#8be9fd">int</span> share) {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 计算实际使用率与限制之间的差异
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 如果差异小于5%,则使用5%作为最小调整单位
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> utilization_diff <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>        <span style="color:#50fa7b">abs</span>(up_limit <span style="color:#ff79c6">-</span> user_current) <span style="color:#ff79c6">&lt;</span> <span style="color:#bd93f9">5</span> <span style="color:#ff79c6">?</span> <span style="color:#bd93f9">5</span> <span style="color:#ff79c6">:</span> <span style="color:#50fa7b">abs</span>(up_limit <span style="color:#ff79c6">-</span> user_current);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 计算基础增量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 公式: (SM数量)² * 每个SM的最大线程数 * 使用率差异 / 2560
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 2560是一个经验值,用于将增量控制在合理范围
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> increment <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>        g_sm_num <span style="color:#ff79c6">*</span> g_sm_num <span style="color:#ff79c6">*</span> g_max_thread_per_sm <span style="color:#ff79c6">*</span> utilization_diff <span style="color:#ff79c6">/</span> <span style="color:#bd93f9">2560</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 当使用率差异大于限制的一半时,加速调整
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 这是为了在使用率变化剧烈时能快速响应
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> (utilization_diff <span style="color:#ff79c6">&gt;</span> up_limit <span style="color:#ff79c6">/</span> <span style="color:#bd93f9">2</span>) {
</span></span><span style="display:flex;"><span>        increment <span style="color:#ff79c6">=</span> increment <span style="color:#ff79c6">*</span> utilization_diff <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">2</span> <span style="color:#ff79c6">/</span> (up_limit <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 根据当前使用率调整share值
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> (user_current <span style="color:#ff79c6">&lt;=</span> up_limit) {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 使用率低于限制时,增加share
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 但确保不超过总容量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        share <span style="color:#ff79c6">=</span> share <span style="color:#ff79c6">+</span> increment <span style="color:#ff79c6">&gt;</span> g_total_cuda_cores <span style="color:#ff79c6">?</span> 
</span></span><span style="display:flex;"><span>                <span style="color:#8be9fd;font-style:italic">g_total_cuda_cores</span> : share <span style="color:#ff79c6">+</span> increment;
</span></span><span style="display:flex;"><span>    } <span style="color:#ff79c6">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 使用率高于限制时,减少share
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 但确保不小于0
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        share <span style="color:#ff79c6">=</span> share <span style="color:#ff79c6">-</span> increment <span style="color:#ff79c6">&lt;</span> <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">?</span> <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">:</span> share <span style="color:#ff79c6">-</span> increment;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> share;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="56-hami-core-gdb调试">5.6 hami-core gdb调试</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#6272a4"># 检查动态库是否包含调试符号</span>
</span></span><span style="display:flex;"><span>readelf -S libvgpu.so | grep debug
</span></span></code></pre></div><p>修改CMakeLists.txt编译参数, <code>-g</code>是生成调试信息，包括源代码行号、变量名等，可以被GDB等调试器更好地调试；<code>-fvisibility=hidden</code>控制共享库中符号的可见性，可以减少动态链接时的符号冲突，提高加载速度，并减小二进制大小</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#6272a4"># Compile flags</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>CMAKE_BUILD_TYPE STREQUAL Debug<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span>    set<span style="color:#ff79c6">(</span>LIBRARY_COMPILE_FLAGS -shared -fPIC -g -D_GNU_SOURCE -fvisibility<span style="color:#ff79c6">=</span>hidden -Wall<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span>    set<span style="color:#ff79c6">(</span>TEST_COMPILE_FLAGS -O1 -g<span style="color:#ff79c6">)</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">else</span><span style="color:#ff79c6">()</span>
</span></span><span style="display:flex;"><span>    ......
</span></span></code></pre></div><p>编译时候设置<code>-fvisibility=hidden</code>，针对hook的函数，需要设置<code>__attribute__((visibility(&quot;default&quot;)))</code>，否则无法被gdb调试.所有需要批量把cuda、nvml hook的函数都设置为默认可见</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#6272a4">// 以nvmlDeviceGetMemoryInfo函数为例，设置为默认可见
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#50fa7b">__attribute__</span>((<span style="color:#50fa7b">visibility</span>(<span style="color:#f1fa8c">&#34;default&#34;</span>)))
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">nvmlReturn_t</span> <span style="color:#50fa7b">nvmlDeviceGetMemoryInfo</span>(<span style="color:#8be9fd">nvmlDevice_t</span> device, <span style="color:#8be9fd">nvmlMemory_t</span><span style="color:#ff79c6">*</span> memory) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#50fa7b">_nvmlDeviceGetMemoryInfo</span>(device,memory,<span style="color:#bd93f9">1</span>); 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>gdb单步调试，libvgpu.so的函数被调用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#ff79c6">(</span>base<span style="color:#ff79c6">)</span> root@vgpu:/libvgpu/build# <span style="color:#8be9fd;font-style:italic">LD_PRELOAD</span><span style="color:#ff79c6">=</span>./libvgpu.so gdb test/test_alloc
</span></span><span style="display:flex;"><span>GNU gdb <span style="color:#ff79c6">(</span>Ubuntu 12.1-0ubuntu1~22.04.2<span style="color:#ff79c6">)</span> 12.1
</span></span><span style="display:flex;"><span>Copyright <span style="color:#ff79c6">(</span>C<span style="color:#ff79c6">)</span> <span style="color:#bd93f9">2022</span> Free Software Foundation, Inc.
</span></span><span style="display:flex;"><span>License GPLv3+: GNU GPL version <span style="color:#bd93f9">3</span> or later &lt;http://gnu.org/licenses/gpl.html&gt;
</span></span><span style="display:flex;"><span>This is free software: you are free to change and redistribute it.
</span></span><span style="display:flex;"><span>There is NO WARRANTY, to the extent permitted by law.
</span></span><span style="display:flex;"><span>Type <span style="color:#f1fa8c">&#34;show copying&#34;</span> and <span style="color:#f1fa8c">&#34;show warranty&#34;</span> <span style="color:#ff79c6">for</span> details.
</span></span><span style="display:flex;"><span>This GDB was configured as <span style="color:#f1fa8c">&#34;x86_64-linux-gnu&#34;</span>.
</span></span><span style="display:flex;"><span>Type <span style="color:#f1fa8c">&#34;show configuration&#34;</span> <span style="color:#ff79c6">for</span> configuration details.
</span></span><span style="display:flex;"><span>For bug reporting instructions, please see:
</span></span><span style="display:flex;"><span>&lt;https://www.gnu.org/software/gdb/bugs/&gt;.
</span></span><span style="display:flex;"><span>Find the GDB manual and other documentation resources online at:
</span></span><span style="display:flex;"><span>    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>For help, <span style="color:#8be9fd;font-style:italic">type</span> <span style="color:#f1fa8c">&#34;help&#34;</span>.
</span></span><span style="display:flex;"><span>Type <span style="color:#f1fa8c">&#34;apropos word&#34;</span> to search <span style="color:#ff79c6">for</span> commands related to <span style="color:#f1fa8c">&#34;word&#34;</span>...
</span></span><span style="display:flex;"><span>Reading symbols from test/test_alloc...
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">(</span>gdb<span style="color:#ff79c6">)</span> b main
</span></span><span style="display:flex;"><span>Breakpoint <span style="color:#bd93f9">1</span> at 0x17c1: file /libvgpu/test/test_alloc.c, line 68.
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">(</span>gdb<span style="color:#ff79c6">)</span> r
</span></span><span style="display:flex;"><span>Starting program: /libvgpu/build/test/test_alloc
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">[</span>Thread debugging using libthread_db enabled<span style="color:#ff79c6">]</span>
</span></span><span style="display:flex;"><span>Using host libthread_db library <span style="color:#f1fa8c">&#34;/lib/x86_64-linux-gnu/libthread_db.so.1&#34;</span>.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Breakpoint 1, main <span style="color:#ff79c6">()</span> at /libvgpu/test/test_alloc.c:68
</span></span><span style="display:flex;"><span>68	int main<span style="color:#ff79c6">()</span> <span style="color:#ff79c6">{</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">(</span>gdb<span style="color:#ff79c6">)</span> sharedlibrary libvgpu.so
</span></span><span style="display:flex;"><span>Symbols already loaded <span style="color:#ff79c6">for</span> ./libvgpu.so
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">(</span>gdb<span style="color:#ff79c6">)</span> b _nvmlDeviceGetMemoryInfo
</span></span><span style="display:flex;"><span>Breakpoint <span style="color:#bd93f9">2</span> at 0x7ffff7f86075: file /libvgpu/src/nvml/hook.c, line 317.
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">(</span>gdb<span style="color:#ff79c6">)</span> b /libvgpu/src/nvml/hook.c:317
</span></span><span style="display:flex;"><span>Note: breakpoint <span style="color:#bd93f9">2</span> also <span style="color:#8be9fd;font-style:italic">set</span> at pc 0x7ffff7f86075.
</span></span><span style="display:flex;"><span>Breakpoint <span style="color:#bd93f9">3</span> at 0x7ffff7f86075: file /libvgpu/src/nvml/hook.c, line 317.
</span></span></code></pre></div><h2 id="57-vgpumonitor调试环境">5.7 vGPUMonitor调试环境</h2>
<p>远程gpu服务器上dlv启动vGPUMonitor，本地goland添加Go Remote Debugger指向<!-- raw HTML omitted -->:2347</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">KUBECONFIG</span><span style="color:#ff79c6">=</span>/root/.kube/config <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span><span style="color:#8be9fd;font-style:italic">NODE_NAME</span><span style="color:#ff79c6">=</span>vgpu <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span><span style="color:#8be9fd;font-style:italic">NVIDIA_VISIBLE_DEVICES</span><span style="color:#ff79c6">=</span>all <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span><span style="color:#8be9fd;font-style:italic">NVIDIA_MIG_MONITOR_DEVICES</span><span style="color:#ff79c6">=</span>all <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span><span style="color:#8be9fd;font-style:italic">HOOK_PATH</span><span style="color:#ff79c6">=</span>/usr/local/vgpu <span style="color:#f1fa8c">\
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c"></span>dlv <span style="color:#8be9fd;font-style:italic">exec</span> bin/vGPUmonitor --headless -l 0.0.0.0:2347 --api-version<span style="color:#ff79c6">=</span><span style="color:#bd93f9">2</span>
</span></span></code></pre></div><h2 id="58-vgpumonitor核心逻辑">5.8 vGPUMonitor核心逻辑</h2>
<p>启动函数，程序的主要功能是监控vGPU的使用情况，并提供相应的指标收集和反馈机制</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 校验环境变量HOOK_PATH必须存在
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">ValidateEnvVars</span>(); err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		klog.<span style="color:#50fa7b">Fatalf</span>(<span style="color:#f1fa8c">&#34;Failed to validate environment variables: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 创建一个容器列表器实例，用于跟踪和管理GPU容器Usage
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	containerLister, err <span style="color:#ff79c6">:=</span> nvidia.<span style="color:#50fa7b">NewContainerLister</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		klog.<span style="color:#50fa7b">Fatalf</span>(<span style="color:#f1fa8c">&#34;Failed to create container lister: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	cgroupDriver = <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 创建一个错误通道用于错误处理, 用于在不同goroutine间传递错误信息（看起来没有意义了，因为main函数里没有使用）
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	errchannel <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd">error</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#6272a4">//go serveInfo(errchannel)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 初始化vGPUmonitor metrics
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">go</span> <span style="color:#50fa7b">initMetrics</span>(containerLister)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 持续监控容器使用情况
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">go</span> <span style="color:#50fa7b">watchAndFeedback</span>(containerLister)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 等待错误通道传递错误信息，errchannel实际上没用到
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>		err <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&lt;-</span>errchannel
</span></span><span style="display:flex;"><span>		klog.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;failed to serve: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>主要使用到的结构体</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#6272a4">// ContainerLister结构体，用于存储容器列表使用信息
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> ContainerLister <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>	containerPath <span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// map存储容器使用信息，key为&lt;podUID_containerName&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	containers    <span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">string</span>]<span style="color:#ff79c6">*</span>ContainerUsage
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// 互斥锁，用于保护containers map的并发访问
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	mutex         sync.Mutex
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// k8s clientSet
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	clientset     <span style="color:#ff79c6">*</span>kubernetes.Clientset
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// ContainerUsage结构体，用于存储单个容器使用信息
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> ContainerUsage <span style="color:#8be9fd;font-style:italic">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// Pod 的唯一标识符
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	PodUID        <span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// 容器名称
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	ContainerName <span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// 容器使用信息
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	data          []<span style="color:#8be9fd">byte</span>
</span></span><span style="display:flex;"><span>	Info          UsageInfo
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// UsageInfo接口，定义了获取和设置NVIDIA GPU设备使用情况的方法
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> UsageInfo <span style="color:#8be9fd;font-style:italic">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// DeviceMax 返回系统中支持的最大GPU设备数量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">DeviceMax</span>() <span style="color:#8be9fd">int</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// DeviceNum 返回当前实际使用的GPU设备数量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">DeviceNum</span>() <span style="color:#8be9fd">int</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// DeviceMemoryContextSize 返回指定GPU设备的上下文内存大小
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">DeviceMemoryContextSize</span>(idx <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">uint64</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// DeviceMemoryModuleSize 返回指定GPU设备的模块内存大小
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">DeviceMemoryModuleSize</span>(idx <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">uint64</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// DeviceMemoryBufferSize 返回指定GPU设备的缓冲区内存大小
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">DeviceMemoryBufferSize</span>(idx <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">uint64</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// DeviceMemoryOffset 返回指定GPU设备的内存偏移量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">DeviceMemoryOffset</span>(idx <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">uint64</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// DeviceMemoryTotal 返回指定GPU设备的总内存大小
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">DeviceMemoryTotal</span>(idx <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">uint64</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// DeviceSmUtil 返回指定GPU设备的SM(Streaming Multiprocessor)利用率
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">DeviceSmUtil</span>(idx <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">uint64</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// SetDeviceSmLimit 设置GPU设备的SM使用限制
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">SetDeviceSmLimit</span>(l <span style="color:#8be9fd">uint64</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// IsValidUUID 检查指定GPU设备的UUID是否有效
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">IsValidUUID</span>(idx <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">bool</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// DeviceUUID 返回指定GPU设备的UUID
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">DeviceUUID</span>(idx <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">string</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// DeviceMemoryLimit 返回指定GPU设备的内存使用限制
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">DeviceMemoryLimit</span>(idx <span style="color:#8be9fd">int</span>) <span style="color:#8be9fd">uint64</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// SetDeviceMemoryLimit 设置GPU设备的内存使用限制
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">SetDeviceMemoryLimit</span>(l <span style="color:#8be9fd">uint64</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// LastKernelTime 返回最后一次内核执行的时间戳
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">LastKernelTime</span>() <span style="color:#8be9fd">int64</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// UsedMemory 返回指定GPU设备的已使用内存（当前已注释）
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">//UsedMemory(idx int) (uint64, error)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// GetPriority 返回GPU任务的优先级
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">GetPriority</span>() <span style="color:#8be9fd">int</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// GetRecentKernel 获取最近的内核执行状态
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">GetRecentKernel</span>() <span style="color:#8be9fd">int32</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// SetRecentKernel 设置最近的内核执行状态
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">SetRecentKernel</span>(v <span style="color:#8be9fd">int32</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// GetUtilizationSwitch 获取利用率开关状态
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">GetUtilizationSwitch</span>() <span style="color:#8be9fd">int32</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// SetUtilizationSwitch 设置利用率开关状态
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#50fa7b">SetUtilizationSwitch</span>(v <span style="color:#8be9fd">int32</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>容器列表器实例，如何更新containers map？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> (l <span style="color:#ff79c6">*</span>ContainerLister) <span style="color:#50fa7b">Update</span>() <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 是否设置NODE_NAME环境变量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	nodename <span style="color:#ff79c6">:=</span> os.<span style="color:#50fa7b">Getenv</span>(util.NodeNameEnvName)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> nodename <span style="color:#ff79c6">==</span> <span style="color:#f1fa8c">&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;env %s not set&#34;</span>, util.NodeNameEnvName)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 获取指定节点上的所有Pod
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	pods, err <span style="color:#ff79c6">:=</span> l.clientset.<span style="color:#50fa7b">CoreV1</span>().<span style="color:#50fa7b">Pods</span>(<span style="color:#f1fa8c">&#34;&#34;</span>).<span style="color:#50fa7b">List</span>(context.<span style="color:#50fa7b">Background</span>(), metav1.ListOptions{
</span></span><span style="display:flex;"><span>		FieldSelector: fmt.<span style="color:#50fa7b">Sprintf</span>(<span style="color:#f1fa8c">&#34;spec.nodeName=%s&#34;</span>, nodename),
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 加锁，保护containers map的并发访问
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	l.mutex.<span style="color:#50fa7b">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">defer</span> l.mutex.<span style="color:#50fa7b">Unlock</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 读取容器目录下的所有文件
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	entries, err <span style="color:#ff79c6">:=</span> os.<span style="color:#50fa7b">ReadDir</span>(l.containerPath)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> err
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 遍历容器目录下的所有文件
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">for</span> _, entry <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> entries {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> !entry.<span style="color:#50fa7b">IsDir</span>() {
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">continue</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 获取容器目录的完整路径
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// containerPath: /usr/local/vgpu/containers
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// entry.Name(): 305df464-2a9e-485d-9c80-f2901a9259cc_pytorch-container
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		dirName <span style="color:#ff79c6">:=</span> filepath.<span style="color:#50fa7b">Join</span>(l.containerPath, entry.<span style="color:#50fa7b">Name</span>())
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 检查容器是否存在，如果不存在的话
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">if</span> !<span style="color:#50fa7b">isValidPod</span>(entry.<span style="color:#50fa7b">Name</span>(), pods) {
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// 获取容器目录的元数据
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>			dirInfo, err <span style="color:#ff79c6">:=</span> os.<span style="color:#50fa7b">Stat</span>(dirName)
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// 如果容器目录存在，并且修改时间在300秒内，则跳过
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>			<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span> <span style="color:#ff79c6">&amp;&amp;</span> dirInfo.<span style="color:#50fa7b">ModTime</span>().<span style="color:#50fa7b">Add</span>(time.Second<span style="color:#ff79c6">*</span><span style="color:#bd93f9">300</span>).<span style="color:#50fa7b">After</span>(time.<span style="color:#50fa7b">Now</span>()) {
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">continue</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			klog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;Removing dirname %s in monitorpath&#34;</span>, dirName)
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// 判断map中是否存在该容器
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>			<span style="color:#ff79c6">if</span> c, ok <span style="color:#ff79c6">:=</span> l.containers[entry.<span style="color:#50fa7b">Name</span>()]; ok {
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// 如果存在，则释放内存
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>				syscall.<span style="color:#50fa7b">Munmap</span>(c.data)
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// 删除map中的该容器
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>				<span style="color:#8be9fd;font-style:italic">delete</span>(l.containers, entry.<span style="color:#50fa7b">Name</span>())
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// 删除容器目录
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>			_ = os.<span style="color:#50fa7b">RemoveAll</span>(dirName)
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">continue</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 检查容器是否存在，如果存在的话
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 判断map中是否存在该容器
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">if</span> _, ok <span style="color:#ff79c6">:=</span> l.containers[entry.<span style="color:#50fa7b">Name</span>()]; ok {
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">continue</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 加载容器使用信息
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		usage, err <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">loadCache</span>(dirName)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>			klog.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;Failed to load cache: %s, error: %v&#34;</span>, dirName, err)
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">continue</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 如果容器使用信息为空，则跳过
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">if</span> usage <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#6272a4">// no cuInit in container
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>			<span style="color:#ff79c6">continue</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 获取pod uid和container name
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		usage.PodUID = strings.<span style="color:#50fa7b">Split</span>(entry.<span style="color:#50fa7b">Name</span>(), <span style="color:#f1fa8c">&#34;_&#34;</span>)[<span style="color:#bd93f9">0</span>]
</span></span><span style="display:flex;"><span>		usage.ContainerName = strings.<span style="color:#50fa7b">Split</span>(entry.<span style="color:#50fa7b">Name</span>(), <span style="color:#f1fa8c">&#34;_&#34;</span>)[<span style="color:#bd93f9">1</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 将容器使用信息添加到map中
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		l.containers[entry.<span style="color:#50fa7b">Name</span>()] = usage
</span></span><span style="display:flex;"><span>		klog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;Adding ctr dirname %s in monitorpath&#34;</span>, dirName)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>loadCache函数，如何加载容器使用信息？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">loadCache</span>(fpath <span style="color:#8be9fd">string</span>) (<span style="color:#ff79c6">*</span>ContainerUsage, <span style="color:#8be9fd">error</span>) {
</span></span><span style="display:flex;"><span>	klog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;Checking path %s&#34;</span>, fpath)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 读取容器目录下的所有文件，形如/usr/local/vgpu/containers/305df464-2a9e-485d-9c80-f2901a9259cc_pytorch-container/
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	files, err <span style="color:#ff79c6">:=</span> os.<span style="color:#50fa7b">ReadDir</span>(fpath)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, err
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 检查文件数量，如果文件数量大于2，则返回错误
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">len</span>(files) &gt; <span style="color:#bd93f9">2</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, errors.<span style="color:#50fa7b">New</span>(<span style="color:#f1fa8c">&#34;cache num not matched&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 如果文件数量为0，则返回nil
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">len</span>(files) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	cacheFile <span style="color:#ff79c6">:=</span> <span style="color:#f1fa8c">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">for</span> _, val <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> files {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 检查文件名是否包含libvgpu.so
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">if</span> strings.<span style="color:#50fa7b">Contains</span>(val.<span style="color:#50fa7b">Name</span>(), <span style="color:#f1fa8c">&#34;libvgpu.so&#34;</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">continue</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 检查文件名是否包含.cache
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">if</span> !strings.<span style="color:#50fa7b">Contains</span>(val.<span style="color:#50fa7b">Name</span>(), <span style="color:#f1fa8c">&#34;.cache&#34;</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">continue</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 获取cache文件的完整路径
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		cacheFile = filepath.<span style="color:#50fa7b">Join</span>(fpath, val.<span style="color:#50fa7b">Name</span>())
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">break</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 如果cacheFile为空，则返回nil
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">if</span> cacheFile <span style="color:#ff79c6">==</span> <span style="color:#f1fa8c">&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>		klog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;No cache file in %s&#34;</span>, fpath)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 获取cache文件的元数据
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	info, err <span style="color:#ff79c6">:=</span> os.<span style="color:#50fa7b">Stat</span>(cacheFile)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		klog.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;Failed to stat cache file: %s, error: %v&#34;</span>, cacheFile, err)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, err
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 检查cache文件大小，如果小于headerT结构体的大小，则返回错误
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">if</span> info.<span style="color:#50fa7b">Size</span>() &lt; <span style="color:#8be9fd;font-style:italic">int64</span>(unsafe.<span style="color:#50fa7b">Sizeof</span>(headerT{})) {
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;cache file size %d too small&#34;</span>, info.<span style="color:#50fa7b">Size</span>())
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 打开cache文件
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	f, err <span style="color:#ff79c6">:=</span> os.<span style="color:#50fa7b">OpenFile</span>(cacheFile, os.O_RDWR, <span style="color:#bd93f9">0666</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		klog.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;Failed to open cache file: %s, error: %v&#34;</span>, cacheFile, err)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, err
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">defer</span> <span style="color:#8be9fd;font-style:italic">func</span>(f <span style="color:#ff79c6">*</span>os.File) {
</span></span><span style="display:flex;"><span>		_ = f.<span style="color:#50fa7b">Close</span>()
</span></span><span style="display:flex;"><span>	}(f)
</span></span><span style="display:flex;"><span>	usage <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&amp;</span>ContainerUsage{}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 将cache文件映射到内存
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// - 内存映射文件
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 参数说明：
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// - fd: 文件描述符
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// - offset: 从文件开始处的偏移量
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// - length: 要映射的字节数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// - prot: 内存保护标志 (读/写)
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// - flags: 映射标志
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	usage.data, err = syscall.<span style="color:#50fa7b">Mmap</span>(<span style="color:#8be9fd;font-style:italic">int</span>(f.<span style="color:#50fa7b">Fd</span>()), <span style="color:#bd93f9">0</span>, <span style="color:#8be9fd;font-style:italic">int</span>(info.<span style="color:#50fa7b">Size</span>()), syscall.PROT_WRITE|syscall.PROT_READ, syscall.MAP_SHARED)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>		klog.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;Failed to mmap cache file: %s, error: %v&#34;</span>, cacheFile, err)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, err
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 将[]byte转换为结构体指针
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	head <span style="color:#ff79c6">:=</span> (<span style="color:#ff79c6">*</span>headerT)(unsafe.<span style="color:#50fa7b">Pointer</span>(<span style="color:#ff79c6">&amp;</span>usage.data[<span style="color:#bd93f9">0</span>]))
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 校验initializedFlag，不清楚为什么SharedRegionMagicFlag=19920718
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">if</span> head.initializedFlag <span style="color:#ff79c6">!=</span> SharedRegionMagicFlag {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 释放内存映射
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		_ = syscall.<span style="color:#50fa7b">Munmap</span>(usage.data)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;cache file magic flag not matched&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 检查cache文件大小，为什么跟1197897比较，看起来是针对特定版本的NVIDIA GPU监控数据结构的大小
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// usage.data 是通过 syscall.Mmap 映射的文件内容
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// v0.CastSpec 和 v1.CastSpec 分别处理不同版本的数据格式
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 两个版本都实现了UsageInfo接口
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">if</span> info.<span style="color:#50fa7b">Size</span>() <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">1197897</span> {
</span></span><span style="display:flex;"><span>		usage.Info = v0.<span style="color:#50fa7b">CastSpec</span>(usage.data)
</span></span><span style="display:flex;"><span>	} <span style="color:#ff79c6">else</span> <span style="color:#ff79c6">if</span> head.majorVersion <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">1</span> {
</span></span><span style="display:flex;"><span>		usage.Info = v1.<span style="color:#50fa7b">CastSpec</span>(usage.data)
</span></span><span style="display:flex;"><span>	} <span style="color:#ff79c6">else</span> {
</span></span><span style="display:flex;"><span>		_ = syscall.<span style="color:#50fa7b">Munmap</span>(usage.data)
</span></span><span style="display:flex;"><span>		<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>, fmt.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;unknown cache file size %d version %d.%d&#34;</span>, info.<span style="color:#50fa7b">Size</span>(), head.majorVersion, head.minorVersion)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> usage, <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>vGPUmonitor metrics，如何初始化？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#6272a4">// NewClusterManager first creates a Prometheus-ignorant ClusterManager
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// instance. Then, it creates a ClusterManagerCollector for the just created
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// ClusterManager. Finally, it registers the ClusterManagerCollector with a
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// wrapping Registerer that adds the zone as a label. In this way, the metrics
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// collected by different ClusterManagerCollectors do not collide.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">NewClusterManager</span>(zone <span style="color:#8be9fd">string</span>, reg prometheus.Registerer, containerLister <span style="color:#ff79c6">*</span>nvidia.ContainerLister) <span style="color:#ff79c6">*</span>ClusterManager {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 创建一个ClusterManager实例
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	c <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">&amp;</span>ClusterManager{
</span></span><span style="display:flex;"><span>		Zone:            zone,
</span></span><span style="display:flex;"><span>		containerLister: containerLister,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 创建一个PodLister实例，用于获取Pod信息
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	informerFactory <span style="color:#ff79c6">:=</span> informers.<span style="color:#50fa7b">NewSharedInformerFactoryWithOptions</span>(containerLister.<span style="color:#50fa7b">Clientset</span>(), time.Hour<span style="color:#ff79c6">*</span><span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>	c.PodLister = informerFactory.<span style="color:#50fa7b">Core</span>().<span style="color:#50fa7b">V1</span>().<span style="color:#50fa7b">Pods</span>().<span style="color:#50fa7b">Lister</span>()
</span></span><span style="display:flex;"><span>	stopCh <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>(<span style="color:#8be9fd;font-style:italic">chan</span> <span style="color:#8be9fd;font-style:italic">struct</span>{})
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 启动informerFactory，用于获取Pod信息
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	informerFactory.<span style="color:#50fa7b">Start</span>(stopCh)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 创建一个ClusterManagerCollector实例，用于收集metrics
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	cc <span style="color:#ff79c6">:=</span> ClusterManagerCollector{ClusterManager: c}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 将ClusterManagerCollector实例注册到prometheus
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	prometheus.<span style="color:#50fa7b">WrapRegistererWith</span>(prometheus.Labels{<span style="color:#f1fa8c">&#34;zone&#34;</span>: zone}, reg).<span style="color:#50fa7b">MustRegister</span>(cc)
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">return</span> c
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如何持续监控容器使用情况？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">watchAndFeedback</span>(lister <span style="color:#ff79c6">*</span>nvidia.ContainerLister) {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 初始化 NVIDIA Management Library
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    nvml.<span style="color:#50fa7b">Init</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 无限循环，持续监控
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">for</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 每5秒执行一次
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        time.<span style="color:#50fa7b">Sleep</span>(time.Second <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">5</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 更新容器列表器实例的containers map
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        err <span style="color:#ff79c6">:=</span> lister.<span style="color:#50fa7b">Update</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> err <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// 如果更新失败，记录错误并继续下一次循环
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            klog.<span style="color:#50fa7b">Errorf</span>(<span style="color:#f1fa8c">&#34;Failed to update container list: %v&#34;</span>, err)
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">continue</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 观察并处理容器状态
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#50fa7b">Observe</span>(lister)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#6272a4">// Observe 监控和管理容器的 GPU 使用状态
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">Observe</span>(lister <span style="color:#ff79c6">*</span>nvidia.ContainerLister) {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 初始化设备利用率开关映射，key是GPU UUID，value是每个优先级的使用计数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    utSwitchOn <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">map</span>[<span style="color:#8be9fd">string</span>]UtilizationPerDevice{}
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 获取containers map
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    containers <span style="color:#ff79c6">:=</span> lister.<span style="color:#50fa7b">ListContainers</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 第一次遍历：统计每个 GPU 设备的使用情况
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">for</span> _, c <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> containers {
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 获取容器的最近内核使用计数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        recentKernel <span style="color:#ff79c6">:=</span> c.Info.<span style="color:#50fa7b">GetRecentKernel</span>()
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> recentKernel &gt; <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// 递减内核使用计数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            recentKernel<span style="color:#ff79c6">--</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> recentKernel &gt; <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// 遍历容器使用的所有 GPU 设备
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; i &lt; c.Info.<span style="color:#50fa7b">DeviceMax</span>(); i<span style="color:#ff79c6">++</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#6272a4">// 跳过无效的 GPU UUID
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                    <span style="color:#ff79c6">if</span> !c.Info.<span style="color:#50fa7b">IsValidUUID</span>(i) {
</span></span><span style="display:flex;"><span>                        <span style="color:#ff79c6">continue</span>
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#6272a4">// 获取 GPU 的 UUID
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                    uuid <span style="color:#ff79c6">:=</span> c.Info.<span style="color:#50fa7b">DeviceUUID</span>(i)
</span></span><span style="display:flex;"><span>                    <span style="color:#6272a4">// 如果是新设备，初始化优先级计数数组 [0, 0]
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                    <span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">len</span>(utSwitchOn[uuid]) <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>                        utSwitchOn[uuid] = []<span style="color:#8be9fd">int</span>{<span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0</span>}
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    <span style="color:#6272a4">// 增加对应优先级的使用计数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                    utSwitchOn[uuid][c.Info.<span style="color:#50fa7b">GetPriority</span>()]<span style="color:#ff79c6">++</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">// 更新容器的内核使用计数
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            c.Info.<span style="color:#50fa7b">SetRecentKernel</span>(recentKernel)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// 第二次遍历：根据统计结果更新容器状态
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">for</span> idx, c <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> containers {
</span></span><span style="display:flex;"><span>        priority <span style="color:#ff79c6">:=</span> c.Info.<span style="color:#50fa7b">GetPriority</span>()
</span></span><span style="display:flex;"><span>        recentKernel <span style="color:#ff79c6">:=</span> c.Info.<span style="color:#50fa7b">GetRecentKernel</span>()
</span></span><span style="display:flex;"><span>        utilizationSwitch <span style="color:#ff79c6">:=</span> c.Info.<span style="color:#50fa7b">GetUtilizationSwitch</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 检查是否需要阻塞（有更高优先级的任务在使用）
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">if</span> <span style="color:#50fa7b">CheckBlocking</span>(utSwitchOn, priority, c) {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> recentKernel <span style="color:#ff79c6">&gt;=</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>                klog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;utSwitchon=%v&#34;</span>, utSwitchOn)
</span></span><span style="display:flex;"><span>                klog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;Setting Blocking to on %v&#34;</span>, idx)
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// 设置阻塞状态
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                c.Info.<span style="color:#50fa7b">SetRecentKernel</span>(<span style="color:#ff79c6">-</span><span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#ff79c6">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> recentKernel &lt; <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>                klog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;utSwitchon=%v&#34;</span>, utSwitchOn)
</span></span><span style="display:flex;"><span>                klog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;Setting Blocking to off %v&#34;</span>, idx)
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// 解除阻塞状态
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                c.Info.<span style="color:#50fa7b">SetRecentKernel</span>(<span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4">// 检查优先级冲突（同优先级是否有多个任务）
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">if</span> <span style="color:#50fa7b">CheckPriority</span>(utSwitchOn, priority, c) {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> utilizationSwitch <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">1</span> {
</span></span><span style="display:flex;"><span>                klog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;utSwitchon=%v&#34;</span>, utSwitchOn)
</span></span><span style="display:flex;"><span>                klog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;Setting UtilizationSwitch to on %v&#34;</span>, idx)
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// 开启利用率限制
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                c.Info.<span style="color:#50fa7b">SetUtilizationSwitch</span>(<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#ff79c6">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> utilizationSwitch <span style="color:#ff79c6">!=</span> <span style="color:#bd93f9">0</span> {
</span></span><span style="display:flex;"><span>                klog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;utSwitchon=%v&#34;</span>, utSwitchOn)
</span></span><span style="display:flex;"><span>                klog.<span style="color:#50fa7b">Infof</span>(<span style="color:#f1fa8c">&#34;Setting UtilizationSwitch to off %v&#34;</span>, idx)
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">// 关闭利用率限制
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                c.Info.<span style="color:#50fa7b">SetUtilizationSwitch</span>(<span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个函数实现了一个优先级基础的 GPU 资源管理机制：</p>
<ul>
<li>统计每个 GPU 设备上不同优先级任务的数量</li>
<li>根据优先级规则决定是否阻塞低优先级任务</li>
<li>处理同优先级任务的资源竞争</li>
<li>通过日志记录状态变化</li>
</ul>
<p>这种机制可以确保：</p>
<ul>
<li>高优先级任务优先获得GPU资源</li>
<li>同优先级任务公平共享GPU资源</li>
<li>低优先级任务在资源充足时才能运行</li>
</ul>
<h1 id="参考链接">参考链接</h1>
<ul>
<li><a href="https://project-hami.io/docs/core-concepts/architecture">HAMi官方部署文档</a></li>
<li><a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html">Nvidia Container Toolkit</a></li>
<li><a href="https://www.lixueduan.com/posts/ai/01-how-to-use-gpu/">GPU 环境搭建指南：如何在裸机、Docker、K8s 等环境中使用 GPU</a></li>
<li><a href="https://www.lixueduan.com/posts/ai/02-gpu-operator/">GPU 环境搭建指南：使用 GPU Operator 加速 Kubernetes GPU 环境搭建</a></li>
<li><a href="https://www.lixueduan.com/posts/kubernetes/21-device-plugin/">Kubernetes教程(二一)—自定义资源支持：K8s Device Plugin 从原理到实现</a></li>
</ul>


                
                
<div class="entry-shang text-center">
    
	    <p>「真诚赞赏，手留余香」</p>
	
	<button class="zs show-zs btn btn-bred">赞赏支持</button>
</div>
<div class="zs-modal-bg"></div>
<div class="zs-modal-box">
	<div class="zs-modal-head">
		<button type="button" class="close">×</button>
		<span class="author"><a href="https://www.iceyao.com.cn/"><img src="/img/favicon.png" />爱折腾的工程师</a></span>
        
	        <p class="tip"><i></i><span>真诚赞赏，手留余香</span></p>
		
 
	</div>
	<div class="zs-modal-body">
		<div class="zs-modal-btns">
			<button class="btn btn-blink" data-num="2">2元</button>
			<button class="btn btn-blink" data-num="5">5元</button>
			<button class="btn btn-blink" data-num="10">10元</button>
			<button class="btn btn-blink" data-num="50">50元</button>
			<button class="btn btn-blink" data-num="100">100元</button>
			<button class="btn btn-blink" data-num="1">任意金额</button>
		</div>
		<div class="zs-modal-pay">
			<button class="btn btn-bred" id="pay-text">2元</button>
			<p>使用<span id="pay-type">微信</span>扫描二维码完成支付</p>
			<img src="/img/reward/wechat-2.png"  id="pay-image"/>
		</div>
	</div>
	<div class="zs-modal-footer">
		<label><input type="radio" name="zs-type" value="wechat" class="zs-type" checked="checked"><span ><span class="zs-wechat"><img src="/img/reward/wechat-btn.png"/></span></label>
		<label><input type="radio" name="zs-type" value="alipay" class="zs-type" class="zs-alipay"><img src="/img/reward/alipay-btn.png"/></span></label>
	</div>
</div>
<script type="text/javascript" src="/js/reward.js"></script>

                

                
                <hr>
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2024/08/26/dify-readnotes/" data-toggle="tooltip" data-placement="top" title="dify学习笔记">&larr;
                            Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2025/02/10/vllm-readnotes/" data-toggle="tooltip" data-placement="top" title="vLLM学习笔记(AI编程工具分析)">Next
                            Post &rarr;</a>
                    </li>
                    
                </ul>
                

                


<script src="https://giscus.app/client.js"
        data-repo="yaoice/yaoice.github.io"
        data-repo-id="R_kgDOJnxqVg"
        data-category="General"
        data-category-id="DIC_kwDOJnxqVs4CWwUs"
        data-mapping="pathname"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-theme="light"
        data-lang="en"
        crossorigin="anonymous"
        async>
</script>


            </div>

            
            
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
            

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                        
                        
                        
                        
                        
                        <a href="/tags/devops" title="devops">
                            devops
                        </a>
                        
                        
                        
                        <a href="/tags/go" title="go">
                            go
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/k8s" title="k8s">
                            k8s
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/llm" title="llm">
                            llm
                        </a>
                        
                        
                        
                        <a href="/tags/openstack" title="openstack">
                            openstack
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/tkestack" title="tkestack">
                            tkestack
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/%E7%BB%83%E8%BD%A6" title="练车">
                            练车
                        </a>
                        
                        
                    </div>
                </section>
                

                
                
            </div>
        </div>
    </div>
</article>









<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">                  
                    
                    <li>
                        <a href="mailto:yao3690093@gmail.com">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		           
                    
                    
                    
                    

		            
                    
                    <li>
                        <a target="_blank" href="/img/wechat.jpeg">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-weixin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		            
                    
                    <li>
                        <a target="_blank" href="https://github.com/yaoice">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		            
                    
                    
                    
                    
                    
                    
                    
                    
                    
            
            
            
           
                   <li>
                       <a href="/index.xml" rel="alternate" type="application/rss+xml" title="爱折腾的工程师" >
                           <span class="fa-stack fa-lg">
                               <i class="fas fa-circle fa-stack-2x"></i>
                               <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                           </span>
                       </a>
                   </li>
            
             </ul>
		<p class="copyright text-muted">
                    Copyright &copy; 爱折腾的工程师 2025
                </p>
            </div>
        </div>
    </div>
</footer>




<script>
    function loadAsync(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>






<script>
    
    if($('#tag_cloud').length !== 0){
        loadAsync("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>


<script>
    loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>



<script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https'){
       bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else{
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>


<script>
    
    var _baId = '92c175994ded75a3cd2074bc1123e2be';

    
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>




<script type="text/javascript">
    function generateCatalog(selector) {

        
        
        
        
            _containerSelector = 'div.post-container'
        

        
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        
        $(selector).html('')

        
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    
    $(".catalog-toggle").click((function (e) {
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    


    loadAsync("\/js\/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>







</body>
</html>
